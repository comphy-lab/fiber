[
  {
    "title": "Our Team & Collaborators - Vatsal Sanjay (PI)",
    "content": "[ ](https://github.com/VatsalSy) [ ](https://scholar.google.com/citations?user=tHb_qZoAAAAJ&hl=en) [ ](https://bsky.app/profile/comphy-lab.org) - [Postdoc, Phys. Fluids - Univ. Twente / 2022-25](https://pof.tnw.utwente.nl/people/profile/1330) - [Ph.D., Phys. Fluids - Univ. Twente / 2018-22](https://doi.org/10.3990/1.9789036554077) - [B.Tech + M.Tech, Two-Phase Flow & Instability Lab, IIT-Roorkee / 2013-18](http://dx.doi.org/10.13140/RG.2.2.22294.04166) - [Personal Website](https://vatsalsanjay.com) **Research Interest:** See [here](https://comphy-lab.org/research) [Download CV](https://raw.githubusercontent.com/VatsalSy/Vatsal_CV/master/Vatsal_CV.pdf){: .cv-button}",
    "url": "https://comphy-lab.org/team/#vatsal-sanjay-pi",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Ayush Dixit (Ph.D)",
    "content": "[ ](https://github.com/ayushkumardixit) [ ](https://scholar.google.com/citations?hl=en&user=ws43SmkAAAAJ) Joint with [Detlef Lohse](https://en.wikipedia.org/wiki/Detlef_Lohse) - [Ph.D. Student, Phys. Fluids - Univ. Twente / 2023-now](https://pof.tnw.utwente.nl/people/profile/2068) - [B.Tech + M.Tech, Two-Phase Flow & Instability Lab, IIT-Roorkee / 2018-23](http://dx.doi.org/10.13140/RG.2.2.23218.79040) **Research Interest:** Viscoelastic Flows, Bursting Bubbles, Respiratory Drops.",
    "url": "https://comphy-lab.org/team/#ayush-dixit-phd",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Aman Bhargava (Ph.D)",
    "content": "[ ](https://github.com/amanb1901) [ ](https://scholar.google.com/citations?hl=en&user=AmGOP8gAAAAJ) Joint with [Detlef Lohse](https://en.wikipedia.org/wiki/Detlef_Lohse) - [Ph.D. Student, Phys. Fluids - Univ. Twente / 2024-now](https://pof.tnw.utwente.nl/people/profile/2120) - M.Sc. Chemical Engineering, Purdue University / 2022-23 - B.Tech. (Hons.) Chemical Engineering, IIT-Bombay / 2018-22 **Research Interest:** Inertial Contact Line, Drop Retraction.",
    "url": "https://comphy-lab.org/team/#aman-bhargava-phd",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Jnandeep Talukdar (M.Sc.)",
    "content": "[ ](https://github.com/spilltheT) [ ](https://scholar.google.com/citations?hl=en&user=Coxj4VQAAAAJ) [ ](https://bsky.app/profile/jnandeep.bsky.social) Joint with [Detlef Lohse](https://en.wikipedia.org/wiki/Detlef_Lohse) - Ph.D. Student, Phys. Fluids - Univ. Twente / **starting** May 2025 - [M.Sc. Student, Phys. Fluids - Univ. Twente / 2023-25](https://pof.tnw.utwente.nl/people/profile/1938) - B.Tech. Mechanical Engineering, IIT-Patna / 2019-23 **Research Interest:** Surfactant Dynamics, Dissipative Anomaly, Soft Wetting.",
    "url": "https://comphy-lab.org/team/#jnandeep-talukdar-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Saumili Jana (M.Sc.)",
    "content": "[ ](https://github.com/SaumiliJana) Joint with [Detlef Lohse](https://en.wikipedia.org/wiki/Detlef_Lohse) - Ph.D. Student, Phys. Fluids - Univ. Twente / **starting** Jul 2025 - B.Tech.+M.Tech. Student, IIT-Kharagpur / 2020-25 - [Research Intern, Phys. Fluids - Univ. Twente / 2024](https://pof.tnw.utwente.nl/people/profile/2152) **Research Interest:** Soft Impact.",
    "url": "https://comphy-lab.org/team/#saumili-jana-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Floris Hoek (M.Sc.)",
    "content": "[ ](https://github.com/Floris-Hoek) Joint with [Martin van der Hoef](https://pof.tnw.utwente.nl/people/profile/244) and [Alvaro Marin](https://pof.tnw.utwente.nl/people/profile/243) - [M.Sc. Student, Phys. Fluids - Univ. Twente / 2024](https://pof.tnw.utwente.nl/people/profile/1937) **Research Interest:** Molecular Dynamics Simulations of Evaporation-Driven Colloidal Self-Assembly.",
    "url": "https://comphy-lab.org/team/#floris-hoek-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - We need you!",
    "content": "See: [Join Us](https://github.com/VatsalSy/Project-ideas-for-prospective-students) for ongoing projects.",
    "url": "https://comphy-lab.org/team/#we-need-you",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Detlef Lohse",
    "content": "[ ](https://scholar.google.com/citations?user=WvP_pIUAAAAJ) [ ](https://x.com/detlef_lohse) - [Professor, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/3) **Collaboration on:** Drop Impact, Viscoelastic Flows, Dissipative Anomaly, Surfactant Dynamics, Electrolysis, Bubbles, and Everything in Between.",
    "url": "https://comphy-lab.org/team/#detlef-lohse",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Jacco Snoeijer",
    "content": "[ ](https://scholar.google.com/citations?user=7qdux_4AAAAJ&hl=nl) - [Professor, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/21) **Collaboration on:** Elastic Sheets, Viscoelasticity vs. Elasticity, Surfactant Dynamics, Spinning Pizza.",
    "url": "https://comphy-lab.org/team/#jacco-snoeijer",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dominik Krug",
    "content": "[ ](https://scholar.google.com/citations?user=qGEpq7IAAAAJ&hl=en&inst=5726176096060060532&oi=ao) - [Professor, RWTH Aachen University](https://www.aia.rwth-aachen.de/) - [Adjunct Professor, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1199) **Collaboration on:** Electrolysis, Bubble Coalescence, Swimming Bubbles.",
    "url": "https://comphy-lab.org/team/#dominik-krug",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Maziyar Jalaal",
    "content": "[ ](https://scholar.google.com/citations?user=FE8TQeUAAAAJ) [ ](https://x.com/maziyarj) [ ](https://bsky.app/profile/mazi1.bsky.social) - **Mazi** [Associate Professor, Fluid Lab, Univ. Amsterdam](https://www.fluidlab.nl/) **Collaboration on:** Plastocapillarity, Viscoplastic Flows.",
    "url": "https://comphy-lab.org/team/#maziyar-jalaal",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Uddalok Sen",
    "content": "[ ](https://scholar.google.com/citations?user=a6h2uMQAAAAJ) - **Udo** [Assistant Professor, PhySM, Wageningen University and Research](https://www.physm-lab.org/) **Collaboration on:** Drop Impact, Sheet Retraction.",
    "url": "https://comphy-lab.org/team/#uddalok-sen",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Alvaro Marin",
    "content": "[ ](https://scholar.google.com/citations?user=0_jOqqkAAAAJ) [ ](https://github.com/alvarogum) [ ](https://x.com/AlvaroGMarin) [ ](https://bsky.app/profile/alvaromarin.bsky.social) - [Adjunct Professor, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/243) **Collaboration on:** Colloidal Systems, Evaporation, Shell Formation.",
    "url": "https://comphy-lab.org/team/#alvaro-marin",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Christian Diddens",
    "content": "[ ](https://scholar.google.com/citations?user=3QSyucwAAAAJ&hl=en&inst=5726176096060060532&oi=ao) [ ](https://github.com/cdiddens) - [Group Leader, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1143) - [Developer of pyoomph](https://pyoomph.github.io/) **Collaboration on:** Surfactant Dynamics in Free Surface Flows, Dissipative Anomaly, Sliding Drops.",
    "url": "https://comphy-lab.org/team/#christian-diddens",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Gareth McKinley",
    "content": "[ ](https://scholar.google.com/citations?user=uLxFfGkAAAAJ) [ ](https://en.wikipedia.org/wiki/Gareth_H._McKinley) [ ](https://x.com/garethmckinley) - [Professor, MIT](https://nnf.mit.edu/) **Collaboration on:** Die-Swelling, Viscoelastic Flows.",
    "url": "https://comphy-lab.org/team/#gareth-mckinley",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - John Kolinski",
    "content": "[ ](https://scholar.google.com/citations?user=BDzF8kMAAAAJ) [ ](https://en.wikipedia.org/wiki/John_Martin_Kolinski) - [Asst. Professor, EPFL (\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne)](https://people.epfl.ch/john.kolinski) **Collaboration on:** Soft Impact",
    "url": "https://comphy-lab.org/team/#john-kolinski",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - C. Ricardo Constante-Amores",
    "content": "[ ](https://scholar.google.com/citations?user=ncqnphMAAAAJ) [ ](https://github.com/rcrc15) - [Asst. Professor, Univ. Illinois Urbana-Champaign](https://publish.illinois.edu/constanteamores/home/) **Collaboration on:** Non-Newtonian Flows, Bubble Bursting, Herschel--Bulkley Fluids, Elastic Coating.",
    "url": "https://comphy-lab.org/team/#c-ricardo-constante-amores",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Radu Cimpeanu",
    "content": "[ ](https://scholar.google.com/citations?user=6grZnhQAAAAJ&hl=en&inst=5726176096060060532&oi=ao) [ ](https://x.com/rcimpeanu) [ ](https://github.com/RaduCimpeanu) - [Assc. Professor, Univ. Warwick](https://www.raducimpeanu.com/) **Collaboration on:** Open-Source Code Development, Non-Coalescence Impacts.",
    "url": "https://comphy-lab.org/team/#radu-cimpeanu",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Jie Feng",
    "content": "[ ](https://scholar.google.com/citations?user=226dDBAAAAAJ) [ ](https://x.com/FengFluidsLab) - [Asst. Professor, Univ. Illinois Urbana-Champaign](https://fengfluidslab.web.illinois.edu/wp/) **Collaboration on:** Elastic Coating, Bursting Bubbles.",
    "url": "https://comphy-lab.org/team/#jie-feng",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Omar Matar",
    "content": "[ ](https://scholar.google.com/citations?user=mLXz_NAAAAAJ&hl=en) [ ](https://x.com/okmatar?lang=en) - [Professor, Imperial College London](https://profiles.imperial.ac.uk/o.matar) **Collaboration on:** Surfactant Dynamics, Viscoelastic Drop Impact.",
    "url": "https://comphy-lab.org/team/#omar-matar",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Ratul Dasgupta",
    "content": "[ ](https://scholar.google.com/citations?user=I1jFG_oAAAAJ) [ ](https://x.com/RatulDG) - [Assc. Professor, IIT-Bombay](https://sites.google.com/view/ratuldasgupta/home) **Collaboration on:** Waves, Dissipative Anomaly.",
    "url": "https://comphy-lab.org/team/#ratul-dasgupta",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Eric Lauga",
    "content": "[ ](https://scholar.google.com/citations?hl=en&user=5ObY7hsAAAAJ) - [Professor, Univ. Cambridge](https://www.damtp.cam.ac.uk/user/lauga/) **Collaboration on:** Mycofluidic Transport.",
    "url": "https://comphy-lab.org/team/#eric-lauga",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Saikat Datta",
    "content": "[ ](https://scholar.google.com/citations?user=o4mXtIgAAAAJ) - Senior Lecturer, Swansea University **Collaboration on:** Multiscale Simulation, Ice Nucleation and Removal, Hydrogen Storage.",
    "url": "https://comphy-lab.org/team/#saikat-datta",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Doris Vollmer",
    "content": "[ ](https://orcid.org/0000-0001-9599-5589) - [Apl. Professor, Max Planck Institute for Polymer Research, Mainz, Germany.](https://www.mpip-mainz.mpg.de/en/butt/groups/vollmer) **Collaboration on:** Contact Line, Drop Impact, Superhydrophobic Surfaces.",
    "url": "https://comphy-lab.org/team/#doris-vollmer",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - St\u00e9phane Zaleski",
    "content": "[ ](https://scholar.google.com/citations?hl=en&user=no1GX_QAAAAJ) [ ](https://x.com/zaleski) - [Professor, Sorbonne Universite](http://www.ida.upmc.fr/~zaleski/zaleski.html) **Collaboration on:** Holey Sheets.",
    "url": "https://comphy-lab.org/team/#st\u00e9phane-zaleski",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Pierre Chantelot",
    "content": "[ ](https://scholar.google.nl/citations?user=BQWXUKYAAAAJ) - [Postdoc, Institut Langevin, ESPCI Paris](https://sites.google.com/view/pierre-chantelot/) **Collaboration on:** Drop Impact",
    "url": "https://comphy-lab.org/team/#pierre-chantelot",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Aleksandr Bashkatov",
    "content": "[ ](https://scholar.google.com/citations?user=9_vPSFsAAAAJ&hl=en&inst=5726176096060060532&oi=ao) - [Postdoc, RWTH Aachen University](https://scholar.google.com/citations?user=9_vPSFsAAAAJ&hl=en&inst=5726176096060060532&oi=ao) **Collaboration on:** Electrolysis, Bubble Coalescence, Swimming Bubbles.",
    "url": "https://comphy-lab.org/team/#aleksandr-bashkatov",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Vincent Bertin",
    "content": "[ ](https://scholar.google.com/citations?user=jO_RTLR2xBYC&hl=en&inst=5726176096060060532&oi=ao) - [Postdoc, University Aix-Marseille ](https://vincent-bertin.github.io/) **Collaboration on:** Elastic Sheets, Spinning Pizza.",
    "url": "https://comphy-lab.org/team/#vincent-bertin",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Alexandros Oratis",
    "content": "[ ](https://scholar.google.com/citations?user=2lOr8WQAAAAJ&hl=en&inst=5726176096060060532&oi=ao) - [Postdoc, TU Delft](https://garbinlab.org/people/) **Collaboration on:** Electrolysis, Bubble Coalescence, Swimming Bubbles.",
    "url": "https://comphy-lab.org/team/#alexandros-oratis",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Arivazhagan Balasubramanian (Ari)",
    "content": "[ ](https://scholar.google.com/citations?user=xyheRZ8AAAAJ) [ ](https://github.com/GbArivazhagan) [ ](https://bsky.app/profile/gbarivaz.bsky.social) - [Ph.D. Student, KTH Sweden](https://www.kth.se/profile/argb?l=en) **Collaboration on:** Elastoviscoplastic Flows, Bursting Bubbles",
    "url": "https://comphy-lab.org/team/#arivazhagan-balasubramanian-ari",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Konstantinos Zinelis (Costis)",
    "content": "[ ](https://scholar.google.com/citations?user=dZrR_z8AAAAJ&hl=en&inst=5726176096060060532&oi=ao) [ ](https://x.com/KZinelis) - [Postdoc, MIT](https://qigroup.mit.edu/team/) **Collaboration on:** Viscoelastic Flows, Drop Impact.",
    "url": "https://comphy-lab.org/team/#konstantinos-zinelis-costis",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Milan Sent",
    "content": "[ ](https://github.com/mdjsent) - **2025:** Graduated with B.Sc., Univ. Twente - **Thesis:** [Spinning Pizza](https://tinyurl.com/2ycunjcr)",
    "url": "https://comphy-lab.org/team/#milan-sent",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Valentin Rosario",
    "content": "[ ](https://www.linkedin.com/in/valentin-rosario-6377602b2/?originalSubdomain=nl) [ ](https://github.com/ValeRos9) - **2024:** Graduated with M.Sc., Univ. Amsterdam - **Thesis:** [Modelling the Ward--Hunt ice-shelf as viscoelastic solid](https://tinyurl.com/2cjsjvr4)",
    "url": "https://comphy-lab.org/team/#valentin-rosario",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Swen van den Heuvel",
    "content": "[ ](https://www.linkedin.com/in/swen-van-den-heuvel-33a1901aa/) - **Now:** [Ph.D. Student, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/2119) - **2023:** [Graduated with M.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/2119) - **Thesis:** [Hydrodynamic forces acting on vertically rising bubbles](https://bit.ly/4er5VaH)",
    "url": "https://comphy-lab.org/team/#swen-van-den-heuvel",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Niels Kuipers",
    "content": "[ ](https://www.linkedin.com/in/nielskuipers1/) - **Now:** M.Sc. Student, Adv. Technology - Univ. Twente - **2023:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/2064) - **Thesis:** [Partial coalescence of drops on viscous films](https://tinyurl.com/258jvdyv)",
    "url": "https://comphy-lab.org/team/#niels-kuipers",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - C. H. (Luuk) Maurits",
    "content": "- **2023:** [Graduated with M.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1741) - **Thesis:** [When Laplace meets Marangoni](https://bit.ly/ThesisLuuk)",
    "url": "https://comphy-lab.org/team/#c-h-luuk-maurits",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Tom Appleford",
    "content": "- **Now:** [Ph.D. Student, Fluid Lab - Univ. Amsterdam](https://www.fluidlab.nl/team) - **2022:** [Graduated with M.Sc., Univ. Amsterdam](https://pof.tnw.utwente.nl/people/profile/1741) - **Thesis:** [The deformation of a droplet in a viscoplastic simple shear flow](https://bit.ly/ThesisTom)",
    "url": "https://comphy-lab.org/team/#tom-appleford",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Twan Heijink",
    "content": "[ ](https://www.linkedin.com/in/twanheijink/) - **Now:** Software IVQA Engineer at Thales - **2021:** [Graduated with B.Sc., Saxion Univ.](https://pof.tnw.utwente.nl/people/profile/1822) - **Thesis:** [Standing waves at a fluid-fluid interface with plastocapillarity](https://bit.ly/ThesisTwanHeijink)",
    "url": "https://comphy-lab.org/team/#twan-heijink",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Steven Meuleman",
    "content": "[ ](https://www.linkedin.com/in/steven-meuleman/) - **Now:** Mechanical Engineer at VIRO - **2020:** Graduated with B.Sc., Univ. Twente - **Thesis:** [Simulations of foam generation for a custom axisymmetric core-shell nozzle](https://bit.ly/ThesisStevenM)",
    "url": "https://comphy-lab.org/team/#steven-meuleman",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Thijmen Kroeze",
    "content": "[ ](https://www.linkedin.com/in/thijmen-kroeze-535aa3207/) - **Now:** CFD Engineer, Brink Climate Systems - **2020:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1630) - **Thesis:** [Singular jet dynamics of drop impacts at high Bond numbers](https://bit.ly/ThesisThijmenKroeze)",
    "url": "https://comphy-lab.org/team/#thijmen-kroeze",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Coen Verschuur",
    "content": "- **Now:** [Ph.D. Student, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1709) - **2020:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1709) - **Thesis:** [Early time dynamics in immiscible drop impacts](https://bit.ly/ThesisCoenVerschuur)",
    "url": "https://comphy-lab.org/team/#coen-verschuur",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Pim J. Dekker",
    "content": "[ ](https://www.linkedin.com/in/pim-dekker/) - **Now:** [Ph.D. Student, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1431) - **2019:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1431) - **Thesis:** [Spreading of a drop on a water-air interface](https://bit.ly/ThesisPimDekker) ](https://github.com/zhangxyPHD) - **2024:** [Guest Researcher, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/2209) - City University of Hong Kong, China **Research Interest:** Viscoplastic Drop Impact. -->",
    "url": "https://comphy-lab.org/team/#pim-j-dekker",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Laurence Bruggink",
    "content": "[ ](https://www.linkedin.com/in/laurence-bruggink-b733b222a/) - **Now:** Research Engineer at Alfen - **2019:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1518) - **Thesis:** [Bursting bubble in a Herschel--Bulkley fluid](https://bit.ly/ThesisLaurenceBruggink)",
    "url": "https://comphy-lab.org/team/#laurence-bruggink",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "[11]Sanjay, V., Chantelot, P., & Lohse, D. When does an impacting drop stop bouncing? J. Fluid Mech., 958, A26 (2023).",
    "content": "[11]Sanjay, V., Chantelot, P., & Lohse, D. When does an impacting drop stop bouncing? J. Fluid Mech., 958, A26 (2023).",
    "url": "https://comphy-lab.org/research/#11",
    "type": "paper",
    "tags": [
      "Drops",
      "Bouncing",
      "Dissipative anomaly",
      "Featured"
    ],
    "priority": 1
  },
  {
    "title": "[15]Sanjay, V., & Lohse, D. Unifying theory of scaling in drop impact: Forces & maximum spreading diameter. Phys. Rev. Lett., 134, 104003 (2025).",
    "content": "[15]Sanjay, V., & Lohse, D. Unifying theory of scaling in drop impact: Forces & maximum spreading diameter. Phys. Rev. Lett., 134, 104003 (2025).",
    "url": "https://comphy-lab.org/research/#15",
    "type": "paper",
    "tags": [
      "Drops",
      "Dissipative anomaly",
      "Superamphiphobic-surfaces",
      "Impact forces"
    ],
    "priority": 2
  },
  {
    "title": "[14]Sanjay, V., Zhang, B., Lv, C., & Lohse, D. The role of viscosity on drop impact forces on non-wetting surfaces. J. Fluid Mech., 1004, A6 (2025).",
    "content": "[14]Sanjay, V., Zhang, B., Lv, C., & Lohse, D. The role of viscosity on drop impact forces on non-wetting surfaces. J. Fluid Mech., 1004, A6 (2025).",
    "url": "https://comphy-lab.org/research/#14",
    "type": "paper",
    "tags": [
      "Drops",
      "Impact forces"
    ],
    "priority": 2
  },
  {
    "title": "[13] Kayal, L.,Sanjay, V., Yewale, N., Kumar, A., & Dasgupta, R. Focusing of concentric free-surface waves. J. Fluid Mech., 1003, A14 (2025).",
    "content": "[13] Kayal, L.,Sanjay, V., Yewale, N., Kumar, A., & Dasgupta, R. Focusing of concentric free-surface waves. J. Fluid Mech., 1003, A14 (2025).",
    "url": "https://comphy-lab.org/research/#13",
    "type": "paper",
    "tags": [
      "Waves",
      "Dissipative anomaly"
    ],
    "priority": 2
  },
  {
    "title": "[12] Balasubramanian, A. G.,Sanjay, V., Jalaal, M., Vinuesa, R., & Tammisola, O. Bursting bubble in an elastoviscoplastic medium. J. Fluid Mech., 1001, A9 (2024).",
    "content": "[12] Balasubramanian, A. G.,Sanjay, V., Jalaal, M., Vinuesa, R., & Tammisola, O. Bursting bubble in an elastoviscoplastic medium. J. Fluid Mech., 1001, A9 (2024).",
    "url": "https://comphy-lab.org/research/#12",
    "type": "paper",
    "tags": [
      "Bubbles",
      "Non-Newtonian",
      "Jets",
      "Soft-matter-singularities"
    ],
    "priority": 2
  },
  {
    "title": "[10]Sanjay, V., Lakshman, S., Chantelot, P., Snoeijer, J. H., & Lohse, D. Drop impact on viscous liquid films. J. Fluid Mech., 958, A25 (2023).",
    "content": "[10]Sanjay, V., Lakshman, S., Chantelot, P., Snoeijer, J. H., & Lohse, D. Drop impact on viscous liquid films. J. Fluid Mech., 958, A25 (2023).",
    "url": "https://comphy-lab.org/research/#10",
    "type": "paper",
    "tags": [
      "Drops",
      "Bouncing",
      "Superhydrophobic surfaces"
    ],
    "priority": 2
  },
  {
    "title": "\u27a1\ufe0fSanjay, V.Viscous free-surface flows. Ph.D. Thesis, Physics of Fluids, University of Twente (2022).",
    "content": "\u27a1\ufe0fSanjay, V.Viscous free-surface flows. Ph.D. Thesis, Physics of Fluids, University of Twente (2022).",
    "url": "https://comphy-lab.org/research/#thesis",
    "type": "paper",
    "tags": [
      "Drops",
      "Jets",
      "Sheets",
      "Bubbles",
      "Soft-matter-singularities",
      "Non-Newtonian"
    ],
    "priority": 2
  },
  {
    "title": "[9]Sanjay, V.Taylor--Culick retractions and the influence of the surroundings. J. Fluid Mech., 948, A14 (2022).",
    "content": "[9]Sanjay, V.Taylor--Culick retractions and the influence of the surroundings. J. Fluid Mech., 948, A14 (2022).",
    "url": "https://comphy-lab.org/research/#9",
    "type": "paper",
    "tags": [
      "Sheets",
      "Dissipative anomaly",
      "Retraction"
    ],
    "priority": 2
  },
  {
    "title": "[8] Zhang, B.,Sanjay, V., Shi, S., and Zhao, Y., and Lv, C., and Feng, X.-Q., & Lohse, D. Impact forces of water drops falling on superhydrophobic surfaces. Phys. Rev. Lett., 129(10), 104501 (2022).",
    "content": "[8] Zhang, B.,Sanjay, V., Shi, S., and Zhao, Y., and Lv, C., and Feng, X.-Q., & Lohse, D. Impact forces of water drops falling on superhydrophobic surfaces. Phys. Rev. Lett., 129(10), 104501 (2022).",
    "url": "https://comphy-lab.org/research/#8",
    "type": "paper",
    "tags": [
      "Drops",
      "Superhydrophobic surfaces",
      "Impact forces"
    ],
    "priority": 2
  },
  {
    "title": "[7]Sanjay, V., Lohse, D., & Jalaal, M. Bursting bubble in a viscoplastic medium. J. Fluid Mech., 922, A2 (2021).",
    "content": "[7]Sanjay, V., Lohse, D., & Jalaal, M. Bursting bubble in a viscoplastic medium. J. Fluid Mech., 922, A2 (2021).",
    "url": "https://comphy-lab.org/research/#7",
    "type": "paper",
    "tags": [
      "Bubbles",
      "Jets",
      "Non-Newtonian",
      "Soft-matter-singularities"
    ],
    "priority": 2
  },
  {
    "title": "[6] Ram\u00edrez-Soto, O.,Sanjay, V., Lohse, D., Pham, J. T., & Vollmer, D. Lifting a sessile oil drop from a superamphiphobic surface with an impacting one. Sci. Adv., 6(34), eaba4330 (2020).",
    "content": "[6] Ram\u00edrez-Soto, O.,Sanjay, V., Lohse, D., Pham, J. T., & Vollmer, D. Lifting a sessile oil drop from a superamphiphobic surface with an impacting one. Sci. Adv., 6(34), eaba4330 (2020).",
    "url": "https://comphy-lab.org/research/#6",
    "type": "paper",
    "tags": [
      "Drops",
      "Superamphiphobic-surfaces",
      "Lifting"
    ],
    "priority": 2
  },
  {
    "title": "[5] Jain, A.,Sanjay, V., & Das, A. K. Consequences of inclined and dual jet impingement in stagnant liquid and stratified layers. AIChE J., 65(1), 372-384 (2019).",
    "content": "[5] Jain, A.,Sanjay, V., & Das, A. K. Consequences of inclined and dual jet impingement in stagnant liquid and stratified layers. AIChE J., 65(1), 372-384 (2019).",
    "url": "https://comphy-lab.org/research/#5",
    "type": "paper",
    "tags": [
      "Jets",
      "Bubbles"
    ],
    "priority": 2
  },
  {
    "title": "[4] Soni, A.,Sanjay, V., & Das, A. K. Formation of fluid structures due to jet-jet and jet-sheet interactions. Chem. Eng. Sci., 191, 67-77 (2018).",
    "content": "[4] Soni, A.,Sanjay, V., & Das, A. K. Formation of fluid structures due to jet-jet and jet-sheet interactions. Chem. Eng. Sci., 191, 67-77 (2018).",
    "url": "https://comphy-lab.org/research/#4",
    "type": "paper",
    "tags": [
      "Jets"
    ],
    "priority": 2
  },
  {
    "title": "[3]Sanjay, V., Das, A.K. Numerical assessment of hazard in compartmental fire having steady heat release rate from the source. Build. Simul. 11, 613\u2013624 (2018).",
    "content": "[3]Sanjay, V., Das, A.K. Numerical assessment of hazard in compartmental fire having steady heat release rate from the source. Build. Simul. 11, 613\u2013624 (2018).",
    "url": "https://comphy-lab.org/research/#3",
    "type": "paper",
    "tags": [
      "Others",
      "Fire",
      "Evacuation"
    ],
    "priority": 2
  },
  {
    "title": "[2]Sanjay, V., & Das, A. K. Formation of liquid chain by collision of two laminar jets. Phys. Fluids, 29(11), 112101 (2017).",
    "content": "[2]Sanjay, V., & Das, A. K. Formation of liquid chain by collision of two laminar jets. Phys. Fluids, 29(11), 112101 (2017).",
    "url": "https://comphy-lab.org/research/#2",
    "type": "paper",
    "tags": [
      "Jets",
      "Sheets"
    ],
    "priority": 2
  },
  {
    "title": "[1]Sanjay, V., & Das, A. K. On air entrainment in a water pool by impingement of a jet. AIChE J., 63(11), 5169-5181 (2017).",
    "content": "[1]Sanjay, V., & Das, A. K. On air entrainment in a water pool by impingement of a jet. AIChE J., 63(11), 5169-5181 (2017).",
    "url": "https://comphy-lab.org/research/#1",
    "type": "paper",
    "tags": [
      "Jets",
      "Bubbles"
    ],
    "priority": 2
  },
  {
    "title": "Teaching - Teaching",
    "content": "Welcome to the CoMPhy Lab's educational resources. Apart from the university courses, we aim to develop and offer a range of workshops and tutorials on modern computational methods for multiphase flows and high-fidelity simulations. High-Fidelity Simulations Using Basilisk C Universidad Carlos III de Madrid March 10-13, 2025 A comprehensive course on using Basilisk C for simulating multiphase flows, interface tracking, and solving conservation equations. Learn to tackle complex fluid dynamics problems with high-fidelity numerical methods. View Course",
    "url": "https://comphy-lab.org/teaching/#teaching",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "Teaching - About Our Teaching Philosophy",
    "content": "At CoMPhy Lab, we believe in hands-on learning and deep understanding of computational methods. Our courses combine theoretical foundations with practical implementation, allowing students to develop both conceptual understanding and technical skills. Our teaching approach emphasizes: - **Think before you compute**: Understanding the underlying physics before implementation - **Modular code structure**: Building maintainable and extensible computational tools - **Advanced numerical methods**: Mastering state-of-the-art techniques for complex problems - **Open science**: Sharing knowledge and tools with the scientific community. Checkout If you're interested in hosting a course or workshop with CoMPhy Lab, please [contact us](/join) for collaboration opportunities.",
    "url": "https://comphy-lab.org/teaching/#about-our-teaching-philosophy",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\"",
    "content": "// Function to update image visibility based on theme function updateBannerImages() { const theme = document.documentElement.getAttribute('data-theme') || 'light'; const lightImages = document.querySelectorAll('.light-mode-img'); const darkImages = document.querySelectorAll('.dark-mode-img'); if (theme === 'dark') { lightImages.forEach(img => img.style.display = 'none'); darkImages.forEach(img => img.style.display = 'block'); } else { lightImages.forEach(img => img.style.display = 'block'); darkImages.forEach(img => img.style.display = 'none'); } } // Run on page load document.addEventListener('DOMContentLoaded', updateBannerImages); // Watch for theme changes const observer = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { if (mutation.attributeName === 'data-theme') { updateBannerImages(); } }); }); observer.observe(document.documentElement, { attributes: true });",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid",
    "type": "website_content",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - High-Fidelity Simulations Using Basilisk C",
    "content": "Dates March 10-13, 2025 Location Universidad Carlos III de Madrid, Spain Duration 4 days, full-time",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#high-fidelity-simulations-using-basilisk-c",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - What will you learn?",
    "content": "- **Think before you compute!** Understanding the physics before implementation - **Writing the first code in Basilisk C** Getting comfortable with the framework - **Solving conservation equations** Numerical approaches to fluid dynamics - **Interface tracking methods** Capturing multiphase phenomena accurately - **Non-Newtonian flows** Modeling complex rheological behaviors",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#what-will-you-learn",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Course Description",
    "content": "This intensive 4-day course provides a comprehensive introduction to high-fidelity simulations using Basilisk C, a powerful computational framework for fluid dynamics. Participants will learn to implement and solve complex fluid mechanics problems with an emphasis on multiphase flows, interface dynamics, and non-Newtonian rheology. The course combines theoretical lectures with extensive hands-on sessions, allowing participants to immediately apply concepts through guided coding exercises. By the end of the course, you'll be able to develop your own simulations for a variety of fluid dynamics applications.",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#course-description",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Think before you compute",
    "content": "- **10:00-11:30** &nbsp;|&nbsp; **Lecture (1a)** - Conservation laws and the numerical solution of the Navier\u2013Stokes equations - **11:45-13:00** &nbsp;|&nbsp; **Lecture (1b)** - Transport equations - *Brief intro to Basilisk coding framework*",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#think-before-you-compute",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - First coding steps",
    "content": "- **15:00-18:00** &nbsp;|&nbsp; **Hybrid Session** - Implementing basic transport equations in Basilisk C. - Using headers in Basilisk, modular code structure, problem setup, and compilation - *Whiteboard + coding* - [1st Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment)",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#first-coding-steps",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Coding like a pro",
    "content": "- **10:00-11:15** &nbsp;|&nbsp; **Hackathon (1c)** - Solving Navier\u2013Stokes equations in Basilisk C. - [2nd Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment) - **11:30-13:00** &nbsp;|&nbsp; **Hackathon Continued** - Expanding on the morning tasks and code debugging",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#coding-like-a-pro",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Interface tracking methods",
    "content": "- **10:00-11:30** &nbsp;|&nbsp; **Lecture (2a)** - Interface tracking methods (VoF, level set, phase-field approaches) and numerical strategies - **11:45-13:00** &nbsp;|&nbsp; **Hackathon (2b)** - Hands-on tutorial with interface-tracking to a simple two-phase problem - [3rd Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment)",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#interface-tracking-methods",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Seminar",
    "content": "- **13:30-14:00** &nbsp;|&nbsp; **Department seminar (2c)** - A note on the thrust of airfoils by [Jos\u00e9 Manuel Gordillo](https://scholar.google.com/citations?user=14wOsewAAAAJ&hl=en&inst=5726176096060060532&oi=ao)",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#seminar",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Non-Newtonian flows",
    "content": "- **15:00-16:00** &nbsp;|&nbsp; **Lecture (3a)** - Non-Newtonian flows: viscoelasticity. - **16:15-18:00** &nbsp;|&nbsp; **Hackathon (3b)** - Coding exercises for viscoelastic fluids. - [4th Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment)",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#non-newtonian-flows",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Special topics",
    "content": "- **10:00-11:30** &nbsp;|&nbsp; **Lecture (4a)** - Review and catching up on [4th Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment). - Special Topics: Three-phase flows, - **11:45-13:00** &nbsp;|&nbsp; **Hackathon (4b)** - Special Topics: Holey Sheets, Contact line dynamics. - **15:00-16:30** &nbsp;|&nbsp; **Lecture (4c)** - Open discussion, deeper dives into advanced features, final code reviews, and next steps. ---",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#special-topics",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Prerequisites",
    "content": "- Basic knowledge of fluid mechanics - Experience with programming (any language, C preferred) - Understanding of partial differential equations - Laptop with ability to compile C code",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#prerequisites",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Registration",
    "content": "For registration details, please contact bubbles@ing.uc3m.es vatsalsy@comphy-lab.org function copyEmail(button) { const textToCopy = button.getAttribute('data-text'); // Create a temporary textarea element to copy from const textarea = document.createElement('textarea'); textarea.value = textToCopy; textarea.setAttribute('readonly', ''); textarea.style.position = 'absolute'; textarea.style.left = '-9999px'; document.body.appendChild(textarea); // Select and copy the text textarea.select(); document.execCommand('copy'); // Remove the temporary element document.body.removeChild(textarea); // Show feedback const originalIcon = button.innerHTML; button.innerHTML = ' '; button.classList.add('copied'); // Restore original state after a delay setTimeout(() => { button.innerHTML = originalIcon; button.classList.remove('copied'); }, 2000); } Course GitHub Repository",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#registration",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Introduction",
    "content": "Bubble bursting at the liquid\u2013air interface is a ubiquitous phenomenon. Whether in a glass of champagne, a carbonated beverage, or a natural setting (e.g., mudpots, ocean spray), bubbles rise due to buoyancy and eventually rupture at the free surface. Upon bursting, the cavity created in the free surface collapses, generating jets and ejected droplets. These droplets play important roles in: - **Aromatic transport** in champagne and sparkling beverages. - **Pathogen and aerosol spread** in contaminated water or biological fluids (coughing, sneezing). - **Cloud formation** through sea spray in the atmosphere. - **Geophysical processes**, such as mudpots or volcanic lakes involving complex rheology.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - The Phenomenon",
    "content": "When the bubble film ruptures, a \u201chole\u201d forms in the thin liquid interface. Surface tension drives capillary waves that converge at the bottom of the cavity, shooting liquid upward in a narrow jet. This jet eventually breaks into droplets, as observed in: - **Champagne**: Enhancing aroma and flavor perception. - **Contaminated water**: Ejecting micro-droplets that can carry pathogens. - **Viscoplastic mud**: Where the yield stress of the medium significantly alters jet formation and droplet size. - **Viscoelastic fluids**: Such as mucosalivary fluids during sneezing or coughing. Extensive studies have addressed bubble bursting in Newtonian fluids (e.g., water). However, **non-Newtonian media**\u2014including **viscoplastic** (mud, clay suspensions) and **viscoelastic** (polymeric solutions, mucosal fluids)\u2014pose open research questions due to their complex rheological behavior.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#the-phenomenon",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Proposed Approach: This combined proposal...",
    "content": "This combined proposal integrates numerical simulations with potential experimental validation to capture the entire process: 1. **Fundamental Two-Phase Flow** - Implement and validate two-phase flow simulations (e.g., in [Basilisk C](http://basilisk.fr)) for bubble dynamics, jet formation, and droplet ejection in Newtonian fluids. 2. **Non-Newtonian Rheology** - Extend the code to handle **generalized Newtonian** and **viscoelastic** models. - Explore how capillary waves and cavity collapse are altered by viscoplastic or viscoelastic effects. 3. **Comparison & Validation** - Compare numerical results against known scaling laws [e.g., Duchemin et al. (2002), Walls et al. (2015), Deike et al. (2018)] and experimental data from ongoing parallel experiments. 4. **Applications & Implications** - Relate findings to **aroma transport** in champagne, **aerosol generation** in pathogen-laden fluids, and **cloud formation** via marine aerosol. - Draw analogies to droplet formation in **coughing/sneezing**, focusing on the role of viscoelasticity in droplet sizes and distribution.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#proposed-approach",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Skills & What You Will Learn",
    "content": "- **Fluid Dynamics Fundamentals** Develop an in-depth understanding of multiphase flows, capillary-driven phenomena, and wave\u2013interface interactions. - **Rheology** Learn how non-Newtonian properties (viscoplasticity, viscoelasticity) influence flow and droplet formation. - **Computational Techniques** Gain experience using open-source codes (e.g., Basilisk C) for high-resolution simulations, parameter sweeps, and data analysis. - **Collaboration** Work alongside experimentalists, compare numerical and laboratory results, and interact with theorists modeling related flows.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#skills-what-you-will-learn",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Supervision",
    "content": "| **Supervisor** | **Email** | **Office** | |-----------------------------|---------------------------------------------|---------------------------| | **Ayush Dixit** | [a.k.dixit@utwente.nl](mailto:a.k.dixit@utwente.nl) | Meander 250 | | **Coen Verschuur** | [c.i.verschuur@utwente.nl](mailto:c.i.verschuur@utwente.nl) | Meander 114B | | **Dr. Vatsal Sanjay** | [vatsalsanjay@gmail.com](mailto:vatsalsanjay@gmail.com) | Meander 246B | | **Dr. Alexandros Oratis** | [a.t.oratis@utwente.nl](mailto:a.t.oratis@utwente.nl) | TU Delft | | **Assis. Prof. Dr. Maziyar (Mazi) Jalaal** | [m.jalaal@uva.nl](mailto:m.jalaal@uva.nl) | University of Amsterdam | | **Prof. Dr. Detlef Lohse** | [d.lohse@utwente.nl](mailto:d.lohse@utwente.nl) | Meander 261 | Feel free to reach out to any of the listed supervisors for more details.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#supervision",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Key References",
    "content": "- Deike, L., et al. (2018). *Dynamics of jets produced by bursting bubbles.* - Duchemin, L., et al. (2002). *Jet formation in bubble bursting.* - Ghabache, E., et al. (2016). *Evaporation of droplets from bursting bubbles.* - Gordillo, J. M. (2019). *Capillary waves and jet formation in bubble collapse.* - Lhuissier, H., & Villermaux, E. (2012). *Bursting bubble film droplets.* - Walls, P. L. L., et al. (2015). *Jet drops from bursting bubbles: How gravity and viscosity couple to inhibit droplet production.* - Walls, A. C., et al. (2017). *Viscoelastic effects in droplet formation.* - Bourouiba, L. (2021). *Fluid dynamics of disease transmission.* - Sanjay, V., Lohse, D., & Jalaal, M. (2021). *Non-Newtonian bubble collapse in mudpots.*",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#key-references",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Computational Multiphase Physics <br> (CoMPhy)",
    "content": "Welcome to the CoMPhy Lab's documentation hub! We are based at the Physics of Fluids Department at the University of Twente, where we explore non-Newtonian free-surface flows and soft matter singularities.",
    "url": "https://blogs.comphy-lab.org/0_README/#computational-multiphase-physics-br-comphy",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Elastoinertial turbulence:",
    "content": "2025-02-24 [[Arrowheads in elastoinertial turbulence]]: Critical review of arrowhead structures in elastoinertial turbulence, examining their existence in 3D flows and experimental observations.",
    "url": "https://blogs.comphy-lab.org/0_README/#elastoinertial-turbulence",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Drop impact dynamics:",
    "content": "2025-02-22 [[2025-JFM-viscous-drop-impact]]: Comprehensive study of viscosity's role in drop impact forces, from raindrops to inkjet printing applications.",
    "url": "https://blogs.comphy-lab.org/0_README/#drop-impact-dynamics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Capillary waves:",
    "content": "2025-01-11 [[Features-of-capillary-waves-during-asymmetric-bubble-coalescence]]: Analysis of capillary wave dynamics during bubble coalescence, focusing on energy transfer and wave propagation mechanisms.",
    "url": "https://blogs.comphy-lab.org/0_README/#capillary-waves",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - H-B formulation:",
    "content": "2024-12-31 [[Herschel\u2013Bulkley formulation]]: Mathematical formulation of the Herschel-Bulkley model for non-Newtonian flows, with emphasis on yield stress fluids.",
    "url": "https://blogs.comphy-lab.org/0_README/#h-b-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Gauss' Law:",
    "content": "2025-01-21 [[Gauss law of Electrostatics]]: Analysis of electric field flux through different surfaces using Gauss's law, with visual demonstrations.",
    "url": "https://blogs.comphy-lab.org/0_README/#gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Seminar-UIUC",
    "content": "2025-01-19 [[Seminar-UIUC-abstract]]: UIUC fluid seminar abstract exploring polymeric flows as a tunable testbed for unsteady, nonlinear continuum mechanics.",
    "url": "https://blogs.comphy-lab.org/0_README/#seminar-uiuc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Connect With Us",
    "content": "- \ud83c\udf10 Website: [comphy-lab.org](http://www.comphy-lab.org) - \ud83d\udce7 Email: [vatsalsy@comphy-lab.org](mailto:vatsalsy@comphy-lab.org) - \ud83d\udc26 Twitter: [@VatsalSanjay](https://twitter.com/VatsalSanjay) - \ud83d\udcbb GitHub: [github.com/VatsalSy](https://github.com/VatsalSy)",
    "url": "https://blogs.comphy-lab.org/0_README/#connect-with-us",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Contributing: We welcome contributions...",
    "content": "We welcome contributions from researchers, students, and collaborators. Here's how you can contribute: 1. **Issues**: Found a problem or have a suggestion?",
    "url": "https://blogs.comphy-lab.org/0_README/#contributing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Contributing: Choose an option...",
    "content": "Choose an option below: - [\ud83d\udde3\ufe0f Request a new blog topic](https://github.com/comphy-lab/CoMPhy-Lab-Blogs/issues/new?template=blog_topic_request.md&labels=blog-request,enhancement) - [\ud83d\udcda Request documentation](https://github.com/comphy-lab/CoMPhy-Lab-Blogs/issues/new?template=documentation_request.md&labels=documentation) - [\ud83d\udd0d Report content correction](https://github.com/comphy-lab/CoMPhy-Lab-Blogs/issues/new?template=content_correction.md&labels=correction) 2. **Pull Requests**: Want to contribute directly? - Fork the repository - Make your changes (it can simply be correcting grammar or making a new post - simply write in plain text or markdown format and add it to the root folder). - Submit a pull request with a clear description of your changes Visit our [GitHub repository](https://github.com/comphy-lab/CoMPhy-Lab-Blogs) to get started. --- *Note: This documentation is maintained by the CoMPhy Lab team and is regularly updated with our latest research findings and computational methods.* > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/0_README/#contributing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public",
    "content": "![CoMPhy-Lab](_Media/CoMPhy-Lab-no-name.png) Here is a list of things on our to-publish list: - [ ] Stokes waves and related topics \ud83d\udcc5 2025-03-01 \u23f3 2025-02-05 ^E1A6F85F-5E63-405E-9EF7-E8CC8662D3CC - [x] Showcase bubbles, waves: \ud83d\udcc5 2025-01-12 ^0B681993-8C8A-49A5-93B6-83368684058E",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "0_todo blog public - To-Do: Blog Posts on Research Papers and Thesis",
    "content": "Below is a list of all the papers and the thesis requiring a dedicated blog post. Each post should highlight the motivation, key findings, and broader implications of the work, along with engaging visuals or videos (where applicable). ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#to-do-blog-posts-on-research-papers-and-thesis",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - Work in Progress",
    "content": "- [ ] **To jump or not to jump: Adhesion and viscous dissipation dictate the detachment of coalescing wall-attached bubbles** Link: [arXiv:2501.05532](https://arxiv.org/abs/2501.05532) - [ ] **Viscoelastic Worthington jets & droplets produced by bursting bubbles** Link: [arXiv:2408.05089](https://arxiv.org/abs/2408.05089) - [ ] **Unifying theory of scaling in drop impact: Forces & maximum spreading diameter** Link: [arXiv:2408.12714](https://arxiv.org/abs/2408.12714) - [ ] **Electrolyte spraying within H\u2082 bubbles during water electrolysis** Link: [arXiv:2409.00515](https://arxiv.org/abs/2409.00515) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#work-in-progress",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2025",
    "content": "- [ ] **The role of viscosity on drop impact forces on non-wetting surfaces** Link: [arXiv:2311.03012](https://arxiv.org/abs/2311.03012) - [ ] **Focusing of concentric free-surface waves** Link: [arXiv:2406.05416](https://arxiv.org/abs/2406.05416) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2025",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2024",
    "content": "- [ ] **Bursting bubble in an elastoviscoplastic medium** Highlight: Cover of _J. Fluid Mech._ Link: [DOI](https://doi.org/10.1017/jfm.2024.109) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2024",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2023",
    "content": "- [ ] **Drop impact on viscous liquid films** Link: [DOI](https://doi.org/10.1017/jfm.2023.895) - [ ] **When does an impacting drop stop bouncing?** Link: [DOI](https://doi.org/10.1017/jfm.2023.896) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2023",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2022",
    "content": "- [ ] **Ph.D. Thesis: Viscous free-surface flows** Links: [Thesis Info](https://www.vatsalsanjay.com/phd-thesis), [DOI](https://doi.org/10.3990/1.9789036554077), move here from old website - [ ] **Impact forces of water drops falling on superhydrophobic surfaces** Highlights: Editor's Suggestion, Research Highlight in _Nature_ Link: [DOI](https://doi.org/10.1103/PhysRevLett.129.104501) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2022",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2021",
    "content": "- [ ] **Bursting bubble in a viscoplastic medium** Link: [DOI](https://doi.org/10.1017/jfm.2021.489) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2021",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2020",
    "content": "- [ ] **Lifting a sessile oil drop from a superamphiphobic surface with an impacting one** Link: [DOI](https://doi.org/10.1126/sciadv.aba4330) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2020",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2019",
    "content": "- [ ] **Consequences of inclined and dual jet impingement in stagnant liquid and stratified layers** Link: [DOI](https://doi.org/10.1002/aic.16373) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2019",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2018",
    "content": "- [ ] **Formation of fluid structures due to jet-jet and jet-sheet interactions** Link: [DOI](https://doi.org/10.1016/j.ces.2018.06.055) - [ ] **Numerical assessment of hazard in compartmental fire having steady heat release rate from the source** Link: [DOI](https://doi.org/10.1007/s12273-017-0411-y) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2018",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2017",
    "content": "- [ ] **Formation of liquid chain by collision of two laminar jets** Link: [DOI](https://doi.org/10.1063/1.4998288) - [ ] **On air entrainment in a water pool by impingement of a jet** Link: [DOI](https://doi.org/10.1002/aic.15828) --- > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2017",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Private todo blog public - Elasticity and viscoelasticity",
    "content": "- [ ] Jacco paper \u23f3 2025-01-24 \ud83d\udcc5 2025-02-03 ^9A6D89F2-1B19-460B-9DAD-DAB0109C0BC3 - [ ] all about the elastic mapping \u23f3 2025-01-26 \ud83d\udcc5 2025-02-09 ^499BBFE0-EB2C-48CD-B8F4-7DFA004C79A7",
    "url": "https://blogs.comphy-lab.org/Private-ToDo-Blog-public/#elasticity-and-viscoelasticity",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Seminar uiuc abstract - Can polymeric flows be the Drosophila of continuum mechanics?: > [!significance] Details...",
    "content": "> [!significance] Details > Speaker:: [Vatsal Sanjay](https://vatsalsanjay.com) ([CoMPhy Lab](https://comphy-lab.org)) > Seminar:: Fluid seminar, University of Illinois Urbana-Champaign (UIUC) > > When:: Thu. January 30, 2025 at **1600h CST (2300h AMS time)**. > How to attend:: Online, please email Vatsal ([vatsalsanjay@gmail.com](mailto:vatsalsanjay@gmail.com)) Polymeric liquids provide a tunable testbed to explore unsteady, nonlinear continuum mechanics by systematically varying the amount and type of polymers. We explore how such systems can probe a continuum of behaviors from Newtonian flows to elastically dominated regimes, making polymeric flows effectively the \"Drosophila\" of unsteady continuum mechanics. This talk will demonstrate how adding polymers modifies instabilities in three canonical free-surface flows: sheets punctured by holes (Taylor\u2013Culick retraction), bursting bubbles that emit droplets, and Worthington jets formed by impact.",
    "url": "https://blogs.comphy-lab.org/Talks/Seminar-UIUC-abstract/#can-polymeric-flows-be-the-drosophila-of-continuum-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Seminar uiuc abstract - Can polymeric flows be the Drosophila of continuum mechanics?: Elastic stresses either...",
    "content": "Elastic stresses either create new singularities or suppress known ones, leading to distinct regimes in parameter space. Numerical simulations and complementary experiments reveal how polymer relaxation time and modulus determine free-surface morphologies, droplet sizes, and jet velocities, with implications for aerosol generation and fluid processing. By unifying concepts from fluid and solid mechanics, these results provide broad insight into controlling interfacial flows in manufacturing, pathogen transport, and beyond. ![Singularities](_Media/20250119213726033_Seminar-UIUC-abstract.png) [[Seminar-UIUC-abstract.pdf|abstract in .pdf]] > [!info]- Metadata > Posted by:: Vatsal > Date published:: 2025-01-19 > Date modified:: Jan 27, 2025 at 08:03 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Talks/Seminar-UIUC-abstract/#can-polymeric-flows-be-the-drosophila-of-continuum-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Seminar durham abstract - Can polymeric flows be the Drosophila of continuum mechanics?: > [!significance] Speaker...",
    "content": "> [!significance] Speaker > [Vatsal Sanjay](https://vatsalsanjay.com) ([CoMPhy Lab](https://comphy-lab.org)) Polymeric liquids provide a tunable testbed to explore unsteady, nonlinear continuum mechanics by systematically varying the amount and type of polymers. We explore how such systems can probe a continuum of behaviors from Newtonian flows to elastically dominated regimes, making polymeric flows effectively the \"Drosophila\" of unsteady continuum mechanics. This talk will demonstrate how adding polymers modifies instabilities in three canonical free-surface flows: sheets punctured by holes (Taylor\u2013Culick retraction), bursting bubbles that emit droplets, and Worthington jets formed by impact. Elastic stresses either create new singularities or suppress known ones, leading to distinct regimes in parameter space.",
    "url": "https://blogs.comphy-lab.org/Talks/Seminar-Durham-abstract/#can-polymeric-flows-be-the-drosophila-of-continuum-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Seminar durham abstract - Can polymeric flows be the Drosophila of continuum mechanics?: JavaScript",
    "content": "Numerical simulations and complementary experiments reveal how polymer relaxation time and modulus determine free-surface morphologies, droplet sizes, and jet velocities, with implications for aerosol generation and fluid processing. By unifying concepts from fluid and solid mechanics, these results provide broad insight into controlling interfacial flows in manufacturing, pathogen transport, and beyond. ![[_Media/Durham.png|How do polymeric flows influence classical hydrodyna ic singularities?]] > [!info]- Metadata > Posted by:: Vatsal > Date published:: 2025-02-21 > Date modified:: Feb 21, 2025 at 07:23 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab) [[Seminar-Durham-abstract.pdf|this page in .pdf]]",
    "url": "https://blogs.comphy-lab.org/Talks/Seminar-Durham-abstract/#can-polymeric-flows-be-the-drosophila-of-continuum-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Herschel\u2013Bulkley formulation for non-Newtonian flows",
    "content": "> [!tldr] TL;DR > The **Herschel\u2013Bulkley** model unifies Newtonian, Bingham, and power-law fluids via a yield stress and a strain-rate-dependent viscosity. An \ufffc$\\epsilon$-regularization ensures stable computations and recovers simpler models (Newtonian, Bingham) by tuning model parameters. Dimensionless groups (e.g., the plasto-capillary number \ufffc and the effective Ohnesorge) capture the interplay of fluid rheology, capillarity, and flow scales. Implementation details are provided, along with references, open-source code, and demonstrations of bubble-burst simulations in viscoplastic media.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#herschelbulkley-formulation-for-non-newtonian-flows",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Features:",
    "content": "* Yield stress $\\tau_y$ * Power law dependance on the strain rate * Shear thinning for $n 1$. * Bingham model for $n = 1$. * Newtonian fluid for $n = 1$ and $\\tau_y = 0$.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#features",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - $\\varepsilon$-formulation: $$ \\boldsymbol{\\tau} =...",
    "content": "$$ \\boldsymbol{\\tau} = \\tau_{y}\\,\\boldsymbol{\\mathcal{I}} \\;+\\; K\\left(2\\boldsymbol{\\mathcal{D}}\\right)^{n} = 2\\biggl[\\frac{\\tau_{y}}{2\\|\\boldsymbol{\\mathcal{D}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + K\\,\\bigl(2\\|\\boldsymbol{\\mathcal{D}}\\|+\\epsilon\\bigr)^{n-1} \\biggr]\\boldsymbol{\\mathcal{D}}. $$ Normalizing stresses with $\\gamma/R_0$, length with $R_0$, and velocity with $\\sqrt{\\gamma/\\rho_lR_0}$... $$ \\boldsymbol{\\tilde{\\tau}} = 2\\biggl[\\frac{\\mathcal{J}}{2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + Oh_K\\,\\bigl(2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\epsilon\\bigr)^{n-1} \\biggr]\\boldsymbol{\\tilde{\\mathcal{D}}}. $$ Here, the effective Ohnesorge is $$ Oh_K = \\frac{K}{\\sqrt{\\rho_l^n\\gamma^{2-n}R_0^{3n-2}}} $$ The plasto-capillary number $\\mathcal{J}$ is $$\\mathcal{J} = \\frac{\\tau_yR_0}{\\gamma}$$ One can easily see that putting $n = 1$ recovers the Bingham model with $Oh = \\eta_l/\\sqrt{\\rho_l\\gamma R_0}$.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#varepsilon-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - $\\varepsilon$-formulation: Additionally, with $n...",
    "content": "Additionally, with $n = 1$ & $\\mathcal{J}$ = 0, the model will give a `Newtonian` response.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#varepsilon-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Calculate the norm of the deformation tensor $\\boldsymbol{\\mathcal{D}}$:: $$\\mathcal{D}_{11} = \\frac{\\partial...",
    "content": "$$\\mathcal{D}_{11} = \\frac{\\partial u_r}{\\partial r}$$ $$\\mathcal{D}_{22} = \\frac{u_r}{r}$$ $$\\mathcal{D}_{13} = \\frac{1}{2}\\left( \\frac{\\partial u_r}{\\partial z}+ \\frac{\\partial u_z}{\\partial r}\\right)$$$$\\mathcal{D}_{31} = \\frac{1}{2}\\left( \\frac{\\partial u_z}{\\partial r}+ \\frac{\\partial u_r}{\\partial z}\\right)$$ $$\\mathcal{D}_{33} = \\frac{\\partial u_z}{\\partial z}$$ $$\\mathcal{D}_{12} = \\mathcal{D}_{23} = 0.$$ The second invariant is $\\mathcal{D}_2=\\sqrt{\\mathcal{D}_{ij}\\mathcal{D}_{ij}}$ (this is the Frobenius norm) $$\\mathcal{D}_2^2= \\mathcal{D}_{ij}\\mathcal{D}_{ij}= \\mathcal{D}_{11}\\mathcal{D}_{11} + \\mathcal{D}_{22}\\mathcal{D}_{22} + \\mathcal{D}_{13}\\mathcal{D}_{31} + \\mathcal{D}_{31}\\mathcal{D}_{13} + \\mathcal{D}_{33}\\mathcal{D}_{33}$$ **Note:** $\\|\\mathcal{D}\\| = D_2/\\sqrt{2}$.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#calculate-the-norm-of-the-deformation-tensor-boldsymbolmathcald",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Calculate the norm of the deformation tensor $\\boldsymbol{\\mathcal{D}}$:: We use the...",
    "content": "We use the formulation as given in [Balmforth et al. (2013)](https://www.annualreviews.org/doi/pdf/10.1146/annurev-fluid-010313-141424) [1], who use the strain rate tensor $\\boldsymbol{\\dot{\\mathcal{S}}}$ which and its norm $\\sqrt{\\frac{1}{2}\\dot{\\mathcal{S}_{ij}}\\dot{\\mathcal{S}_{ij}}}$. Of course, given $\\dot{\\mathcal{S}}_{ij}=2 D_{ij}$.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#calculate-the-norm-of-the-deformation-tensor-boldsymbolmathcald",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Calculate the equivalent viscosity",
    "content": "Factorizing with $2 \\mathcal{D}_{ij}$ to obtain an equivalent viscosity $$\\eta_{\\text{eff}} = \\frac{\\mathcal{J}}{2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + Oh_K\\,\\bigl(2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\epsilon\\bigr)^{n-1} $$ In this formulation, $\\varepsilon$ is a small number to ensure numerical stability. The term $$\\frac{\\tau_y}{\\varepsilon} + ...$$is equivalent to the $\\mu_{max}$ of the previous (v1.0, see: [GitHub](https://github.com/VatsalSy/Bursting-Bubble-In-a-Viscoplastic-Medium)) formulation [2]. **Note:** The fluid flows always, it is not a solid, but a very viscous fluid. Reproduced from: [P.-Y. Lagr\u00e9e's Sandbox](http://basilisk.fr/sandbox/M1EMN/Exemples/bingham_simple.c). Here, we use a face implementation of the regularisation method, described [here](http://basilisk.fr/sandbox/vatsal/GenaralizedNewtonian/Couette_NonNewtonian.c). ---",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#calculate-the-equivalent-viscosity",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Video showcasing a typical simulation of bubble bursting in a Herschel\u2013Bulkley fluid medium",
    "content": "[Open on YouTube](https://youtu.be/NmvCVsiEZIA)",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#video-showcasing-a-typical-simulation-of-bubble-bursting-in-a-herschelbulkley-fluid-medium",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - More resources",
    "content": "| [GitHub](https://github.com/comphy-lab/BurstingBubble_Herschel-Bulkley) | [Demo](https://youtu.be/NmvCVsiEZIA) | [License](https://github.com/comphy-lab/BurstingBubble_Herschel-Bulkley/blob/main/LICENSE) | [Latest Changes](https://github.com/comphy-lab/BurstingBubble_Herschel-Bulkley/commits/main) | [[Herschel\u2013Bulkley formulation.pdf\\|pdf]] | | :---------------------------------------------------------------------: | :----------------------------------: | :----------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------: | ----------------------------------------- |",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#more-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - References",
    "content": "[1] N. J. Balmforth, I. A. Frigaard, and G. Ovarlez, \u201cYielding to Stress: Recent Developments in Viscoplastic Fluid Mechanics,\u201d _Annu. Rev. Fluid Mech._, vol. 46, pp. 121\u2013146, Jan. 2014, doi: [10.1146/annurev-fluid-010313-141424](https://doi.org/10.1146/annurev-fluid-010313-141424). [2] V. Sanjay, D. Lohse, and M. Jalaal, \u201cBursting bubble in a viscoplastic medium,\u201d _J. Fluid Mech._, vol. 922, p. A2, 2021. > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Dec 31, 2024 > Date modified:: Jan 26, 2025 at 11:50 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#references",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Relationship between rate of change of a physical quantity and its divergence - Relationship between rate of change of a physical quantity and its divergence",
    "content": "For a conserved quantity (like mass, momentum, or energy), the local rate of change within a volume is directly linked to the divergence of its flux. In particular, conservation laws often take the form: $$\\frac{\\partial \\phi}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0$$ where $\\phi$ is the density of the conserved quantity and $\\mathbf{J}$ is its flux. Integrating over a volume and applying the divergence theorem: $$\\int_V \\frac{\\partial \\phi}{\\partial t} \\, dV + \\oint_{\\partial V} \\mathbf{J}\\cdot d\\mathbf{A} = 0$$ shows that the rate of change of $\\phi$ in that volume (the first term) is exactly balanced by the net flux across the boundary (the second term). Thus, $\\nabla \\cdot \\mathbf{J}$ encapsulates the `source` or `sink` behavior within the volume and is intimately connected to how $\\phi$ changes over time.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Relationship between rate of change of a physical quantity and its divergence/#relationship-between-rate-of-change-of-a-physical-quantity-and-its-divergence",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gaussian surface is very similar to the control volume in fluid mechanics",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:03 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Gaussian surface is very similar to the control volume in fluid mechanics/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Gaussian surface is very similar to the control volume in fluid mechanics - Gaussian surface is very similar to the control volume in fluid mechanics",
    "content": "They are closely related in a mathematical sense. In [[Gauss law of Electrostatics|Gauss\u2019s law for electrostatics]], one picks a closed surface\u2014the Gaussian surface\u2014to evaluate the net electric flux and relate it to enclosed charge via the divergence theorem. In fluid mechanics, one defines a control volume (with a control surface) to analyze fluxes of mass, momentum, or energy. Both rely on the same underlying integral theorem (the divergence theorem) to connect fluxes through the surface to sources or sinks within the volume. The physical interpretations differ\u2014charge density for electromagnetism versus mass or momentum for fluid flow\u2014but the conceptual framework is very similar.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Gaussian surface is very similar to the control volume in fluid mechanics/#gaussian-surface-is-very-similar-to-the-control-volume-in-fluid-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History of gauss",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:04 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/History-of-Gauss/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "History of gauss - History of Gauss (and one recent event):: Carl Friedrich Gauss...",
    "content": "Carl Friedrich Gauss (1777\u20131855) was a brilliant mathematician who made breakthroughs in just about every area of math and physics you can think of\u2013he crunched numbers like a prodigy even as a kid, later proved key theorems in algebra and laid the groundwork for number theory, geometry, and analysis. Beyond math, he helped calculate the orbit of the dwarf planet Ceres, co-invented an early telegraph, and teamed up with physicist **Wilhelm Weber** to measure and model the Earth\u2019s magnetic field. His name is attached to many concepts, including \"Gauss\u2019s law\" (topic of this blog) in electromagnetism, which is a cornerstone in understanding electric fields. Gauss\u2019s relentless curiosity earned him the nickname \"the Prince of Mathematicians,\u201d and his work remains at the heart of modern science and engineering.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/History-of-Gauss/#history-of-gauss-and-one-recent-event",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History of gauss - History of Gauss (and one recent event):: Even today\u2014nearly two...",
    "content": "Even today\u2014nearly two centuries after his death\u2014people still visit his grave in G\u00f6ttingen to pay homage (see figure below, \ud83d\ude09). ![|250](_Media/20250120200507219_Gauss%20law%20of%20Electrostatics.png) Fig. Potrait made availale by Johann Christian August Schwartz - Carl Friedrich Gauss 1777-1855. Ausstellung zum 200. Geburtstag. St\u00e4dtisches Museum G\u00f6ttingen. 16. Januar bis 13. M\u00e4rz 1977. G\u00f6ttingen, 1977, Frontispiz., Public Domain, Link ![|250](_Media/20250120200806664_Gauss%20law%20of%20Electrostatics.png) Fig. Even after (almost) 200 years of his death, people still visit the grave of Carl Friedrich Gauss in G\u00f6ettingen to pay homage to the master.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/History-of-Gauss/#history-of-gauss-and-one-recent-event",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Geometric description of electric field",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:03 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Geometric description of electric field/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Geometric description of electric field - Geometric description of electric field",
    "content": "* **Field Lines**: Draw lines so that at each point, their tangent matches the direction of $\\vec{E}$ * **Density**: The number of lines per unit area (normal to the lines) is proportional to $\\|\\vec{E}\\|$. * **Direction**: Arrows on the lines indicate the direction of $\\vec{E}$. * **Interpretation**: This visual map shows both the direction and magnitude of $\\vec{E}$ across space.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Geometric description of electric field/#geometric-description-of-electric-field",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Principle of superposition of electric fields",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:05 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Principle of superposition of electric fields/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Principle of superposition of electric fields - Principle of Superposition of Electric Fields",
    "content": "The electric field from multiple sources is the vector sum of the individual fields at each point. If charges create electric fields $\\vec{E}_1$, $\\vec{E}_2$, $\\dots$, then the total field is given by: $$ \\vec{E}_{\\text{total}} = \\vec{E}_1 + \\vec{E}_2 + \\cdots $$ This linear superposition implies that each charge\u2019s field contribution adds without altering the others\u2019 fields, enabling straightforward calculation of net electric fields from complex charge distributions.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Principle of superposition of electric fields/#principle-of-superposition-of-electric-fields",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Permittivity of free space",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:05 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/permittivity of free space/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Permittivity of free space - Permittivity of free space",
    "content": "In Gauss\u2019s law, $\\varepsilon$ the permittivity of free space. It quantifies how an electric field propagates through a vacuum. In the standard form of Gauss\u2019s law, $\\oint \\mathbf{E}\\cdot d\\mathbf{A} \\;=\\; \\frac{Q_{\\text{enc}}}{\\varepsilon_0},$ appears as the proportionality constant relating the net electric flux through a closed surface to the total charge enclosed. Numerically, $\\varepsilon_0 \\approx 8.854 \\times 10^{-12}\\,\\mathrm{F/m}$. It also factors into the relationship between the speed of light $c$, the vacuum permeability $\\mu_0$, and itself, via $c = \\frac{1}{\\sqrt{\\varepsilon_0\\,\\mu_0}}$.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/permittivity of free space/#permittivity-of-free-space",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "What is electric field flux?",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:06 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/What is electric field flux?/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "What is electric field flux? - What is electric field flux?",
    "content": "![|750](20250121024948930_What%20is%20electric%20field%20flux_.png) $$ \\Phi = A\\vec{E}\\cdot\\hat{n} = AE\\cos\\alpha $$",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/What is electric field flux?/#what-is-electric-field-flux",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Surface Element Parameterization",
    "content": "> [!tldr] TL;DR > Surface parameterization is a powerful mathematical technique for describing fluid interfaces using coordinates $(u,v)$ that map a 2D parameter space onto 3D surfaces. The tangent vectors $\\mathbf{x}_u = \\partial\\mathbf{x}/\\partial u$ and $\\mathbf{x}_v = \\partial\\mathbf{x}/\\partial v$ define the local surface geometry and are tangent to curves of constant $v$ and $u$, respectively. The normal vector to the surface is calculated as $\\mathbf{n} = (\\mathbf{x}_u \\times \\mathbf{x}_v)/|\\mathbf{x}_u \\times \\mathbf{x}_v|$. This framework enables mathematical analysis of surface metrics like curvature and area, which are essential for understanding interfacial phenomena in multiphase flows, bubble dynamics, and capillary effects.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#surface-element-parameterization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Introduction to Surface Parameterization",
    "content": "Interfaces between fluids represent some of the most fascinating and complex phenomena in fluid dynamics. From the gentle ripples on a pond to the intricate dynamics of bubble coalescence, these interfaces require precise mathematical descriptions to understand their behavior. At the heart of this description lies surface parameterization, a technique that allows us to map coordinates from a two-dimensional parameter space onto a three-dimensional surface. ![](Surface-parameterization-1741712767672.png) Figure 1. A parameterized surface element showing coordinate lines and the tangent plane. In fluid dynamics, we frequently encounter \"sharp\" interfaces\u2014surfaces that separate distinct fluid phases, across which physical properties may change discontinuously. This post explores the mathematical framework for describing such interfaces and how we characterize their geometric properties.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#introduction-to-surface-parameterization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Parameterization Basics",
    "content": "A three-dimensional fluid interface can be mathematically represented by a vector function: $$\\mathbf{x}(u,v) = (x(u,v), y(u,v), z(u,v))$$ Here, $u$ and $v$ are parameters that serve as coordinates on the surface, much like latitude and longitude on Earth's surface. Each point on the interface corresponds to a unique pair of values $(u,v)$ within the parameter domain. > [!note] Parametric vs. Explicit Representation > While some simple surfaces can be described explicitly (e.g., $z = f(x,y)$), parametric representation offers greater flexibility for describing complex shapes, especially those with overhangs or multiple-valued functions.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#parameterization-basics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Iso-Parameter Curves",
    "content": "When we hold one parameter constant while varying the other, we trace curves on the surface known as iso-parameter curves: - **Iso-$u$ curves**: Created by keeping $u$ constant and varying $v$ - **Iso-$v$ curves**: Created by keeping $v$ constant and varying $u$ These curves form a coordinate grid on the surface, as illustrated in Figure 2.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#iso-parameter-curves",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Defining Tangent Vectors: When we differentiate...",
    "content": "When we differentiate the position vector $\\mathbf{x}(u,v)$ with respect to the surface coordinates, we obtain two fundamental tangent vectors: $$\\mathbf{x}_u = \\frac{\\partial\\mathbf{x}}{\\partial u} \\quad \\text{and} \\quad \\mathbf{x}_v = \\frac{\\partial\\mathbf{x}}{\\partial v}$$ These vectors have precise geometric interpretations: - $\\mathbf{x}_u$ is tangent to iso-$v$ curves (curves where $v$ is constant) - $\\mathbf{x}_v$ is tangent to iso-$u$ curves (curves where $u$ is constant) This is visualized below: ![Figure 2](Surface-parameterization-1741713152627.png) Figure 2, taken from [G. Tryggvason, R. Scardovelli & S.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#defining-tangent-vectors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Defining Tangent Vectors: Zaleski, Direct numerical...",
    "content": "Zaleski, Direct numerical simulations of gas-liquid multiphase flows, Cambridge University Press (2011)](https://books.google.es/books?hl=en&lr=&id=nY5bjSYq-AEC&oi=fnd&pg=PR9&dq=%5BBook-Zaleski%5D_Direct+Numerical+Simulations+of+Gas+Liquid+Multiphase+Flows.pdf&ots=TpFXIKxNaj&sig=g-xqzt5uACGx-SYIMhvOwAVtz6U&redir_esc=y#v=onepage&q&f=false) > [!important] Key Insight > The tangent vector $\\mathbf{x}_u$ points in the direction of increasing $u$ along curves of constant $v$, not perpendicular to iso-$u$ curves. Similarly, $\\mathbf{x}_v$ points in the direction of increasing $v$ along curves of constant $u$. This can be a source of confusion: $\\mathbf{x}_u$ is tangent to curves where $v$ is constant, not to curves where $u$ is constant. This is because when you move along a curve where $v$ is fixed, you're varying the $u$ parameter.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#defining-tangent-vectors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - The Surface Normal Vector",
    "content": "With two tangent vectors defined at each point, we can determine the normal vector to the surface through their cross product: $$\\mathbf{n} = \\frac{\\mathbf{x}_u \\times \\mathbf{x}_v}{|\\mathbf{x}_u \\times \\mathbf{x}_v|}$$ This unit normal vector is perpendicular to both tangent vectors and thus perpendicular to the surface itself. The normal vector is crucial for calculating quantities like surface curvature and for determining the direction of surface tension forces.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#the-surface-normal-vector",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Differential Area Element",
    "content": "The differential area element $dA$ on the surface is related to the parameters $du$ and $dv$ through: $$dA = |\\mathbf{x}_u \\times \\mathbf{x}_v| \\, du \\, dv$$ The term $|\\mathbf{x}_u \\times \\mathbf{x}_v|$ represents the local scaling factor between the parameter space and the physical surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#differential-area-element",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - First Fundamental Form",
    "content": "The first fundamental form characterizes distances and areas on the surface: $$ds^2 = E \\, du^2 + 2F \\, du \\, dv + G \\, dv^2$$ where: - $E = \\mathbf{x}_u \\cdot \\mathbf{x}_u$ - $F = \\mathbf{x}_u \\cdot \\mathbf{x}_v$ - $G = \\mathbf{x}_v \\cdot \\mathbf{x}_v$ These coefficients completely determine the metric properties of the surface. > [!note] Orthogonal Parameterization > When $F = \\mathbf{x}_u \\cdot \\mathbf{x}_v = 0$, we have an orthogonal parameterization, meaning that the iso-parameter curves intersect at right angles. This often simplifies calculations.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#first-fundamental-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Mean and Gaussian Curvature",
    "content": "The mean curvature $H$ and Gaussian curvature $K$ are invariant properties of the surface that characterize its local shape: $$H = \\frac{1}{2}(\\kappa_1 + \\kappa_2) \\quad \\text{and} \\quad K = \\kappa_1 \\kappa_2$$ where $\\kappa_1$ and $\\kappa_2$ are the principal curvatures. The mean curvature is particularly important in fluid interfaces due to the Young-Laplace equation: $$\\Delta p = 2\\gamma H$$ which relates the pressure difference $\\Delta p$ across an interface to the surface tension $\\gamma$ and mean curvature $H$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#mean-and-gaussian-curvature",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Shape Characterization",
    "content": "The local shape of a surface element can be categorized based on its curvature: - Elliptic points: $K > 0$ (bowl-shaped) - Hyperbolic points: $K < 0$ (saddle-shaped) - Parabolic points: $K = 0$, $H \\neq 0$ (cylindrical) - Flat points: $K = 0$, $H = 0$ (planar) These classifications help us understand the geometric behavior of interfaces in various fluid dynamics scenarios.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#shape-characterization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Numerical Implementation Considerations: Methods",
    "content": "When implementing surface parameterization in computational fluid dynamics, several approaches are commonly used: 1. **Finite Element Method**: Elements are defined on the parameter space and mapped to the physical surface 2. **Level Set Method**: Implicit representation of the interface as a level set of a function 3. **Front Tracking Method**: Explicit tracking of interface points with dynamic remeshing > [!important] Numerical Stability > The choice of parameterization can significantly impact numerical stability. Orthogonal parameterizations often provide better conditioning for numerical solvers.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#numerical-implementation-considerations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Numerical Implementation Considerations: Code snippets utilize...",
    "content": "Code snippets utilize these concepts for calculating surface properties: ```c /** * @brief Calculates surface curvature from parametric representation * @param xu First tangent vector * @param xv Second tangent vector * @param xuu Second derivative with respect to u * @param xuv Mixed second derivative * @param xvv Second derivative with respect to v * @return Mean curvature value */ double mean_curvature(Vector xu, Vector xv, Vector xuu, Vector xuv, Vector xvv) { Vector n = normalize(cross_product(xu, xv)); double E = dot_product(xu, xu); double F = dot_product(xu, xv); double G = dot_product(xv, xv); double L = dot_product(xuu, n); double M = dot_product(xuv, n); double N = dot_product(xvv, n); return (E*N - 2*F*M + G*L)/(2*(E*G - F*F)); } ```",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#numerical-implementation-considerations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Conclusion and Future Directions: Surface parameterization provides...",
    "content": "Surface parameterization provides a powerful mathematical framework for analyzing fluid interfaces. By defining a mapping between a 2D parameter space and a 3D surface, we gain access to precise geometric tools for calculating properties like curvature, area, and normal vectors. In research, these concepts have proven invaluable for understanding phenomena ranging from capillary waves in bubble coalescence to complex rheological behaviors in non-Newtonian fluids. Future work will continue to leverage these mathematical tools to explore increasingly complex interfacial dynamics across various fluid systems. For researchers working in this field, mastering surface parameterization is essential for both theoretical understanding and computational implementation.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#conclusion-and-future-directions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Conclusion and Future Directions: The framework outlined...",
    "content": "The framework outlined in this post serves as a foundation for more advanced topics in multiphase fluid dynamics. > [!question] Food for Thought > Consider how different choices of surface parameterization might impact numerical stability and accuracy in simulating multiphase flows. What advantages might orthogonal parameterizations offer in specific fluid dynamics problems?",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#conclusion-and-future-directions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - More resources",
    "content": "| [GitHub](https://github.com/comphy-lab/fluid-interfaces-notes) | [Demo](https://youtu.be/NmvCVsiEZIA) | [License](https://github.com/comphy-lab/fluid-interfaces-notes/blob/main/LICENSE) | | :---------------------------------------------------------------------: | :----------------------------------: | :----------------------------------------------------------------------------------------: |",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#more-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Further reading",
    "content": "[1] > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Mar 11, 2025 > Date modified:: Mar 11, 2025 at 14:26 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#further-reading",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Gauss law of electrostatics: > [!important]- Pre-requisites...",
    "content": "> [!important]- Pre-requisites > I assume a working knowledge of > * Electric field $\\vec{E}$. > * [[Geometric description of electric field]] > * [[What is electric field flux?]] > * What is the electric field created by a point change $q$? > $E = q/(4\\pi\\varepsilon_0r^2)$ > * [[Principle of superposition of electric fields]] > [!tldr] TL;DR > Gauss\u2019 law states that the net electric flux through any closed surface is proportional to the total charge enclosed inside it. Its integral form, $\\oint \\vec{E} \\cdot d\\vec{A} = q_{\\text{in}}/\\varepsilon_0$, is most practically used with high\u2010symmetry geometries (spherical, cylindrical, planar). Even though it might seem universal, using it directly for complex geometries often requires additional methods. The differential form, $\\vec{\\nabla} \\cdot \\vec{E} = \\rho/\\varepsilon_0$, underpins charge\u2010field relationships in Maxwell\u2019s equations.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#gauss-law-of-electrostatics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Gauss law of electrostatics: Key insights include:...",
    "content": "Key insights include: _flux remains invariant if charges stay within the boundary_, and _external charges yield zero net flux through a given surface_. Applications to spherical shells, infinite planes, and wires highlight its computational utility. However, without symmetry, one typically reverts to direct integration or other approaches. Often, one of the first wonders students encounter in electrostatics is the deceptively simple yet powerful Gauss' law. I still recall my own initial surprise when I realized flux through any closed surface enclosing a single charge remained the same, no matter how oddly shaped that surface was. In this post, I hope to convey that same amazement while walking you through the essential details and derivations.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#gauss-law-of-electrostatics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Question we ask: which of the following three surfaces will see the maximum flux of $\\vec{E}$ pass through itself?",
    "content": "![fig1](20250121002320090_Gauss%20law%20of%20Electrostatics.png) Fig. A cone, a sphere, and a batman symbol (enclose it in the front and the back) encircle a lonely charge of magnitude $q$. Which of the three will experience maximum eleectric field flux passing through them? This is perhaps the most counterintuitive result of the Gauss law. > [!question] Try it yourself > Instead of taking my (well, Gauss') word for it, try finding the flux through the cone and the circle by integrating the dot product of the local electric field and the area (note that for cone, we must account for both the lateral and the base area). Once you find the solution, make a PR at the GitHub repository please show all intermediate steps.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#question-we-ask-which-of-the-following-three-surfaces-will-see-the-maximum-flux-of-vece-pass-through-itself",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - General form of Gauss' law",
    "content": "> [!tldr] Main statement of Gauss' law > The flux of electric field $\\vec{E}$ though a closed surface (known as the Gaussian surface) is equal to the amount of change enclosed by that surface. $\\int_A\\vec{E}\\cdot\\vec{n}dA = q_{\\text{in}}/\\varepsilon_0$, $\\vec{E}$ is the electric field, $n$ is the normal vector to the area element $dA$, $q_{\\text{in}}$ is the change enclosed inside the Gaussian surface and $\\varepsilon_0$ is the [[permittivity of free space]]. > * In the differential form, it is identical to: > $\\vec{\\nabla}\\cdot\\vec{E} = \\rho/\\varepsilon_0$, where $\\rho$ is the local electric changed density. Let us define the flux as: $$ \\Phi = \\int_A\\vec{E}\\cdot d\\vec{A} = \\int_A\\vec{E}\\cdot \\hat{n}dA $$ Then, $$ \\int_A\\vec{E}\\cdot \\hat{n}dA = \\frac{q_{\\text{in}}}{\\varepsilon_0} $$ Of course, $q_\\text{in}$ is $$ q_\\text{in} = \\int_A\\sigma dA = \\int_V\\rho dV, $$ where $\\sigma$ and $\\rho$ are the surface and volumetric change densities, respectively.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#general-form-of-gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Proof:",
    "content": "> [!caution] > I leave it upto you to decide if the following derivations are the proofs or merely consistency checks for the Gauss' law.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#proof",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Special case of spherical Gaussian surface enclosing a single charge:",
    "content": "![|500](20250121013316786_Gauss%20law%20of%20Electrostatics.png) Electric field by a point change: $$ \\vec{E} = \\frac{q}{4\\pi\\varepsilon_0r^2}\\hat{r} $$ Flux through a sphere of radius $r$, $$ \\Phi = E\\hat{r}\\cdot\\hat{r}A = EA = \\frac{q}{4\\pi\\varepsilon_0r^2}4\\pi r^2 = \\frac{q}{\\varepsilon_0} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#special-case-of-spherical-gaussian-surface-enclosing-a-single-charge",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Arbitary Gaussian surface enclosing a single charge:",
    "content": "![|750](20250121013334249_Gauss%20law%20of%20Electrostatics.png) Electric field by a point change: $$ \\vec{E} = \\frac{q}{4\\pi\\varepsilon_0r^2}\\hat{r} $$ Local flux at the indicated location: $$ d\\Phi = E\\hat{r}\\cdot\\hat{n}dA = \\frac{q}{4\\pi\\varepsilon_0r^2}\\cos\\alpha\\,dA = \\frac{q}{4\\pi\\varepsilon_0}\\frac{\\cos\\alpha\\,dA}{r^2} $$ Here, $\\cos\\alpha\\,dA/r^2 = d\\Omega$ is in fact the solid angle subtended by the local area element. $$ \\Phi = \\int d\\Phi = \\int_\\Omega\\frac{q}{4\\pi\\varepsilon_0}d\\Omega $$ The solid angle $\\Omega$ integrates to give $4\\pi$ resulting in $$ \\Phi = \\frac{q}{\\varepsilon_0} $$ ---",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#arbitary-gaussian-surface-enclosing-a-single-charge",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Consequences of Gauss' law: > [!danger] Displace...",
    "content": "> [!danger] Displace the charge all you want, it won\u2019t change the flux > The flux of $\\vec{E}$ only depends on the amount of charge contained inside a Gaussian surface and not on whether or not the charge is moving inside the space enclosed by this Gaussian surface. **Remarkable property:** If charges are moved around **but do not cross** the boundary of $A$, the flux of $E$ through $A$ remains **unchanged**. Despite this unchanging flux, the field $E$ itself can undergo substantial modifications everywhere else.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#consequences-of-gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Consequences of Gauss' law: Conversely, if charges...",
    "content": "Conversely, if charges **do** cross the boundary of $A$, the flux through $A$ will generally change. > [!danger] A charge outside the Gaussian surface imparts net zero flux in that control surface > It is easier to see by construction that electric field lines coming out of a charge outside a Gaussian surface will pass straight through without creating any global flux. ![|750](20250121023006325_Gauss%20law%20of%20Electrostatics.png) > [!danger] On the impossibility of equilibrium in electrostatics In any electrostatic field, a charge cannot be in [stable equilibrium](https://en.wikipedia.org/wiki/Mechanical_equilibrium). A single point charge $q$ cannot remain in stable equilibrium under the electrostatic influence of other, fixed charges in vacuum. Can you think of a scenario? Say, we do. And now, let us enclose this $q$ within a small closed surface $A$. For $q$ to be in stable equilibrium, the net electric field from all other charges must point inward everywhere on $A$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#consequences-of-gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Consequences of Gauss' law: Such an inward...",
    "content": "Such an inward field is critical to create a restoring force for any small displacement of $q$. However, Gauss\u2019s theorem tells us that the total electric flux through $A$ must be zero if no net charge (creating this electrostatic field) is contained inside $A$. This zero flux requirement forces the field to have both inward and outward components on the surface, contradicting the need for a purely inward field. Hence, no purely electrostatic arrangement of external charges can hold a point charge in stable equilibrium in a vacuum. ![|250](20250121015925070_Gauss%20law%20of%20Electrostatics.png)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#consequences-of-gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Symmetries to the rescue",
    "content": "Now, one of the best ways to make Gauss\u2019 law practical is by using symmetry arguments. Below are three major symmetry cases that come in handy.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#symmetries-to-the-rescue",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Plannar symmetry",
    "content": "![|750](20250121033252912_Gauss%20law%20of%20Electrostatics.png) Consider an infinite sheet with uniform surface\u2010charge density $\\sigma$. By symmetry, the electric field must point perpendicular to the sheet and have the same magnitude on either side (left-right symmetry). Select a \"pillbox\" (a short cylinder) that straddles the sheet as your Gaussian surface. The flux then emerges through the two circular faces only; there is no flux through the curved surface because $\\vec{E}$ is parallel there. The integral form of Gauss\u2019s law yields $$ 2\\,E\\,A \\;=\\; \\frac{\\sigma\\,A}{\\varepsilon_0} $$ $$ \\quad\\Longrightarrow\\quad E \\;=\\; \\frac{\\sigma}{2\\,\\varepsilon_0}. $$ Hence, an infinite charged plane produces a constant electric field whose magnitude depends solely on $\\sigma$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#plannar-symmetry",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Special case:",
    "content": "![[plates.png]] When **two** parallel sheets carry equal and opposite surface\u2010charge densities $+\\sigma$ and $-\\sigma$, superposition implies that the fields from each sheet **add** in the region between them and **cancel** outside. Specifically, in the space between the plates, each sheet contributes $\\sigma/(2\\,\\varepsilon_0)$ in the **same** direction, giving a total $$ E_{\\text{between}} \\;=\\; \\frac{\\sigma}{\\varepsilon_0}. $$ Outside the plates, the fields from the two sheets have opposite directions and thus cancel to zero, assuming the plates are large compared to their separation. This configuration approximates the uniform field of a parallel\u2010plate capacitor.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#special-case",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Cyliindrical symmetry",
    "content": "![|750](20250121033734979_Gauss%20law%20of%20Electrostatics.png) Consider an infinitely long wire with a uniform linear charge density $\\lambda$. By symmetry, the electric field $\\vec{E}$ at distance $r$ from the wire must point radially outward and have constant magnitude on a coaxial cylindrical surface of radius $r$. Let us choose this coaxial cylinder as our Gaussian surface (length L). The flux is through the curved surface only; both end caps see $\\vec{E}$ parallel to their planes and hence yield no net contribution. Applying Gauss\u2019s law, $$ E \\,(2\\pi r L) \\;=\\; \\frac{\\lambda\\,L}{\\varepsilon_0} $$ $$\\quad\\Longrightarrow\\quad E \\;=\\; \\frac{\\lambda}{2\\pi \\varepsilon_0\\,r}. $$ The field diminishes as $1/r$ from the wire.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#cyliindrical-symmetry",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Spherical symmetry",
    "content": "Here, let us consider two cases: 1. uniformly charged sphere with charge density $\\rho$ and 2. a thin spherical shell with change $q$. Both have a radius of $a$. Also, assume $\\frac{4\\pi a^3}{3}\\rho = q$. ![|750](20250121035211075_Gauss%20law%20of%20Electrostatics.png)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#spherical-symmetry",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - For $r > a$:",
    "content": "Here, the Gaussian surface contains the entire spherical object inside it. So, in both cases, the Gaussian surface sees a total charge of $q$. Consequently, $$ E = \\frac{q}{4\\pi\\varepsilon_0r^2} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#for-r-a",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - For $r < a$:",
    "content": "* *Shell:* Charge enclosed inside the shell for $r [!note] Note > To play with the above plots, see: [[Gauss-law-of-electrostatics.ipynb]]",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#for-r-a",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - A critique of the Gauss' law in the non-local form",
    "content": "One might wonder: is Gauss' law too good to be true for complicated geometries? Below, I share a brief critique.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#a-critique-of-the-gauss-law-in-the-non-local-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Illusion of Generality",
    "content": "The integral form, $$ \\int_A \\vec{E} \\cdot d\\vec{A} = \\frac{q_\\text{in}}{\\varepsilon_0}, $$ can give a misleading impression that it solves _any_ electrostatic field problem elegantly. While it is indeed general as a statement of charge\u2013field relationships, _practical_ usage relies heavily on symmetry arguments to simplify the surface integral.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#illusion-of-generality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Dependence on Symmetry",
    "content": "Gauss\u2019s integral theorem is most effective when the field and geometry exhibit high symmetry (e.g., spherical, cylindrical, or planar). In such cases, one can choose a closed surface $A$ where the electric field $\\vec{E}$ is either constant in magnitude or zero over different parts of the surface. This makes the flux integral collapse to a simple multiplication, thus giving a direct link between enclosed charge and field magnitude.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#dependence-on-symmetry",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Limitations in Complex Geometries",
    "content": "For configurations lacking these symmetries\u2014such as a uniformly charged disk or other irregular charge distributions\u2014no straightforward closed surface simplifies the flux integral. In these scenarios, one must resort to more laborious methods, like direct integration of Coulomb\u2019s law or employing the local (differential) form combined with suitable boundary conditions. > [!faq] Note: > Of course, let us be very clear that the above critique is only about the non-local form (or integral formulation) of Gauss' law. If we use the more general differential form (or together with the Maxwell's laws of electromagnetism, the above limitations do not apply).",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#limitations-in-complex-geometries",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Some food for throught: Gauss' law is...",
    "content": "Gauss' law is agnostic to the number of dimensions in the problem. In this note, we mainly looked at cases in 3D. Now, think about living in a 2D space. Answer the following: 1. How does the Coulomb's law change in 2D? 2. Adapt Gauss\u2019s law to a 2D problem, where **flux** becomes a line integral around a closed loop. Consider a point charge qqq in a 2D plane. Choose a circle of radius $r$ around the charge as the \"Gaussian\" boundary. Compute the total radial component of $\\vec{E}$ along this circle and show that it is proportional to $q/\\varepsilon_0$ (with an appropriate constant reflecting 2D geometry). 3. For a hypothetical \"4D\" space, the electric field of a point charge might scale differently with distance.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#some-food-for-throught",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Some food for throught: Use dimensional analysis...",
    "content": "Use dimensional analysis to argue how Gauss\u2019s law might look there, and what the \"closed surface\u201d would mean in 4D. **Hint:** Highlight the dimension-agnostic idea that flux = enclosed charge/$\\varepsilon_0$\u200b remains structurally the same, although radius-dependencies of $\\vec{E}$ and definitions of \"surface\" change with dimension. **Note:** To submit answers to the questions above or in case you find a mistake in this note, please feel free to open a pull request at the repository: [link to repository](https://github.com/comphy-lab/CoMPhy-Lab-Blogs).",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#some-food-for-throught",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Integral form:",
    "content": "In this post, we encountered Gauss law in integral form as, $$ \\oint_A \\vec{E} \\cdot d\\vec{A} \\;=\\; \\frac{q_{\\text{in}}}{\\epsilon_0}, $$ where $\\vec{E}$ is the electric field, $q_{\\text{in}}$ is the total charge enclosed by $A$, and $\\epsilon_0$ is the permittivity of free space.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#integral-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Relate enclosed charge to charge density.",
    "content": "The enclosed charge can be expressed in terms of the volume charge density $\\rho$ using a volume integral: $$ q_{\\text{in}} \\;=\\; \\int_{V} \\rho \\, dV. $$ Here, $V$ is the volume bounded by the surface \\(S\\).",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#relate-enclosed-charge-to-charge-density",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Apply the divergence theorem: Rewrite the left...",
    "content": "Rewrite the left side of Gauss\u2019s law using the divergence theorem (also known as Gauss\u2019s divergence theorem): $$ \\oint_A \\vec{E} \\cdot d\\vec{A} \\;=\\; \\int_{V} \\vec{\\nabla} \\cdot \\vec{E} \\; dV. $$ > [!signifigance] Gauss' divergence therorem > This is yet another significant contribution from Gauss. It relates volume integrals to fluxes at the boundaries. This theorem is more generally used throughout the Physics literature. For example, simplifying integrals in Rayleigh$-$B\u00e9nard convection or in Taylor$-$Culick retractions. > $$ \\oint_A\\boldsymbol{F\\cdot}d\\boldsymbol{A} = \\int_{V}\\boldsymbol{\\nabla\\cdot F}\\;dV $$ > **Rate of change of a physical quantity** (see [[Relationship between rate of change of a physical quantity and its divergence]]) in a volume is tied directly to its net flux across the boundary of that volume. More generally, in fluid mechanics, this principle underpins conservation laws such as mass, momentum, or energy.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#apply-the-divergence-theorem",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Apply the divergence theorem: Thus, $$ \\int_{V}...",
    "content": "Thus, $$ \\int_{V} \\vec{\\nabla} \\cdot \\vec{E} \\; dV \\;=\\; \\frac{1}{\\epsilon_0} \\int_{V} \\rho \\; dV. $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#apply-the-divergence-theorem",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Conclude the differential form",
    "content": "Because this equation must hold for any volume $V$, the integrands themselves must be equal at every point in space: $$ \\vec{\\nabla} \\cdot \\vec{E} \\;=\\; \\frac{\\rho}{\\epsilon_0}. $$ This is Gauss\u2019s law in **differential form**. It states that the divergence of the electric field at a point is proportional to the local charge density at that point.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#conclude-the-differential-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Significance to Maxwell's laws of electromagnetism",
    "content": "The Gauss' law of electrostatics is one of the special cases of Maxwell's laws of electromagnetism.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#significance-to-maxwells-laws-of-electromagnetism",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Gauss's Law (Electric):",
    "content": "$$ \\vec{\\nabla} \\cdot \\vec{E} = \\frac{\\rho}{\\varepsilon_0} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#gausss-law-electric",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Faraday's Law of Induction:",
    "content": "$$ \\vec{\\nabla} \\times \\vec{E} = -\\frac{\\partial \\vec{B}}{\\partial t} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#faradays-law-of-induction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Amp\u00e8re\u2013Maxwell Law:",
    "content": "$$ \\vec{\\nabla} \\times \\vec{B} = \\mu_0 \\vec{J} + \\mu_0 \\varepsilon_0 \\frac{\\partial \\vec{E}}{\\partial t} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#amp\u00e8remaxwell-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Gauss's Law (Electric):",
    "content": "$$ \\oint \\vec{E} \\cdot d\\vec{A} = \\frac{q_\\text{in}}{\\varepsilon_0} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#gausss-law-electric",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Faraday's Law of Induction:",
    "content": "$$ \\oint \\vec{E} \\cdot d\\vec{\\ell} = -\\frac{d}{dt}\\left(\\int \\vec{B} \\cdot d\\vec{A}\\right) $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#faradays-law-of-induction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Amp\u00e8re\u2013Maxwell Law:: Conclusion",
    "content": "$$ \\oint \\vec{B} \\cdot d\\vec{\\ell} = \\mu_0 I_\\text{in} + \\mu_0 \\varepsilon_0 \\frac{d}{dt}\\left(\\int \\vec{E} \\cdot d\\vec{A}\\right) $$ > [!summary] Conclusion > That brings us to the end of this reflective overview of Gauss' law and its place within Maxwell's equations. Even though the symmetrical geometries often steal the spotlight, the underlying message is that Gauss' law is deeply fundamental\u2014tied intimately to how charges shape and define the electric field around them. I hope these notes, with their many examples, help you see both its elegance and its limitations. > [!info] Info > Thanks for reading, and feel free to dive deeper (or suggest improvements) via the [GitHub repository](https://github.com/comphy-lab/CoMPhy-Lab-Blogs)! --- > [!testy] Some side notes: > * To explore some history, see: [[History-of-Gauss]] > * Here, we discuss a lot about Gaussian surfaces.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#amp\u00e8remaxwell-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Amp\u00e8re\u2013Maxwell Law:: The fluid dynamicist...",
    "content": "The fluid dynamicist in me cannot help but point out that a [[Gaussian surface is very similar to the control volume in fluid mechanics]]. \ud83d\udca1 --- > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 25, 2025 at 14:22 > [!link] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#amp\u00e8remaxwell-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Computational Multiphase Flows with Basilisk: From Champagne Bubbles to Drop Impact",
    "content": "> [!tldr] TL;DR > This tutorial explores computational approaches to multiphase flow phenomena using Basilisk's axisymmetric framework. We examine five progressively complex simulations: bubble bursting, drop impact on pools, drop impact on solid surfaces, liquid lens equilibrium, and heated drop impact. Each simulation incorporates different physical aspects \u2013 surface tension, inertia, viscosity, thermal effects \u2013 characterized by dimensionless parameters including Ohnesorge, Bond, Weber, and Froude numbers. Through these simulations, we develop practical skills in handling complex interfaces, implementing boundary conditions, and visualizing flow features using adaptive mesh refinement techniques specifically designed for multiphase problems.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#computational-multiphase-flows-with-basilisk-from-champagne-bubbles-to-drop-impact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Introduction: In this tutorial,...",
    "content": "In this tutorial, we explore multiphase flow phenomena through computational simulations using the Basilisk framework. Multiphase flows \u2013 involving interactions between different fluids or phases \u2013 represent some of the most complex and visually striking phenomena in fluid dynamics. From bursting bubbles in champagne to raindrops impacting puddles, these phenomena are ubiquitous in both natural processes and industrial applications.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Introduction: Building on our...",
    "content": "Building on our previous work with heat conduction ([[1st-workingAssignment]]) and single-phase flows ([[2nd-workingAssignment]]), we now tackle the additional complexity introduced by fluid interfaces, surface tension, and multiple interacting phases. > [!info] Learning Objectives > - Implement and analyze axisymmetric multiphase flow simulations > - Understand key dimensionless parameters governing multiphase dynamics > - Develop skills in handling complex interfaces and boundary conditions > - Visualize and interpret dynamic interface evolution > - Apply adaptive mesh refinement strategies for multiphase problems > - Extend simulations to incorporate thermal effects Throughout this tutorial, we'll progress through five core simulation cases: 1. Bubble bursting at a free surface 2. Drop impact on a liquid pool 3. Drop impact on a solid surface 4. Equilibrium of liquid lenses 5.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Introduction: Heated drop impact...",
    "content": "Heated drop impact on a solid surface Each case introduces new physical aspects and numerical challenges, providing a comprehensive overview of computational multiphase fluid dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.1 Drop Impact on a Liquid Pool (3-DropImpactOnPool.c): When a liquid...",
    "content": "When a liquid drop impacts a pool of the same liquid, complex dynamics unfold including crater formation, capillary wave propagation, crown formation, and potential splashing or bubble entrapment. > [!tldr] Problem Statement > Simulate the axisymmetric impact of a liquid drop onto a pool of the same liquid. Key dimensionless parameters include: > > - **Froude number (Fr)**: $\\text{Fr} = \\frac{U^2}{gD}$ Ratio of inertial to gravitational forces > > - **Galilei number (Ga)**: $\\text{Ga} = \\frac{\\rho g D^3}{\\mu^2}$ Ratio of gravitational to viscous forces > > - **Bond number (Bo)**: $\\text{Bo} = \\frac{\\rho g D^2}{\\sigma}$ Ratio of gravitational to surface tension forces > > > Where $U$ is impact velocity, $D$ is drop diameter, $g$ is gravity, $\\mu$ is viscosity, $\\rho$ is density, and $\\sigma$ is surface tension.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#11-drop-impact-on-a-liquid-pool-3-dropimpactonpoolc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.1 Drop Impact on a Liquid Pool (3-DropImpactOnPool.c): C/C++ Code",
    "content": "The implementation includes several advanced techniques: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // NS solver with centered discretization #define FILTERED 1 // Enable filtered VOF for stability #include \"two-phase.h\" // Two-phase flow solver #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension forces #include \"reduced.h\" // Reduced gravity formulation ``` A key feature of this simulation is the use of a tracer field to track the drop liquid even after it merges with the pool: ```c scalar tagDrop[]; // Tracer to identify the drop liquid event init(t = 0) { if (!restore(file = \"dump\")){ // Initialize the fluid configuration: // - Combined shape of drop and pool using union of: // - Drop: circle centered at (Hint,0) with radius 1 // - Pool: half-plane where x [!note] Reduced Gravity Formulation > The simulation uses the \"reduced.h\" module, which implements a more efficient approach to handling pressure in the presence of gravity.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#11-drop-impact-on-a-liquid-pool-3-dropimpactonpoolc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.1 Drop Impact on a Liquid Pool (3-DropImpactOnPool.c): Instead of solving...",
    "content": "Instead of solving for the total pressure, it solves for the reduced pressure: $p' = p - \\rho g z$. This approach provides better numerical stability for low-Froude-number flows.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#11-drop-impact-on-a-liquid-pool-3-dropimpactonpoolc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.2 Drop Impact on Solid Surfaces (3-DropImpactOnSolids.c): Drop impact on...",
    "content": "Drop impact on solid surfaces exhibits different dynamics compared to pool impact, with spreading, possible rebound, and various splashing behaviors depending on the parameters. > [!tldr] Problem Statement > Simulate the axisymmetric impact of a liquid drop on a solid surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#12-drop-impact-on-solid-surfaces-3-dropimpactonsolidsc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.2 Drop Impact on Solid Surfaces (3-DropImpactOnSolids.c): Key dimensionless parameters...",
    "content": "Key dimensionless parameters include: > > - **Weber number (We)**: $\\text{We} = \\frac{\\rho U^2 D}{\\sigma}$ Ratio of inertial to surface tension forces > > - **Ohnesorge number (Oh)**: $\\text{Oh} = \\frac{\\mu}{\\sqrt{\\rho \\sigma D}}$ Ratio of viscous forces to inertial and surface tension forces > > - **Bond number (Bo)**: $\\text{Bo} = \\frac{\\rho g D^2}{\\sigma}$ Ratio of gravitational to surface tension forces > The boundary conditions for the solid wall are implemented as: ```c // Left boundary: solid wall (no-slip and no flux) u.t[left] = dirichlet(0.0); // Tangential velocity = 0 (no-slip) f[left] = dirichlet(0.0); // Volume fraction = 0 (solid wall) // Right boundary: outflow condition u.n[right] = neumann(0.); // Zero gradient for normal velocity p[right] = dirichlet(0.0); // Reference pressure = 0 ``` The drop is initialized with a downward velocity and positioned slightly above the wall: ```c event init(t = 0){ if(!restore(file = \"dump\")){ // Refine mesh near the drop interface refine((R2Drop(x,y) [!important] Dissipation-Based Refinement > This simulation includes an advanced refinement criterion based on the local dissipation rate: > > ```c > foreach(){ > // Calculate velocity gradient components in cylindrical coordinates > double D11 = (u.y[0,1] - u.y[0,-1])/(2*Delta); > double D22 = (u.y[]/max(y,1e-20)); > double D33 = (u.x[1,0] - u.x[-1,0])/(2*Delta); > double D13 = 0.5*((u.y[1,0] - u.y[-1,0] + u.x[0,1] - u.x[0,-1])/(2*Delta)); > > // Calculate dissipation rate (sum of squares of strain rates) > double D2 = (sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13)); > D2c[] = f[]*D2; // Dissipation rate in the drop phase > } > ``` > > This ensures that regions with high energy dissipation (typically near the spreading front and stagnation point) are well-resolved.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#12-drop-impact-on-solid-surfaces-3-dropimpactonsolidsc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.3 Heated Drop Impact (3-HeatedDropImpact.c): This advanced simulation...",
    "content": "This advanced simulation extends the drop impact problem to include thermal effects, modeling the heat transfer that occurs when a cold drop impacts a heated surface. > [!tldr] Problem Statement > Simulate the thermal-fluid dynamics of a cold liquid drop impacting a heated solid surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#13-heated-drop-impact-3-heateddropimpactc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.3 Heated Drop Impact (3-HeatedDropImpact.c): In addition to...",
    "content": "In addition to the mechanical parameters (We, Oh, Bo), the simulation includes thermal parameters: > > - Prandtl number (Pr = \u03bd/\u03b1): Ratio of momentum diffusivity to thermal diffusivity > - Thermal diffusivity ratio (D1/D2): Ratio of thermal diffusivities between the phases The simulation solves both the Navier-Stokes equations and the heat transfer equation: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // NS solver with centered discretization #define FILTERED // Use filtered VOF advection #include \"two-phase-thermal.h\" // Two-phase flow with heat transfer #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension model #include \"reduced.h\" // Reduced gravity approach ``` The thermal boundary conditions specify a constant heat flux from the hot substrate to the cold drop: ```c // Thermal boundary condition: constant heat flux from the hot substrate T[left] = neumann(10.0); // Fixed positive temperature gradient (heating the cold drop) ``` Physical properties include thermal diffusivity for both phases: ```c // Drop phase (1) properties rho1 = 1.0; // Density of drop (reference value) mu1 = Ohd/sqrt(We); // Viscosity derived from Ohnesorge number D1 = 1.0; // Thermal diffusivity of drop (reference value) // Surrounding phase (2) properties rho2 = Rho21; // Density ratio (air/water) mu2 = Ohs/sqrt(We); // Viscosity derived from Ohnesorge number D2 = 1e-3; // Thermal diffusivity ratio (air/water ~ 10^-3) ``` > [!note] Thermal Gradients and Adaptive Refinement The adaptive mesh refinement criteria now include temperature gradients alongside interface position, curvature, and velocity gradients: > > ```c > adapt_wavelet((scalar *){f, KAPPA, u.x, u.y, D2c, T}, > (double[]){fErr, KErr, VelErr, VelErr, DissErr, TErr}, > MAXlevel, MINlevel); > ``` > > This ensures that thermal boundary layers and temperature gradients are properly resolved.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#13-heated-drop-impact-3-heateddropimpactc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 2.2 Physical Background",
    "content": "When a bubble reaches a free surface, a thin film separates it from the surrounding atmosphere. This film eventually ruptures, leading to capillary waves traveling along the interface, followed by the collapse of the cavity and potentially the ejection of droplets. This phenomenon is relevant to numerous natural and industrial processes: - Aerosol production from ocean waves - Champagne bubbles and carbonated beverages - Volcanic eruptions - Industrial foaming processes > [!note] Key Physical Parameters Two dimensionless numbers primarily govern bubble bursting dynamics: > > - **Ohnesorge number (Oh)**: $\\text{Oh} = \\frac{\\mu}{\\sqrt{\\rho \\sigma R}}$ Relates viscous forces to inertial and surface tension forces > > - **Bond number (Bo)**: $\\text{Bo} = \\frac{\\rho g R^2}{\\sigma}$ Relates gravitational forces to surface tension forces > > > Where $\\mu$ is viscosity, $\\rho$ is density, $\\sigma$ is surface tension, $R$ is bubble radius, and $g$ is gravitational acceleration.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#22-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 2.2 Implementing Bubble Bursting (3-BurstingBubbles.c): C/C++ Code",
    "content": "The simulation uses Basilisk's axisymmetric framework to model the bursting process: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // NS solver with centered discretization #define FILTERED // Smear density and viscosity jumps for stability #include \"two-phase.h\" // Two-phase flow solver #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension forces ``` The bubble is initially defined using a pre-calculated equilibrium shape (based on the Bond number) that balances surface tension and gravitational forces: ```c event init (t = 0) { if (!restore (file = dumpFile)){ // Read initial shape from data file char filename[60]; sprintf(filename,\"Bo%5.4f.dat\",Bond); FILE * fp = fopen(filename,\"rb\"); // Generate distance field from shape coordinates coord* InitialShape; InitialShape = input_xy(fp); fclose (fp); scalar d[]; distance (d, InitialShape); // Refine mesh around interface while (adapt_wavelet ((scalar *){f, d}, (double[]){1e-8, 1e-8}, MAXlevel).nf); // Convert distance field to volume fraction vertex scalar phi[]; foreach_vertex(){ phi[] = -(d[] + d[-1] + d[0,-1] + d[-1,-1])/4.; } fractions (phi, f); } } ``` > [!important] Adaptive Mesh Refinement The simulation uses multiple criteria for mesh refinement to accurately resolve the interface dynamics: > > ```c > event adapt(i++){ > // Calculate interface curvature for refinement criterion > scalar KAPPA[]; > curvature(f, KAPPA); > > // Refine mesh based on multiple criteria > adapt_wavelet ((scalar *){f, u.x, u.y, KAPPA}, > (double[]){fErr, VelErr, VelErr, KErr}, > MAXlevel, MAXlevel-6); > } > ``` > > This adaptive approach concentrates computational resources where they're needed most: at the interface, in regions of high curvature, and in areas with significant velocity gradients.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#22-implementing-bubble-bursting-3-burstingbubblesc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 2.2 Implementing Bubble Bursting (3-BurstingBubbles.c): The simulation tracks...",
    "content": "The simulation tracks the kinetic energy to monitor the dynamics and determine when the system has reached a quasi-steady state: ```c event logWriting (i++) { // Calculate total kinetic energy (with axisymmetric integration) double ke = 0.; foreach (reduction(+:ke)){ ke += (2*pi*y)*(0.5*rho(f[])*(sq(u.x[]) + sq(u.y[])))*sq(Delta); } // Output to log and check for convergence/divergence fprintf (ferr, \"%d %g %g %g\\n\", i, dt, t, ke); // Check for energy explosion (instability) if (ke > 1e2 && i > 1e1){ fprintf(ferr, \"The kinetic energy blew up. Stopping simulation\\n\"); return 1; } // Check for near-static conditions (completion) if (ke 1e1){ fprintf(ferr, \"kinetic energy too small now! Stopping!\\n\"); return 1; } } ```",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#22-implementing-bubble-bursting-3-burstingbubblesc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 2.3 Expected Results",
    "content": "For low Ohnesorge numbers (low viscosity), we expect to see: 1. Rapid retraction of the film after rupture 2. Capillary waves traveling along the interface 3. Formation of a central jet (Worthington jet) 4. Possible pinch-off of droplets from the jet For higher Ohnesorge numbers (higher viscosity), viscous damping suppresses these features, resulting in a more gradual collapse of the cavity.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#23-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 3.1 Three-Phase Systems (3-EquilibriumOfLiquidLenses.c): A liquid lens...",
    "content": "A liquid lens forms when a drop of one liquid sits at the interface between another liquid and a gas. The equilibrium shape is determined by the balance of surface tension forces at the three-phase contact line. > [!tldr] Problem Statement S > imulate the equilibrium shape of a liquid lens at the interface between two immiscible fluids. The system consists of three phases: > > 1. Dispersed phase (labeled as phase 1) > 2. Water drop (labeled as phase 2) > 3. Air (labeled as phase 3) > > Surface tension coefficients between the three pairs of phases determine the equilibrium contact angles according to the Neumann triangle condition.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#31-three-phase-systems-3-equilibriumofliquidlensesc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 3.1 Three-Phase Systems (3-EquilibriumOfLiquidLenses.c): C/C++ Code",
    "content": "This simulation uses Basilisk's three-phase flow solver: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // Centered finite-volume Navier-Stokes solver #define FILTERED // Enable property filtering for stability #include \"three-phase.h\" // Three-phase interface tracking #include \"tension.h\" // Surface tension model ``` Surface tension coefficients are defined between each pair of phases: ```c // Set surface tension coefficients between phase pairs f1.sigma = 1.0; // Surface tension: dispersed phase-air (\u03c3\u2081\u2083, reference value) f2.sigma = 52/16; // Surface tension: dispersed phase-water drop (\u03c3\u2081\u2082 \u2248 3.25) // Note: The effective surface tension between water and air (\u03c3\u2082\u2083) will be: // \u03c3\u2082\u2083 = \u03c3\u2081\u2083 + \u03c3\u2081\u2082 = 1.0 + 52/16 = 4.25 // This satisfies the ideal precursor film assumption (Neumann triangle) ``` The initial configuration puts a water drop slightly below the interface between the dispersed phase and air: ```c event init(t = 0){ if(!restore (file = \"dump\")){ // Refine mesh around the water drop for better resolution refine(sq(x+1.025) + sq(y) 0 is air fraction(f1, -x); // Update the boundary conditions boundary ((scalar *){f1, f2}); } } ``` > [!important] Neumann Triangle and Contact Angles The equilibrium contact angles at the three-phase junction are determined by the balance of surface tension forces, known as the Neumann triangle condition: > > $$\\frac{\\sigma_{12}}{\\sin\\theta_3} = \\frac{\\sigma_{23}}{\\sin\\theta_1} = \\frac{\\sigma_{13}}{\\sin\\theta_2}$$ > > Where $\\sigma_{ij}$ is the surface tension between phases $i$ and $j$, and $\\theta_k$ is the angle in phase $k$. > > In this simulation, we've set $\\sigma_{13} = 1.0$ and $\\sigma_{12} = 3.25$, resulting in specific equilibrium contact angles at the three-phase junction.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#31-three-phase-systems-3-equilibriumofliquidlensesc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Part 4: Exercises and Extensions",
    "content": "Now that we've explored the fundamentals of these multiphase flow simulations, let's develop your skills further with some practical exercises.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#part-4-exercises-and-extensions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 4.1 Bubble Bursting Exercise",
    "content": "> [!task] Exercise: Investigating Ohnesorge Number Effects > > Modify the bubble bursting simulation to explore different Ohnesorge numbers: > > 1. Run simulations with Oh = 1e-3, 1e-2, and 1e-1, keeping Bo constant > 2. Track and compare the following: > - Maximum jet height > - Time to first droplet pinch-off (if it occurs) > - Maximum kinetic energy during the process > 3. Create plots showing these metrics as functions of Oh > 4. Explain the physical mechanisms behind the observed trends > > This exercise will help you understand how viscosity affects capillary-inertial dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#41-bubble-bursting-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 4.2 Drop Impact Exercise",
    "content": "> [!task] Exercise: Comparing Pool and Solid Surface Impact > > Conduct a comparative study between drop impact on a pool and on a solid surface: > > 1. Set up equivalent simulations for both scenarios: > - Use the same Weber number and Ohnesorge number > - Match other parameters (domain size, resolution, etc.) > 2. Track and compare the following: > - Maximum spread diameter > - Crater depth (for pool impact) > - Energy dissipation rate > 3. Visualize the differences in flow patterns using streamlines or velocity magnitude contours > 4. Explain why the outcomes differ based on the underlying physics > > Hint: Pay special attention to the boundary conditions and how they affect momentum transfer.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#42-drop-impact-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 4.3 Advanced Exercise: Thermal Effects",
    "content": "> [!task] Exercise: Temperature-Dependent Surface Tension > > Modify the heated drop impact simulation to include temperature-dependent surface tension: > > 1. Implement the linear relationship: $\\sigma(T) = \\sigma_0(1 - \\gamma(T - T_0))$ > - $\\sigma_0$ is the reference surface tension at temperature $T_0$ > - $\\gamma$ is the temperature coefficient (typically positive) > 2. Run simulations with $\\gamma = 0$ (constant surface tension) and $\\gamma = 0.01$ (temperature-dependent) > 3. Analyze how Marangoni effects (surface tension gradients) affect the spreading dynamics > 4. Visualize temperature and velocity fields to identify regions where thermal effects are most significant > > This extension introduces thermocapillary phenomena, which are important in many industrial processes.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#43-advanced-exercise-thermal-effects",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Part 5: Implementation Tips and Best Practices: Based on our...",
    "content": "Based on our exploration of these multiphase simulations, here are some key insights and best practices: > [!tip] Multiphase Simulation Tips > > 1. **Interface resolution**: Always ensure sufficient resolution near interfaces, especially in regions of high curvature. The `adapt_wavelet()` function with appropriate error thresholds is crucial. > > 2. **Numerical stability**: For high-density and viscosity ratios (typical in air-water systems), use: > > - The `FILTERED` option to smooth property jumps > - The `navier-stokes/conserving.h` module for better momentum conservation > - Appropriate timestep limitations (CFL 3. **Boundary conditions**: Pay careful attention to boundary conditions, especially for solid surfaces. Use `dirichlet()` and `neumann()` appropriately. > > 4. **Initial conditions**: Start with a well-resolved and physically reasonable initial condition.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#part-5-implementation-tips-and-best-practices",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Part 5: Implementation Tips and Best Practices: For drop impact,...",
    "content": "For drop impact, position the drop slightly above the surface. > > 5. **Convergence monitoring**: Track relevant physical quantities (kinetic energy, interface position) to determine when the simulation has reached a quasi-steady state. > > 6. **Parameter sensitivity**: Multiphase flows can be sensitive to small parameter changes. Conduct parameter sweeps to understand the system behavior. > > [!important] Dimensionless Parameters > > Understanding the key dimensionless parameters is essential for characterizing multiphase flows: > > - **Weber number (We)**: Inertia vs. surface tension > - **Ohnesorge number (Oh)**: Viscosity vs. inertia and surface tension > - **Bond number (Bo)**: Gravity vs. surface tension > - **Froude number (Fr)**: Inertia vs. gravity > - **Capillary number (Ca)**: Viscosity vs. surface tension > > These parameters form a framework for classifying and predicting multiphase flow behavior across different scales and fluid properties.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#part-5-implementation-tips-and-best-practices",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Conclusion: In this tutorial,...",
    "content": "In this tutorial, we've explored a range of fascinating multiphase flow phenomena through computational simulations using Basilisk. From bubble bursting to heated drop impact, these simulations capture complex interfacial dynamics that would be challenging to study experimentally. Key insights from our exploration include: 1. The importance of surface tension in driving capillary-inertial phenomena 2. The role of viscosity in damping interfacial oscillations and jet formation 3. The complex interplay between solid boundaries and fluid interfaces 4. The additional complexity introduced by thermal effects 5.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Conclusion: Methods",
    "content": "The power of adaptive mesh refinement in efficiently resolving multiscale features These multiphase flow simulations demonstrate the capability of modern computational methods to capture complex physics with remarkable detail, providing insights into phenomena that occur too quickly or at scales too small for easy experimental observation. > [!question] Further Exploration > > Consider these questions for deeper investigation: > > 1. How would adding surfactants affect bubble bursting or drop impact dynamics? > 2. What happens when the drop and pool liquids have different properties (e.g., immiscible liquids)? > 3. How do contact angle effects influence drop impact on solid surfaces? > 4. What role does the ambient gas play in drop impact phenomena? > 5.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Conclusion: How would phase...",
    "content": "How would phase change (evaporation or solidification) alter these dynamics? > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com/) > Date published:: March 12, 2025 > Date modified:: March 12, 2025 at 09:30 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Think before you compute",
    "content": "- Conservation laws and the numerical solution of the Navier\u2013Stokes equations - Transport equations - *Brief intro to Basilisk coding framework*",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#think-before-you-compute",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - First coding steps",
    "content": "- Implementing basic transport equations in Basilisk C. - Using headers in Basilisk, modular code structure, problem setup, and compilation - [1st Working Assignment](1st-workingAssignment)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#first-coding-steps",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Next coding steps",
    "content": "- Solving Navier\u2013Stokes equations in Basilisk C: [2nd Working Assignment](2nd-workingAssignment.md)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#next-coding-steps",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Interface Dynamics",
    "content": "- Interface tracking methods (VoF, level set, phase-field approaches) and numerical strategies - Hands-on tutorial with interface-tracking to a simple two-phase problem: [3rd Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#interface-dynamics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Non-Newtonian flows",
    "content": "- Non-Newtonian flows: viscoelasticity. - Coding exercises for viscoelastic fluids: [4th Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#non-newtonian-flows",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Special topics",
    "content": "- Three-phase flows. - Holey Sheets. - Contact line dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#special-topics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - Advantages of Basilisk Over Vanilla C for Computational Fluid Dynamics",
    "content": "After examining the implementation of heat conduction problems in both vanilla C and Basilisk, several significant advantages of using Basilisk become apparent. This document outlines these benefits to help new users understand why Basilisk is a powerful tool for computational fluid dynamics (CFD) simulations.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#advantages-of-basilisk-over-vanilla-c-for-computational-fluid-dynamics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 1. Simplified Domain and Grid Management",
    "content": "**Vanilla C:** - Requires manual definition of grid points, cell spacings, and domain extents - Needs explicit calculation of physical coordinates for each point - Requires manual array allocation and deallocation **Basilisk:** - Simple declaration of domain parameters (`L0`, `X0`, `N`) - Automatic grid generation and management - No need for explicit memory allocation/deallocation for grid points",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#1-simplified-domain-and-grid-management",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 2. Declarative Boundary Conditions",
    "content": "**Vanilla C:** - Requires explicit functions to apply boundary conditions - Boundary conditions must be repeatedly applied during solution - Error-prone due to manual indexing **Basilisk:** - Declarative boundary conditions using a simple, intuitive syntax: ```c T[left] = dirichlet(0.0); T[right] = dirichlet(1.0); ``` - Applied automatically during computation",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#2-declarative-boundary-conditions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 3. Event-Based Programming Model",
    "content": "**Vanilla C:** - Procedural, sequential code execution - Complex control flow for time-stepping, initialization, and output - Difficult to separate logical components **Basilisk:** - Event-based programming model that separates concerns: - `event init` for initialization - `event integration/marching` for time stepping - `event end` for final output - Events can be scheduled to occur at specific times or intervals - Cleaner, more modular code structure",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#3-event-based-programming-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 4. Automatic Time Step Management",
    "content": "**Vanilla C:** - Manual implementation of time step calculations - Explicit checks to ensure numerical stability (CFL condition) - Manual logic to hit specific output times exactly **Basilisk:** - Automatic time step management with `dtnext(DT)` - Built-in tools for maintaining numerical stability - Events can be scheduled at specific times with `t += tsnap`",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#4-automatic-time-step-management",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 5. Stencil Operations and Spatial Discretization",
    "content": "**Vanilla C:** - Explicit array indexing for neighbor access - Manual implementation of finite difference/volume stencils - Error-prone due to index arithmetic **Basilisk:** - Intuitive stencil notation: `T[1]`, `T[-1]` for neighbors - `foreach()` iterator for grid traversal without manual indexing - Automatic handling of boundary conditions during stencil operations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#5-stencil-operations-and-spatial-discretization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 6. Reduced Boilerplate Code",
    "content": "**Vanilla C:** - Lengthy implementations even for simple problems - Requires explicit implementations of utility functions - Verbose memory management **Basilisk:** - Significantly shorter code for equivalent functionality - Built-in functions for common operations - Less cognitive load due to reduced complexity",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#6-reduced-boilerplate-code",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 7. Scalar Field Declaration and Management",
    "content": "**Vanilla C:** - Manual array allocation for each field - Explicit memory management to prevent leaks - No standard methods for field operations **Basilisk:** - Simple scalar field declaration: `scalar T[]` - Automatic memory management - Built-in methods for field operations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#7-scalar-field-declaration-and-management",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 8. Flux Computation and Conservative Formulation",
    "content": "**Vanilla C:** - Manual flux computation at interfaces - Error-prone implementation of conservation laws - Complex indexing for interface values **Basilisk:** - Simplified flux computation with stencil notation - Natural expression of conservation laws - Automatic handling of flux boundary conditions",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#8-flux-computation-and-conservative-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 9. Extensibility and Library Integration",
    "content": "**Vanilla C:** - Limited reusability of code components - Need to reimplement common algorithms - Difficult to extend to more complex problems **Basilisk:** - Modular design allows easy extension - Rich library of pre-implemented physics modules - Natural pathway to more complex simulations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#9-extensibility-and-library-integration",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - Conclusion",
    "content": "The Basilisk computational environment provides significant advantages over vanilla C for fluid dynamics simulations. By abstracting away the implementation details of grid management, boundary conditions, and numerical methods, Basilisk allows researchers and engineers to focus on the physics of their problems rather than the computational details. This leads to more readable, maintainable, and correct code with significantly less development effort. The comparison of the heat conduction examples shows that equivalent problems can be solved with much less code in Basilisk, while simultaneously providing a more intuitive and robust framework for extending to more complex physical phenomena.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Non-Newtonian flows with Basilisk",
    "content": "> [!tldr] TL;DR > This assignment explores computational approaches to viscoelastic fluid dynamics using Basilisk. We investigate four advanced multiphase flow phenomena involving complex rheology: bursting bubbles in polymer solutions, viscoplastic drop impact, soft material impacts, and Taylor-Culick retraction of viscoelastic filaments. Each simulation incorporates non-Newtonian behavior characterized by dimensionless parameters including Weissenberg, Deborah, Ohnesorge, and elasto-capillary numbers. Through these simulations, we develop practical skills in implementing log-conformation formulations for numerical stability, handling complex interfaces with adaptive mesh refinement, and visualizing rheologically complex flows. This assignment represents the culmination of our computational fluid dynamics progression, building on earlier work with heat conduction, single-phase flows, and simple multiphase systems.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#non-newtonian-flows-with-basilisk",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Introduction: In this final...",
    "content": "In this final assignment, we explore the fascinating world of viscoelastic fluid dynamics using computational simulations. Viscoelastic materials\u2014from polymer solutions to biological fluids, food products, and advanced materials\u2014exhibit both viscous (fluid-like) and elastic (solid-like) properties, leading to complex and often counterintuitive behaviors. Understanding these behaviors is crucial for applications ranging from inkjet printing and food processing to biological systems and advanced manufacturing. Building on our previous work with heat conduction ([[1st-workingAssignment]]), single-phase flows ([[2nd-workingAssignment]]), and simple multiphase flows ([[3rd-workingAssignment]]), we now tackle the additional complexity introduced by non-Newtonian rheology, viscoelasticity, and viscoplasticity.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Introduction: These phenomena represent...",
    "content": "These phenomena represent some of the most challenging aspects of computational fluid dynamics, requiring specialized numerical techniques for stable and accurate simulations. > [!info] Learning Objectives > > - Understand key mathematical models for viscoelastic and viscoplastic fluid behavior > - Implement log-conformation formulations for numerical stability in viscoelastic simulations > - Analyze how elasticity affects interfacial dynamics in multiphase flows > - Apply adaptive mesh refinement strategies to resolve complex interface evolution > - Develop skills in visualizing and interpreting non-Newtonian flow phenomena > - Relate dimensionless parameters to physical behaviors in complex fluids Throughout this assignment, we'll explore four complex multiphase flow simulations: 1. Bursting bubbles in viscoelastic media 2. Viscoplastic drop impact on a solid surface 3. Soft impact dynamics with viscoelastic fluids 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Introduction: Taylor-Culick retraction of...",
    "content": "Taylor-Culick retraction of viscoelastic filaments Each case presents unique physical phenomena and numerical challenges, providing a comprehensive overview of computational approaches to viscoelastic fluid dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 1: Viscoelastic Fluid Fundamentals",
    "content": "Before diving into specific simulations, let's establish the mathematical framework for understanding viscoelastic fluid behavior.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-1-viscoelastic-fluid-fundamentals",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.1 Constitutive Equations for Complex Fluids: Traditional Newtonian fluids...",
    "content": "Traditional Newtonian fluids are characterized by a linear relationship between stress and strain rate, governed by a constant viscosity: $$\\boldsymbol{\\tau} = \\mu \\dot{\\boldsymbol{\\gamma}}$$ where $\\boldsymbol{\\tau}$ is the stress tensor, $\\mu$ is the viscosity, and $\\dot{\\boldsymbol{\\gamma}}$ is the strain rate tensor. For non-Newtonian fluids, this relationship becomes more complex: 1. **Viscoplastic fluids (e.g., Bingham plastics, Herschel-Bulkley fluids)** exhibit a yield stress $\\tau_y$ that must be exceeded before flow occurs: $$\\boldsymbol{\\tau} = \\begin{cases} \\tau_{y}\\frac{\\dot{\\boldsymbol{\\gamma}}}{|\\dot{\\boldsymbol{\\gamma}}|} + K|\\dot{\\boldsymbol{\\gamma}}|^{n-1}\\dot{\\boldsymbol{\\gamma}}, & \\text{if } |\\boldsymbol{\\tau}| > \\tau_y \\ \\dot{\\boldsymbol{\\gamma}} = 0, & \\text{if } |\\boldsymbol{\\tau}| \\leq \\tau_y \\end{cases} $$ 2. **Viscoelastic fluids** exhibit memory effects, with stress depending on the deformation history.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#11-constitutive-equations-for-complex-fluids",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.1 Constitutive Equations for Complex Fluids: A common model...",
    "content": "A common model is the Oldroyd-B model: $$\\boldsymbol{\\tau} + \\lambda \\overset{\\nabla}{\\boldsymbol{\\tau}} = \\mu \\left( \\dot{\\boldsymbol{\\gamma}} + \\lambda_r \\overset{\\nabla}{\\dot{\\boldsymbol{\\gamma}}} \\right)$$ where $\\lambda$ is the relaxation time, $\\lambda_r$ is the retardation time, and $\\overset{\\nabla}{\\boldsymbol{\\tau}}$ denotes the upper-convected derivative of the stress tensor.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#11-constitutive-equations-for-complex-fluids",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.2 Key Dimensionless Parameters: Several dimensionless parameters...",
    "content": "Several dimensionless parameters characterize the behavior of complex fluids: 1. **Weissenberg number (Wi)**: Ratio of elastic to viscous forces $$\\text{Wi} = \\lambda \\dot{\\gamma}$$ where $\\lambda$ is the relaxation time and $\\dot{\\gamma}$ is a characteristic strain rate 2. **Deborah number (De)**: Ratio of material relaxation time to observation time $$\\text{De} = \\frac{\\lambda}{t_{\\text{obs}}}$$ 3. **Elasticity number (El)**: Ratio of elastic to inertial effects $$\\text{El} = \\frac{\\text{Wi}}{\\text{Re}} = \\frac{\\lambda \\mu}{\\rho L^2}$$ 4. **Ohnesorge number (Oh)**: Ratio of viscous forces to inertial and surface tension forces $$\\text{Oh} = \\frac{\\mu}{\\sqrt{\\rho \\sigma L}}$$ 5. **Plasto-capillary number (J)**: Ratio of yield stress to capillary pressure $$\\mathcal{J} = \\frac{\\tau_y R_0}{\\sigma}$$ > [!note] Numerical Challenge Simulating viscoelastic flows presents significant numerical challenges, particularly at high Weissenberg numbers (known as the \"high Weissenberg number problem\").",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#12-key-dimensionless-parameters",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.2 Key Dimensionless Parameters: Methods",
    "content": "Traditional numerical methods often fail due to the loss of positive-definiteness of the conformation tensor. The log-conformation approach we'll use in these simulations addresses this issue by working with the logarithm of the conformation tensor, ensuring numerical stability.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#12-key-dimensionless-parameters",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.3 The Log-Conformation Approach",
    "content": "In our simulations, we employ the log-conformation approach, which transforms the conformation tensor $\\mathbf{A}$ logarithmically: $$\\mathbf{\\Psi} = \\log(\\mathbf{A})$$ The evolution equation is then solved for $\\mathbf{\\Psi}$ rather than directly for $\\mathbf{A}$, which ensures that the reconstructed conformation tensor remains positive-definite. This approach significantly improves numerical stability, especially for high Weissenberg number flows. The total stress in the fluid is the sum of the Newtonian solvent contribution and the polymer stress: $$\\boldsymbol{\\tau} = \\mu_s (\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T) + \\mathbf{G}(\\mathbf{A} - \\mathbf{I})$$ where $\\mu_s$ is the solvent viscosity, $\\mathbf{G}$ is the elastic modulus, and $\\mathbf{I}$ is the identity tensor.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#13-the-log-conformation-approach",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 2: Bursting Bubbles in Viscoelastic Media",
    "content": "Our first simulation explores the dynamics of bubble bursting in viscoelastic fluids, a phenomenon that differs significantly from the Newtonian case due to elastic memory effects.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-2-bursting-bubbles-in-viscoelastic-media",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.1 Physical Description: When a bubble...",
    "content": "When a bubble reaches a free surface, the thin film separating it from the surrounding atmosphere eventually ruptures. This triggers a series of events: 1. Capillary waves travel along the interface 2. The bubble cavity collapses 3. A central jet may form and rise upward (Worthington jet) 4. Depending on conditions, the jet may break into droplets In viscoelastic fluids, elastic stresses dramatically alter these dynamics, often leading to enhanced jet formation and reduced droplet breakup due to elastic resistance to extensional deformation. > [!tldr] Problem Statement Simulate the bursting of a bubble at the interface between a viscoelastic fluid and air, examining how elasticity affects the jet dynamics and potential droplet formation.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#21-physical-description",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.1 Physical Description: Key dimensionless parameters...",
    "content": "Key dimensionless parameters include: > > - **Deborah number (De)**: Ratio of relaxation time to flow time scale > - **Elasto-capillary number (Ec)**: Ratio of elastic forces to surface tension > - **Ohnesorge number (Oh)**: Ratio of viscous forces to inertial and capillary forces > - **Bond number (Bond)**: Ratio of gravitational forces to surface tension",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#21-physical-description",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.2 Implementation Details: C/C++ Code",
    "content": "The simulation uses Basilisk's axisymmetric framework with a log-conformation approach for viscoelasticity: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // Main Navier-Stokes solver // Viscoelastic model implementation #if !_SCALAR #include \"log-conform-viscoelastic.h\" // Tensor implementation #else #include \"log-conform-viscoelastic-scalar-2D.h\" // Scalar implementation #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" // Two-phase flow with viscoelasticity #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension forces ``` The bubble is initialized using a pre-calculated equilibrium shape that balances surface tension and gravitational forces: ```c event init (t = 0) { if (!restore (file = dumpFile)){ // Read initial shape from data file char filename[60]; sprintf(filename,\"Bo%5.4f.dat\",Bond); FILE * fp = fopen(filename,\"rb\"); // Generate distance field from shape coordinates coord* InitialShape; InitialShape = input_xy(fp); fclose (fp); // Compute signed distance function scalar d[]; distance (d, InitialShape); // Refine mesh based on distance function while (adapt_wavelet ((scalar *){f, d}, (double[]){1e-8, 1e-8}, MAXlevel).nf); // Convert distance function to volume fraction vertex scalar phi[]; foreach_vertex(){ phi[] = -(d[] + d[-1] + d[0,-1] + d[-1,-1])/4.; } fractions (phi, f); } } ``` Physical properties are specified based on the dimensionless parameters: ```c // Density ratio (liquid : gas = 1000:1) rho1 = 1., rho2 = 1e-3; // Gas phase Ohnesorge number Oha = 2e-2 * Oh; // Viscosity from Ohnesorge numbers mu1 = Oh, mu2 = Oha; // Polymer relaxation time (liquid has elasticity, gas does not) lambda1 = De; lambda2 = 0.; // Elastic modulus (liquid is viscoelastic, gas is not) G1 = Ec; G2 = 0.; // Surface tension coefficient f.sigma = 1.0; ``` > [!important] Adaptive Mesh Refinement The simulation uses multiple criteria for mesh refinement to accurately resolve the interface dynamics: > > ```c > event adapt(i++){ > // Calculate interface curvature for refinement criterion > scalar KAPPA[]; > curvature(f, KAPPA); > > // Adapt mesh based on multiple criteria > adapt_wavelet ((scalar *){f, u.x, u.y, conform_p.x.x, conform_p.y.y, > conform_p.y.x, conform_qq, KAPPA}, > (double[]){fErr, VelErr, VelErr, AErr, AErr, AErr, AErr, KErr}, > MAXlevel, MAXlevel-6); > } > ``` > > This adaptive approach concentrates computational resources where they're needed most: at the interface, in regions of high curvature, areas with significant velocity gradients, and regions with rapidly varying conformation tensor components.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#22-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.3 Expected Results: Results",
    "content": "For Newtonian fluids (De = 0), bubble bursting typically results in: 1. Rapid retraction of the film 2. Formation of capillary waves 3. Collapse of the cavity 4. Potential formation of a Worthington jet 5. Possible droplet pinch-off from the jet For viscoelastic fluids (De > 0), we expect to observe: 1. Enhanced jet formation due to elastic stresses 2. Delayed or suppressed droplet pinch-off 3. Longer and thinner jets at high Deborah numbers 4. Beads-on-a-string morphology for moderate elasticity > [!task] Exercise: Investigating Deborah Number Effects > > Modify the bubble bursting simulation to explore different Deborah numbers: > > 1. Run simulations with De = 0 (Newtonian), De = 1 (moderate elasticity), and De = 10 (high elasticity), keeping other parameters constant > 2. Track and compare: > - Maximum jet height > - Time to first droplet pinch-off (if it occurs) > - Jet morphology (thickness, length, shape) > 3.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#23-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.3 Expected Results: Explain the physical...",
    "content": "Explain the physical mechanisms behind the observed differences > > This exercise will help you understand how elastic memory affects interfacial dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#23-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 3: Viscoplastic Drop Impact",
    "content": "Our second simulation investigates the dynamics of a viscoplastic (yield-stress fluid) drop impacting a solid surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-3-viscoplastic-drop-impact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.1 Physical Background: When a viscoplastic...",
    "content": "When a viscoplastic drop impacts a surface, its behavior differs significantly from Newtonian drops due to the yield stress, which creates unyielded (solid-like) regions within the fluid. Key features include: 1. Initial deformation driven by inertia 2. Formation of unyielded regions where stress falls below the yield stress 3. Limited spreading compared to Newtonian drops 4. Potential formation of a solid-like cap at the drop apex 5. Asymmetric retractions and frozen interfaces after impact > [!tldr] Problem Statement Simulate the axisymmetric impact of a viscoplastic drop onto a solid surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#31-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.1 Physical Background: Key dimensionless parameters...",
    "content": "Key dimensionless parameters include: > > - **Weber number (We)**: $\\text{We} = \\frac{\\rho U^2 D}{\\sigma}$ Ratio of inertial to surface tension forces > - **Ohnesorge number (Oh)**: $\\text{Oh} = \\frac{\\mu}{\\sqrt{\\rho \\sigma D}}$ Ratio of viscous to inertial and surface tension forces > - **Plasto-capillary number (J)**: $\\mathcal{J} = \\frac{\\tau_yR_0}{\\sigma}$ Ratio of yield stress to capillary pressure",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#31-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.2 Mathematical Formulation",
    "content": "For the viscoplastic fluid, we employ the Herschel-Bulkley model with regularization: $$ \\boldsymbol{\\tau} = 2\\biggl[\\frac{\\mathcal{J}}{2|\\boldsymbol{\\mathcal{D}}|+\\epsilon} + \\mathcal{O}h (2|\\boldsymbol{\\mathcal{D}}|+\\epsilon)^{n-1}\\biggr]\\boldsymbol{\\mathcal{D}} $$ where: - $\\boldsymbol{\\mathcal{D}}$ is the deformation rate tensor - $|\\boldsymbol{\\mathcal{D}}|$ is its second invariant - $\\epsilon$ is a regularization parameter - $n$ is the power law index (n = 1 for Bingham model) - $\\mathcal{J}$ is the dimensionless yield stress - $\\mathcal{O}h$ is the Ohnesorge number The regularization ensures numerical stability by avoiding the mathematical singularity at zero deformation rate.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#32-mathematical-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.3 Implementation Details: C/C++ Code",
    "content": "The simulation leverages a modified two-phase flow solver for viscoplastic fluids: ```c #include \"axi.h\" #include \"navier-stokes/centered.h\" #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVP-HB.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #include \"reduced.h\" ``` Boundary conditions specify a solid wall at the left boundary: ```c // Left boundary: solid wall (no-slip and no flux) u.t[left] = dirichlet(0.0); // Tangential velocity = 0 (no-slip) f[left] = dirichlet(0.0); // Volume fraction = 0 (solid wall) ``` The drop is initialized with a downward velocity and positioned slightly above the wall: ```c event init (t = 0) { if (!restore (file = dumpFile)){ refine((R2Drop(x, y) [!important] Adaptive Refinement Strategy The simulation employs a sophisticated adaptive refinement strategy that changes based on the simulation stage: > > ```c > event adapt(i++){ > if (t // Early impact phase: focus on interface and velocity fields > adapt_wavelet ((scalar *){f, u.x, u.y}, > (double[]){fErr, VelErr, VelErr}, > MAXlevel); > } else { > // Later stages: add refinement based on curvature and deformation > scalar KAPPA[], D2c[]; > curvature(f, KAPPA); > foreach() { > // Calculate deformation tensor components > double D11 = (u.y[0,1] - u.y[0,-1])/(2*Delta); > double D22 = (u.y[]/y); > double D33 = (u.x[1,0] - u.x[-1,0])/(2*Delta); > double D13 = 0.5*((u.y[1,0] - u.y[-1,0] + u.x[0,1] - u.x[0,-1])/(2*Delta)); > double D2 = (sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13)); > D2c[] = f[]*(D2); // Deformation rate in the drop phase > } > adapt_wavelet ((scalar *){f, u.x, u.y, KAPPA, D2c}, > (double[]){fErr, VelErr, VelErr, KAPPAErr, D2Err}, > MAXlevel); > } > } > ``` > > This strategy ensures fine resolution near the interface and in regions of high deformation, which is critical for accurately capturing the yield surfaces where the stress transitions across the yield threshold.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#33-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.4 Expected Results",
    "content": "For viscoplastic drops, the impact dynamics depend strongly on the plasto-capillary number J: 1. **Low J (J 1)**: Minimal deformation, approaching solid-like behavior A key feature to observe is the formation of unyielded regions where the stress falls below the yield stress. These regions behave as solid-like domains embedded within the flowing fluid. > [!task] Exercise: Non-Newtonian Impact Dynamics > > Compare viscoplastic drop impact with Newtonian drop impact: > > 1. Run simulations with J = 0 (Newtonian), J = 0.1 (moderate yield stress), and J = 0.5 (high yield stress) > 2. Compare: > - Maximum spread factor (ratio of maximum diameter to initial diameter) > - Final equilibrium shape > - Locations of unyielded regions (where applicable) > 3. Plot the spread factor vs. time for each case on a single graph > 4. Explain how yield stress affects the impact dynamics > > This exercise will help you understand how yield stress modifies impact behavior compared to Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#34-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 4: Soft Impact Dynamics with Viscoelastic Fluids",
    "content": "Our third simulation explores the dynamics of viscoelastic drop impact, focusing on the effects of elasticity on the impact behavior.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-4-soft-impact-dynamics-with-viscoelastic-fluids",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.1 Physical Background",
    "content": "When a viscoelastic drop impacts a surface, elastic stresses can lead to behaviors not seen in Newtonian impacts: 1. Enhanced rebound due to elastic energy storage and recovery 2. Suppression of satellite droplet formation 3. Extended filament formation during rebound 4. Complex fingering patterns during spreading 5. Beads-on-a-string morphology in retracting filaments > [!tldr] Problem Statement Simulate the impact of a viscoelastic drop on a solid surface, examining how elasticity affects the impact dynamics. Key dimensionless parameters include: > > - **Weber number (We)**: Ratio of inertial to surface tension forces > - **Ohnesorge number (Oh)**: Ratio of viscous to inertial and surface tension forces > - **Weissenberg number (Wi)**: Ratio of elastic to viscous forces > - **Elasticity number (El)**: Ratio of elastic to inertial effects > - **Bond number (Bo)**: Ratio of gravitational to surface tension forces",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#41-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.2 Implementation Details: C/C++ Code",
    "content": "The simulation uses a similar framework to the bubble bursting case, with axisymmetric formulation and log-conformation approach: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // Main Navier-Stokes solver // Viscoelastic model implementation #if !_SCALAR #include \"log-conform-viscoelastic.h\" // Tensor implementation #else #include \"log-conform-viscoelastic-scalar-2D.h\" // Scalar implementation #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" // Two-phase flow with viscoelasticity #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension implementation ``` The drop is initialized as a sphere approaching the axis of symmetry (which represents the impact surface in the axisymmetric formulation): ```c event init (t = 0) { if (!restore (file = dumpFile)){ // Refine mesh around interface refine((R2Drop(x, y) [!note] Scalar vs.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#42-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.2 Implementation Details: Tensor Implementation The...",
    "content": "Tensor Implementation The code provides two options for implementing viscoelasticity: > > 1. **Tensor Implementation**: Full anisotropic stresses, physically accurate but computationally intensive > 2. **Scalar Implementation**: Simplified model, faster but less accurate for complex flows > > The tensor implementation tracks the full conformation tensor, while the scalar implementation uses a simplified approach that captures the main features while being computationally more efficient.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#42-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.3 Expected Results: Viscoelastic drop impact...",
    "content": "Viscoelastic drop impact exhibits several distinctive behaviors compared to Newtonian impact: 1. **Weissenberg = 0 (Newtonian)**: Standard impact dynamics with spreading, potential rebound depending on Oh and We 2. **Low Weissenberg**: Enhanced rebound due to elastic recovery 3. **Moderate Weissenberg**: Formation of extended filaments during rebound 4. **High Weissenberg**: Dramatic enhancement of rebound with possible beads-on-a-string formation in filaments > [!task] Exercise: Elasticity Effects on Impact > > Investigate how elasticity affects drop impact behavior: > > 1. Run simulations with Wi = 0 (Newtonian), Wi = 1 (moderate elasticity), and Wi = 10 (high elasticity) > 2. For each case, track: > - Maximum spread factor > - Rebound height (if applicable) > - Time evolution of kinetic and elastic energy > 3. Visualize the stress distribution during impact for different Wi values > 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#43-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.3 Expected Results: Explain the physical...",
    "content": "Explain the physical mechanisms behind the observed differences > > This exercise will help you understand how elasticity modifies impact dynamics through storage and recovery of elastic energy.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#43-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 5: Taylor-Culick Viscoelastic Retraction",
    "content": "Our final simulation explores the capillary-driven retraction of a viscoelastic fluid filament, known as Taylor-Culick flow.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-5-taylor-culick-viscoelastic-retraction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.1 Physical Background: When a cylindrical...",
    "content": "When a cylindrical fluid filament with a free surface is suddenly released, surface tension causes it to retract. For Newtonian fluids, the retraction velocity reaches a constant value known as the Taylor-Culick velocity: $$v_{TC} = \\sqrt{\\frac{2\\sigma}{\\rho h}}$$ where $\\sigma$ is the surface tension, $\\rho$ is the density, and $h$ is the filament thickness. For viscoelastic fluids, the retraction dynamics are more complex due to elastic effects: 1. Initial acceleration phase similar to Newtonian fluids 2. Development of a bulbous end that grows as it collects fluid 3. Formation of a neck behind the bulbous end 4. Potential development of beads-on-a-string morphology 5. Modified retraction velocity due to elastic stresses > [!tldr] Problem Statement Simulate the retraction of a viscoelastic fluid filament under capillary action, examining how elasticity affects the retraction dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#51-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.1 Physical Background: Key dimensionless parameters...",
    "content": "Key dimensionless parameters include: > > - **Deborah number (De)**: Ratio of relaxation time to capillary time > - **Ohnesorge number (Oh)**: Ratio of viscous to inertial and capillary forces > - **Elasticity number (El)**: Ratio of elastic to inertial effects",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#51-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.2 Implementation Details: C/C++ Code",
    "content": "The simulation uses the axisymmetric framework with log-conformation approach for viscoelasticity: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // Main Navier-Stokes solver // Viscoelastic model implementation #if !_SCALAR #include \"log-conform-viscoelastic.h\" // Tensor implementation #else #include \"log-conform-viscoelastic-scalar-2D.h\" // Scalar implementation #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" // Two-phase flow with viscoelasticity #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension implementation ``` The initial configuration consists of a cylindrical filament with a hemispherical cap: ```c event init(t = 0){ if(!restore (file = dumpFile)){ // Refine grid near the interface refine(x [!important] Length Scales In this simulation, there are two important length scales: > > 1. `h0`: The filament thickness, set to 1.0 (the characteristic length) > 2. `hole0`: The initial distance of the hemispherical cap from the origin, also set to 1.0 > > These dimensions determine the initial geometry of the filament, which affects the subsequent retraction dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#52-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.3 Expected Results: The retraction dynamics...",
    "content": "The retraction dynamics of viscoelastic filaments show distinctive behaviors: 1. **Newtonian (De = 0)**: Formation of a bulbous end with diameter approximately twice the filament thickness, constant retraction velocity 2. **Low Deborah Number**: Similar to Newtonian but with slightly modified bulbous end shape and retraction velocity 3. **Moderate Deborah Number**: Formation of a neck behind the bulbous end, potential development of beads-on-a-string morphology 4. **High Deborah Number**: Dramatic modification of retraction dynamics, with strong elastic resistance to extensional deformation in the neck region > [!task] Exercise: Viscoelastic Filament Retraction > > Investigate how viscoelasticity affects filament retraction: > > 1. Run simulations with De = 0 (Newtonian), De = 1 (moderate elasticity), and De = 10 (high elasticity) > 2. For each case, track: > - Retraction velocity over time > - Bulbous end diameter > - Neck formation and evolution (where applicable) > 3.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#53-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.3 Expected Results: Compare the observed...",
    "content": "Compare the observed retraction velocity with the theoretical Taylor-Culick velocity > 4. Explain how elasticity modifies the retraction dynamics through extensional rheology > > This exercise will help you understand how elasticity affects capillary-driven flows, particularly through resistance to extensional deformation.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#53-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 6: Numerical Considerations for Viscoelastic Simulations",
    "content": "Simulating viscoelastic flows presents unique numerical challenges that require special attention:",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-6-numerical-considerations-for-viscoelastic-simulations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 6.1 The High Weissenberg Number Problem",
    "content": "As mentioned earlier, traditional numerical methods often fail at high Weissenberg numbers due to the loss of positive-definiteness of the conformation tensor. This manifests as: 1. Unbounded growth of stress values 2. Numerical instabilities 3. Simulation divergence The log-conformation approach addresses this by: 1. Working with the logarithm of the conformation tensor 2. Ensuring the reconstructed tensor remains positive-definite 3. Allowing stable simulations at much higher Weissenberg numbers",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#61-the-high-weissenberg-number-problem",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 6.2 Adaptive Mesh Refinement Strategies",
    "content": "Effective adaptive mesh refinement is critical for viscoelastic simulations. Key refinement criteria include: 1. **Interface location**: Captured by volume fraction gradients 2. **Velocity gradients**: Important for capturing flow features 3. **Interface curvature**: Critical for surface tension effects 4. **Conformation tensor gradients**: Essential for capturing elastic stress variations Balancing these criteria is important for efficiency and accuracy.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#62-adaptive-mesh-refinement-strategies",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 6.3 Multiphase Interface Treatment",
    "content": "For multiphase viscoelastic simulations, proper treatment of interfaces is crucial: 1. **Filtered approach**: Smooths property jumps across interfaces for numerical stability 2. **Conservative formulation**: Ensures momentum conservation during rapid interface deformation 3. **Tension model**: Accurately captures surface tension forces",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#63-multiphase-interface-treatment",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 6.4 Stability Tips",
    "content": "Based on experience with these simulations, here are some tips for ensuring stability: 1. Use a sufficiently small CFL number (typically 0.1 or less) 2. Start with a moderate Weissenberg/Deborah number and gradually increase 3. Ensure sufficient mesh resolution near interfaces and regions of high stress gradients 4. Monitor energy conservation and stress growth for early signs of instability 5. Use the tensor implementation for complex flows, switching to scalar only when necessary for performance > [!tip] Debugging Strategy If your viscoelastic simulation becomes unstable: > > 1. Check the kinetic energy for exponential growth > 2. Examine the conformation tensor components for unbounded growth > 3. Reduce the time step (lower CFL number) > 4. Increase mesh resolution near problematic regions > 5. Consider reducing the Weissenberg/Deborah number temporarily > 6. Ensure boundary conditions are properly implemented",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#64-stability-tips",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Conclusion: In this assignment,...",
    "content": "In this assignment, we've explored the fascinating world of computational viscoelastic fluid dynamics through four complex multiphase flow simulations. These simulations demonstrate the rich and often counterintuitive behaviors that emerge when elastic and viscoplastic effects are introduced into fluid flows. Key insights from our exploration include: 1. The critical importance of specialized numerical techniques (like the log-conformation approach) for stable viscoelastic simulations 2. The profound impact of elasticity on interfacial dynamics, from enhanced jet formation in bubble bursting to modified retraction behavior in filaments 3. The formation of unyielded regions in viscoplastic flows, creating complex solid-fluid transitions 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Conclusion: The challenges and...",
    "content": "The challenges and strategies for adaptive mesh refinement in flows with multiple time and length scales These complex fluid simulations represent the culmination of our progression through computational fluid dynamics, building on earlier foundations in heat conduction, single-phase flows, and simple multiphase systems. The techniques and insights gained are applicable to a wide range of real-world phenomena, from polymer processing and food science to biological flows and advanced manufacturing. > [!question] Further Exploration > > Consider these questions for deeper investigation: > > 1. How would viscoelasticity and viscoplasticity interact in a combined model (e.g., an elasto-viscoplastic fluid)? > 2. What role does fluid microstructure play in determining macroscopic rheological behavior? > 3. How could these models be extended to incorporate temperature-dependent properties? > 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Conclusion: What experimental techniques...",
    "content": "What experimental techniques could validate the computational predictions made by these simulations? > 5. How might machine learning approaches be used to develop more accurate constitutive models for complex fluids? > [!significance]- Metadata Author:: [Vatsal Sanjay](https://vatsalsanjay.com/) Date published:: March 12, 2025 Date modified:: March 12, 2025 at 10:15 CET > [!meta] Back to main website [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - Computational Fluid Dynamics with Basilisk: From Poiseuille Flow to Rayleigh-B\u00e9nard Convection",
    "content": "> [!tldr] TL;DR > This assignment explores fundamental fluid dynamics problems using Basilisk, progressing from simple Poiseuille flow to complex Rayleigh-B\u00e9nard convection. We study both Newtonian and non-Newtonian (Bingham) fluids, examine lid-driven cavity flow with flow visualization, and conclude with thermal convection simulation. The hands-on exercises with incrementally complex implementations help develop practical CFD skills while exploring rich physical phenomena, all through Basilisk's efficient simulation framework.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#computational-fluid-dynamics-with-basilisk-from-poiseuille-flow-to-rayleigh-b\u00e9nard-convection",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - Introduction: In this working...",
    "content": "In this working class, we'll explore advanced fluid dynamics simulations using the Basilisk framework. Building on our previous work with heat conduction ([[1st-workingAssignment]]), we'll now tackle more complex fluid flow problems that incorporate viscosity, non-Newtonian behavior, and thermal effects. > [!info] Learning Objectives > > - Implement and analyze Poiseuille flow simulations for Newtonian and non-Newtonian fluids > - Understand the lid-driven cavity benchmark problem and its implementation > - Extend simulations with flow visualization techniques > - Explore thermal convection through the Rayleigh-B\u00e9nard configuration > - Develop skills in modifying Basilisk code for different physical scenarios Throughout this tutorial, we'll follow a logical progression from simple to complex simulations: 1. Poiseuille flow with Newtonian fluids 2. Poiseuille flow with Bingham/non-Newtonian fluids 3. Lid-driven cavity with Newtonian fluids 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - Introduction: Lid-driven cavity with...",
    "content": "Lid-driven cavity with Bingham fluids (exercise) 5. Flow visualization in lid-driven cavity 6. Rayleigh-B\u00e9nard convection (exercise)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 1.1 Newtonian Poiseuille Flow (2-Poiseuille-flow-Newtonian.c): Let's begin with...",
    "content": "Let's begin with a fundamental fluid mechanics problem: Poiseuille flow with a Newtonian fluid. > [!tldr] Problem Statement > Solve for the steady-state velocity profile in a planar Poiseuille flow with a constant pressure gradient $-\\frac{dp}{dx} = 1$ and constant viscosity $\\mu_0$. For a Newtonian fluid, the analytical solution is a parabolic profile: $u(y) = \\frac{1}{2\\mu_0}y(h-y)$, where $h=1.0$ is the channel height.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#11-newtonian-poiseuille-flow-2-poiseuille-flow-newtonianc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 1.1 Newtonian Poiseuille Flow (2-Poiseuille-flow-Newtonian.c): C/C++ Code",
    "content": "The code uses Basilisk's Navier-Stokes solver to find the steady-state solution: ```c #include \"navier-stokes/centered.h\" // Global parameters char file_name[80]; double mu_0 = 1.0; // Constant viscosity (Newtonian) int max_iter = 1e4; // Maximum iterations #define DT_MAX (1e-3) // Maximum timestep // Initialization event event init(t = 0) { // Set constant Newtonian viscosity const scalar mu_const[] = mu_0; mu = mu_const; // Pressure gradient (-dp/dx = 1) const face vector mdpdx[] = {1.0, 0.0}; a = mdpdx; // Initialize velocity field at rest foreach() { u.x[] = 0; u.y[] = 0; un[] = 0; } } ``` > [!note] Key Implementation Details > > - The domain is a unit square with periodic left/right boundaries > - No-slip boundary at the bottom ($u=0$) > - Slip boundary at the top (zero-gradient) > - Constant horizontal pressure gradient of 1.0 > - Viscosity is set to a constant value (Newtonian fluid) > - Convergence is monitored by tracking changes in the velocity field At steady state, the simulation produces a parabolic velocity profile that can be compared with the analytical solution: ```c event end(t = end) { FILE *fp = fopen(\"profile.dat\", \"w\"); // Sample the velocity profile along the x-midpoint foreach_col(0) { // Calculate exact solution: u(y) = (1/2\u03bc) * y * (h-y) double y = y; double u_exact = (1.0/(2.0*mu_0)) * y * (L0-y); double error = fabs((u.x[] - u_exact)/u_exact); fprintf(fp, \"%g %g %g %g\\n\", y, u.x[], u_exact, error); } } ```",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#11-newtonian-poiseuille-flow-2-poiseuille-flow-newtonianc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 1.2 Non-Newtonian Poiseuille Flow (2-Poiseuille-flow-Bingham.c): Next, we'll extend...",
    "content": "Next, we'll extend our simulation to handle generalized Newtonian fluids, including Bingham plastics and power-law fluids. > [!tldr] Problem Statement > Solve for the steady-state velocity profile in a planar Poiseuille flow with a constant pressure gradient for a generalized Newtonian fluid that follows the Herschel-Bulkley model: $\\tau = \\tau_y + K(\\dot{\\gamma})^n$, where: > > - $\\tau_y$ is the yield stress > - $K$ is the consistency index > - $n$ is the power-law exponent > - $\\dot{\\gamma}$ is the strain rate The generalized Newtonian model can represent: - Newtonian fluid: $\\tau_y = 0$, $n = 1$ - Power-law fluid: $\\tau_y = 0$, $n \\neq 1$ - Bingham plastic: $\\tau_y > 0$, $n = 1$ - Herschel-Bulkley: $\\tau_y > 0$, $n \\neq 1$ The most important addition in this code is the calculation of the viscosity at each face based on the strain rate tensor: ```c event properties(i++) { foreach_face() { // Calculate deformation tensor components at face centers double D11 = (u.x[] - u.x[-1,0]); double D22 = ((u.y[0,1] - u.y[0,-1]) + (u.y[-1,1] - u.y[-1,-1])) / 4.0; double D12 = 0.5 * (((u.x[0,1] - u.x[0,-1]) + (u.x[-1,1] - u.x[-1,-1])) / 4.0 + (u.y[] - u.y[-1,0])); // Calculate second invariant double D2 = sqrt(sq(D11) + sq(D22) + 2.0 * sq(D12)) / Delta; // Calculate effective viscosity double mu_temp; if (D2 > 0.0) { double temp = tau_y / (sqrt(2.0) * D2) + mu_0 * exp((n - 1.0) * log(D2 / sqrt(2.0))); mu_temp = min(temp, mu_max); } else { if (tau_y > 0.0 || n [!important] Mathematical Background For generalized Newtonian fluids, the stress tensor is related to the deformation tensor by: > > $$\\boldsymbol{\\tau} = 2 \\mu_{eq} \\boldsymbol{\\mathcal{D}}$$ > > where the equivalent viscosity $\\mu_{eq}$ for a Herschel-Bulkley fluid is: > > $$\\mu_{eq} = \\frac{\\tau_y}{2|\\boldsymbol{\\mathcal{D}}|} + K|\\boldsymbol{\\mathcal{D}}|^{n-1}$$ > > To prevent numerical instability when $|\\boldsymbol{\\mathcal{D}}| \\approx 0$, we use regularization: > > 1.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#12-non-newtonian-poiseuille-flow-2-poiseuille-flow-binghamc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 1.2 Non-Newtonian Poiseuille Flow (2-Poiseuille-flow-Bingham.c): Compute viscosity as...",
    "content": "Compute viscosity as normal where strain rate is non-zero > 2. Cap the viscosity at $\\mu_{max}$ where needed > 3. Handle special cases for different values of $\\tau_y$ and $n$ This code allows us to study how different fluid models affect the velocity profile, from the parabolic profile of Newtonian fluids to the plug flow region characteristic of Bingham plastics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#12-non-newtonian-poiseuille-flow-2-poiseuille-flow-binghamc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 2.1 Newtonian Lid-Driven Cavity (2-LidDrivenCavity-Newtonian.c): The lid-driven cavity...",
    "content": "The lid-driven cavity is a classic benchmark problem in computational fluid dynamics. > [!tldr] Problem Statement > Solve for the steady-state flow in a square cavity with a moving top lid. The fluid is Newtonian with a constant viscosity, and all walls have no-slip boundary conditions except for the top wall, which moves at a constant velocity $u = 1$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#21-newtonian-lid-driven-cavity-2-liddrivencavity-newtonianc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 2.1 Newtonian Lid-Driven Cavity (2-LidDrivenCavity-Newtonian.c): C/C++ Code",
    "content": "The simulation setup is straightforward: ```c #include \"navier-stokes/centered.h\" // Constants #define LEVEL 8 // Grid refinement level #define MAXDT (1e-4) // Maximum timestep #define ERROR (1e-6) // Convergence error threshold // Boundary conditions // Top moving wall (lid) u.t[top] = dirichlet(1); // Other no-slip boundaries u.t[bottom] = dirichlet(0); u.t[left] = dirichlet(0); u.t[right] = dirichlet(0); ``` > [!note] Lid-Driven Cavity Characteristics The lid-driven cavity flow exhibits several key features: > > - Primary vortex in the center of the cavity > - Secondary corner vortices at low Reynolds numbers > - Benchmark for testing numerical schemes > - Reynolds number defined as Re = \u03c1UL/\u03bc = 1/\u03bc (with \u03c1=1, U=1, L=1) > > At low Reynolds numbers (high viscosity), the flow reaches a steady state with well-defined vortex structures. As Re increases, the flow becomes increasingly complex.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#21-newtonian-lid-driven-cavity-2-liddrivencavity-newtonianc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 2.2 Lid-Driven Cavity with Flow Visualization (2-LidDrivenCavity-Newtonian-dieInjection.c): C/C++ Code",
    "content": "To better visualize the flow patterns, we can add a passive tracer (dye) to the simulation: ```c #include \"navier-stokes/centered.h\" #include \"die-injection.h\" // Die injection parameters event init (t = 0) { // Set constant viscosity for Newtonian fluid mu = muv; // Initialize velocity field foreach() { u.x[] = 0; u.y[] = 0; un[] = 0; } } int main() { // Initialize grid and parameters init_grid(1<<LEVEL); L0 = 1.0; origin(-0.5, -0.5); DT = MAXDT; TOLERANCE = 1e-5; CFL = 0.25; // Die injection parameters tInjection = 0.05; // Inject the die after flow is established xInjection = 0.00; // X position (center of cavity) yInjection = 0.40; // Y position (center of cavity) // Run simulation run(); } ``` The `die-injection.h` header defines a scalar field that is transported with the flow: ```c // Define the scalar field for the die scalar T[]; scalar * tracers = {T}; // Initialize the die tracer to zero everywhere event init (t = 0) { foreach() T[] = 0.0; } // Inject the die at the specified time event inject_die (t = tInjection) { foreach() { double dist = sqrt(sq(x - xInjection) + sq(y - yInjection)); if (dist <= dieRadius) T[] = 1.0; } } ``` This tracer provides a clear visualization of the flow structures and their evolution over time, revealing the complex patterns that develop in the lid-driven cavity.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#22-lid-driven-cavity-with-flow-visualization-2-liddrivencavity-newtonian-dieinjectionc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.1 Modifying 2-LidDrivenCavity-Bingham.c for exercise: For the first...",
    "content": "For the first exercise, I recommend modifying the lid-driven cavity simulation for Bingham fluids. Here are some suggestions for redacting parts of the code: > [!task] Exercise: Implement Bingham Plastic Model in Lid-Driven Cavity > > In this exercise, you'll modify the lid-driven cavity code to simulate a Bingham plastic fluid. Complete the missing parts of the code to: > > 1. Calculate the deformation tensor components at face centers > 2. Compute the second invariant of the deformation tensor > 3. Implement the regularized Bingham viscosity model > 4. Apply the viscosity at cell faces > > You should run simulations with different yield stress values to observe how the flow structure changes.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#31-modifying-2-liddrivencavity-binghamc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.1 Modifying 2-LidDrivenCavity-Bingham.c for exercise: Context",
    "content": "Code: [2-LidDrivenCavity-Bingham_QUES.c](https://github.com/comphy-lab/Basilisk-101/blob/main/testCases/2-LidDrivenCavity-Bingham_QUES.c) ```c event properties(i++) { foreach_face() { // TODO: Calculate deformation tensor components double D11 = /* Your code here */; double D22 = /* Your code here */; double D12 = /* Your code here */; // TODO: Calculate second invariant (D2) double D2 = /* Your code here */; double mu_local; if (D2 > 0.) { // TODO: Implement regularized Bingham model double temp = /* Your code here */; mu_local = /* Your code here */; } else { // Handle zero strain rate case mu_local = (tauy > 0.0) ? mumax : MU_0; } // Apply viscosity muv.x[] = fm.x[] * (mu_local); } } ``` 1. Observe and explain the formation of unyielded regions (plug flow) 2. Compare streamline patterns for different yield stress values 3. Investigate convergence behavior as yield stress increases 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#31-modifying-2-liddrivencavity-binghamc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.1 Modifying 2-LidDrivenCavity-Bingham.c for exercise: Plot velocity profiles...",
    "content": "Plot velocity profiles across horizontal or vertical sections > [!hint] Solution Hints: > > - Deformation tensor components must be calculated from velocity gradients > - Second invariant: $D_2 = \\sqrt{D_{ij}D_{ij}}$ > - Bingham model: $\\mu = \\tau_y/(2D_2) + \\mu_0$, with regularization to prevent division by zero > - Remember to use the appropriate spatial averaging for face-centered calculations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#31-modifying-2-liddrivencavity-binghamc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.2 Modifying 2-Rayleigh-Benard.c for Exercise: > [!task] Exercise:...",
    "content": "> [!task] Exercise: Implement Rayleigh-B\u00e9nard Convection > > In this exercise, you'll implement a simulation of Rayleigh-B\u00e9nard convection using the Boussinesq approximation. Complete the missing parts of the code to: > > 1. Set up the domain and boundary conditions > 2. Initialize the temperature field with a small perturbation > 3. Implement the buoyancy force in the acceleration event > 4. Set up temperature diffusion > 5. Calculate and monitor the Nusselt number > > You'll explore how the Rayleigh number affects convection patterns. - [2-Rayleigh-Benard.c](https://github.com/comphy-lab/Basilisk-101/blob/main/testCases/2-Rayleigh-Benard.c) - [convection-Boussinesq_QUES.h](https://github.com/comphy-lab/Basilisk-101/blob/main/src-local/convection-Boussinesq_QUES.h) Additional challenges: 1. Calculating and plotting the Rayleigh number vs. number of convection cells 2. Investigating the effect of aspect ratio on convection patterns 3.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#32-modifying-2-rayleigh-benardc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.2 Modifying 2-Rayleigh-Benard.c for Exercise: Measuring the critical...",
    "content": "Measuring the critical Rayleigh number where convection begins 4. Implementing different thermal boundary conditions > [!hint] Solution Hints: > > - The Boussinesq approximation adds a buoyancy term to the y-momentum equation > - Temperature should be initialized with a linear profile plus a small random perturbation > - The acceleration term should be: $a_y = g\\beta(T-T_0)$ > - Use the diffusion() function from diffusion.h for temperature evolution > - The Nusselt number can be calculated from the vertical heat flux at the boundaries",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#32-modifying-2-rayleigh-benardc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 4.1 Common Basilisk Patterns",
    "content": "Throughout these simulations, you'll notice some common patterns in Basilisk code: > [!note] Common Basilisk Patterns > > 1. **Grid initialization**: > > ```c > init_grid(1 ``` > > 2. **Boundary conditions**: > > ```c > u.t[top] = dirichlet(1); // Tangential velocity > u.n[bottom] = dirichlet(0); // Normal velocity > ``` > > 3. **Events for different stages**: > > ```c > event init(t = 0) { ... } // Initialization > event properties(i++) { ... } // Property updates > event integration/marching(i++) { ... } // Time stepping > event logfile(i += 100) { ... } // Logging > ``` > > 4. **Grid traversal with foreach()**: > > ```c > foreach() { > // Operation on each cell > } > foreach_face() { > // Operation on each face > } > ``` > > 5. **Convergence monitoring**: > > ```c > double du = change(u.x, un); > if (du ``` >",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#41-common-basilisk-patterns",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 4.2 Tips for Successful Simulations",
    "content": "Here are some tips to help you succeed with these simulations: > [!tip] Simulation Tips > > - **Timestep selection**: For explicit schemes, ensure the timestep satisfies the relevant stability criterion (e.g., CFL condition) > > - **Convergence monitoring**: Always check convergence by tracking changes in key variables > > - **Grid resolution**: Start with a coarse grid for quick tests, then refine for accuracy > > - **Boundary conditions**: Double-check that boundary conditions are correctly implemented > > - **Regularization parameters**: For non-Newtonian fluids, choose appropriate regularization parameters to balance accuracy and stability > > - **Initial conditions**: Use appropriate initial conditions to avoid unnecessary transients > > - **Output frequency**: Balance output frequency with computational resources and storage needs >",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#42-tips-for-successful-simulations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - Conclusion",
    "content": "> [!question] Further Exploration > > Once you've completed the basic exercises, consider these extensions: > > 1. How does the convergence behavior change with increasing yield stress in Bingham fluids? > > 2. Can you identify the critical Rayleigh number where convection cells first appear? > > 3. How would you modify the lid-driven cavity to include temperature effects (thermally-driven cavity)? > > 4. What happens if you implement an oscillating lid velocity instead of constant velocity? > > 5. Can you extend the Poiseuille flow simulation to include time-dependent pressure gradients? > > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com/) > Date published:: March 11, 2025 > Date modified:: March 11, 2025 at 08:48 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - GitHub repository",
    "content": "[Click here](https://github.com/comphy-lab/Basilisk-101) > [!tldr] TL;DR: > Heat Conduction Simulation Tutorial This tutorial walks through implementing heat conduction simulations, starting with basic vanilla C implementations and progressing to more powerful Basilisk C versions. We build from 1D steady-state problems to 2D, annular, and axisymmetric geometries, demonstrating how Basilisk's domain-specific language dramatically simplifies code while adding powerful features like adaptive mesh refinement and embedded boundaries. The tutorial includes eight progressive simulation cases, showing how the same physics can be implemented with increasingly sophisticated numerical methods, and concludes with custom post-processing tools for data extraction and visualization. Basilisk ultimately reduces hundreds of lines of vanilla C code to concise, readable implementations that handle complex geometries with minimal effort.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#github-repository",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Introduction: This guide walks...",
    "content": "This guide walks you through implementing heat conduction simulations using both vanilla C and the Basilisk framework. We'll progress from simple steady-state problems to more complex transient simulations in multiple dimensions, highlighting the advantages of Basilisk for computational fluid dynamics (CFD) and heat transfer applications. > [!info] Learning Objectives > > - Implement basic heat conduction solvers in vanilla C > - Transition to equivalent implementations in Basilisk C > - Understand the advantages of Basilisk's domain-specific language > - Develop simulations with increasing complexity (1D \u2192 2D \u2192 axisymmetric) > - Appreciate how Basilisk simplifies numerical methods implementation > - Learn to analyze and visualize simulation results with post-processing tools Throughout this tutorial, we'll follow a logical progression across eight core simulation cases: 1. Steady-state heat conduction in vanilla C (`1-conduction-simple.c`) 2.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Introduction: Transient heat conduction...",
    "content": "Transient heat conduction in vanilla C (`1-conduction-transient.c`) 3. Steady-state heat conduction in Basilisk (`1-conduction-simple-basilisk.c`) 4. Transient heat conduction in Basilisk (fill-in exercise) (`1-conduction-transient-basilisk.c`) 5. Enhanced transient solution with diffusion module (`1-conduction-transient-basilisk-withHeaders.c`) 6. 2D heat conduction (`1-conduction-2D.c`) 7. Heat conduction in an annulus (`1-conduction-2D-annulus.c`) 8. Axisymmetric heat conduction (`1-conduction-Axi.c`) After completing the simulations, we'll also cover how to post-process and visualize the results using custom tools.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 1.1 Steady-State Heat Conduction (1-conduction-simple.c): JavaScript",
    "content": "We'll begin with a fundamental 1D steady-state heat conduction problem in vanilla C. > [!tldr] Problem Statement Solve the steady-state heat equation: $$\\frac{d^2 T}{dx^2} = 0$$ Subject to Dirichlet boundary conditions: > > - $T(0) = 0$ > - $T(1) = 1$ > > The analytical solution is the linear profile $T(x) = x$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#11-steady-state-heat-conduction-1-conduction-simplec",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 1.1 Steady-State Heat Conduction (1-conduction-simple.c): Let's examine the...",
    "content": "Let's examine the key elements of this implementation: ```c // Domain discretization #define N 11 // Number of grid points #define MAX_ITER 10000 // Maximum number of iterations #define TOL 1e-10 // Convergence tolerance // Core iterative solver using Gauss-Seidel method double update_interior_points(double t_current[N], double t_new[N]) { int i; double error = 0.0; double diff; for (i = 1; i error) { error = diff; } } return error; } ``` This implementation uses the Gauss-Seidel iterative method with a central difference approximation for the second derivative: $$T_{i} \\approx \\frac{T_{i-1} + T_{i+1}}{2}$$ > [!note] Key Implementation Details > > - Arrays for storing current and new temperature values > - Explicit boundary condition application > - Manual iteration until convergence > - Manual memory management > - Explicit file I/O for results",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#11-steady-state-heat-conduction-1-conduction-simplec",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 1.2 Transient Heat Conduction (1-conduction-transient.c): Next, we'll look...",
    "content": "Next, we'll look at a 1D transient heat conduction problem in vanilla C. > [!tldr] Problem Statement Solve the transient heat equation: $$\\frac{\\partial T}{\\partial t} = \\frac{\\partial^2 T}{\\partial x^2}$$ With no-flux boundary conditions and an initial condition approximating a Dirac delta function. > > The analytical solution is a Gaussian profile that spreads over time: $$T(x,t) = \\frac{1}{2\\sqrt{\\pi t}}e^{-x^2/4t}$$ Key aspects of this implementation: ```c // Compute heat fluxes at cell interfaces void compute_fluxes(double *temperature, double *flux, double dx) { flux[0] = 0.0; // Left boundary (no flux) flux[N] = 0.0; // Right boundary (no flux) for (int i = 0; i [!note] Key Implementation Details > > - Explicit time-stepping scheme (forward Euler) > - Manual computation of fluxes at cell interfaces > - Explicit handling of boundary conditions > - Stability condition for time step ($dt \\leq dx^2/2$) > - Manual memory management and array allocation > - Explicit file I/O for snapshots and results",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#12-transient-heat-conduction-1-conduction-transientc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Exercise 1: Modify the Vanilla C Code",
    "content": "> [!task] Suggested Tasks > > 1. Modify `1-conduction-simple.c` to solve a 2D steady-state problem > - Add a second spatial dimension to the grid > - Update the Gauss-Seidel iteration for 2D > - Modify the boundary conditions for all four edges > 2. Modify `1-conduction-transient.c` to use a different initial condition > - Replace the Dirac delta with a Gaussian profile: $T(x,0) = e^{-x^2/\\sigma^2}$ > - Compare the numerical and analytical solutions at different times",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#exercise-1-modify-the-vanilla-c-code",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 2.1 Steady-State Heat Conduction in Basilisk (1-conduction-simple-basilisk.c): C/C++ Code",
    "content": "Now let's examine the equivalent steady-state problem implemented in Basilisk C. ```c #include \"grid/cartesian1D.h\" #include \"run.h\" // Declare scalar field for temperature scalar T[]; T[left] = dirichlet(0.0); T[right] = dirichlet(1.0); int main() { // Domain setup L0 = 1.0; // Domain length X0 = 0.0; // Left boundary N = 200; // Number of cells // Set the timestep based on stability criterion DT = (L0/N)*(L0/N)/2; // Create output directory char comm[80]; sprintf (comm, \"mkdir -p intermediate\"); system(comm); // Run simulation run(); } // Time integration using explicit finite volume method event marching (i++) { foreach() { // Proper heat equation time stepping T[] += DT*(T[1] - 2*T[] + T[-1])/(Delta*Delta); } } ``` > [!important] Basilisk Advantages > > - Simplified domain and grid setup > - Declarative boundary conditions > - Event-based programming model > - Intuitive stencil operations with `T[1]` and `T[-1]` > - Automatic handling of grid traversal with `foreach()` > - Significantly reduced code length with the same functionality",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#21-steady-state-heat-conduction-in-basilisk-1-conduction-simple-basiliskc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 2.2 Understanding Basilisk's Event System",
    "content": "Basilisk uses an event-based programming model that separates concerns: - `event init (t = 0)`: Initialization at t=0 - `event marching/integration (i++)`: Time integration at each step - `event end (t = end)`: Final operations at the end of the simulation Events can also be scheduled at specific times or intervals: ```c // Execute every 0.1 time units event writingFiles (t = 0.0; t += 0.1; t [!note] Event Scheduling Syntax The event scheduling syntax in Basilisk follows this pattern: > > ```c > event name (condition) { ... } > ``` > > Where condition can be: > > - `t = 0` - Single execution at t=0 > - `i++` - Every iteration > - `t += tsnap` - At regular time intervals > - `t = end` - At the end of simulation > - Combinations like `t = 0; t += 0.1; t < 1.0` for repeated execution",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#22-understanding-basilisks-event-system",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Exercise 2: Understand Basilisk Code Structure",
    "content": "> [!task] Tasks > > 1. Compare the structure and length of `1-conduction-simple.c` and `1-conduction-simple-basilisk.c` > - How many lines of code are in each? > - Which sections of code are simplified or eliminated in the Basilisk version? > 2. Identify the advantages of the Basilisk implementation > - List at least three specific advantages > - For each advantage, explain how it simplifies code development or maintenance > 3. Modify `1-conduction-simple-basilisk.c` to output the relative error > - Add code to calculate and print the error relative to the analytical solution > - Use the formula: $error = |T_{numerical} - T_{analytical}|/|T_{analytical}|$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#exercise-2-understand-basilisk-code-structure",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 3.1 Fill-in-the-Blanks Exercise (1-conduction-transient-basilisk.c): Let's implement the...",
    "content": "Let's implement the transient heat equation in Basilisk.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#31-fill-in-the-blanks-exercise-1-conduction-transient-basiliskc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 3.1 Fill-in-the-Blanks Exercise (1-conduction-transient-basilisk.c): C/C++ Code",
    "content": "Here's a template with some parts for you to fill in: ```c #include \"grid/cartesian1D.h\" #include \"run.h\" // Declare scalar field for temperature scalar T[]; // Simulation parameters #define EPS 0.1 // Width of initial temperature peak #define tmax 1.0 #define tsnap 0.1 int main() { // Domain setup L0 = 10.0; // Domain length X0 = -L0/2; // Left boundary N = 200; // Number of cells // Set the timestep based on stability criterion (CFL condition) // dt = dx^2/2 for explicit scheme DT = (L0/N)*(L0/N)/2; // Create output directory char comm[80]; sprintf (comm, \"mkdir -p intermediate\"); system(comm); // Run simulation run(); } /** * Initialize temperature field * * Sets up a \"Dirac delta\" approximated by a thin rectangle * centered at x=0 with total integral = 1. */ event init (t = 0) { foreach() T[] = (fabs(x) [!hint] Stability Condition (K value) The stability condition for the 1D heat equation with explicit Euler time-stepping requires: $$dt \\leq \\frac{dx^2}{2}$$ So K = 2 is the appropriate value to ensure numerical stability. > [!hint] Understanding The Heat Equation Discretization The heat equation $\\frac{\\partial T}{\\partial t} = \\frac{\\partial^2 T}{\\partial x^2}$ can be discretized in two steps: > > 1.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#31-fill-in-the-blanks-exercise-1-conduction-transient-basiliskc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 3.1 Fill-in-the-Blanks Exercise (1-conduction-transient-basilisk.c): Compute heat fluxes...",
    "content": "Compute heat fluxes at cell interfaces: $q_{i+1/2} = -\\frac{T_{i+1}-T_i}{\\Delta x}$ > 2. Update temperature based on flux divergence: $\\frac{dT_i}{dt} = -\\frac{q_{i+1/2}-q_{i-1/2}}{\\Delta x}$ > > In Basilisk's staggered grid, `q[]` is at cell faces while `T[]` is at cell centers.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#31-fill-in-the-blanks-exercise-1-conduction-transient-basiliskc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Part 4: Enhanced Transient Solution with Diffusion Module: C/C++ Code",
    "content": "Now let's look at an enhanced implementation using Basilisk's built-in diffusion module. ```c #include \"grid/multigrid1D.h\" /* Multigrid solver is required by diffusion.h */ #include \"run.h\" #include \"diffusion.h\" // Declare scalar field for temperature scalar T[]; // Boundary conditions // The diffusion solver will use homogeneous Neumann conditions by default T[left] = neumann(0.); T[right] = neumann(0.); // Simulation parameters #define EPS 0.1 // Width of initial temperature peak #define tmax 1.0 #define tsnap 0.1 int main() { // Domain setup L0 = 10.0; // Domain length X0 = -L0/2; // Left boundary N = 10000; // Number of cells // We can use a larger timestep with the implicit solver // compared to the explicit version which requires dt = dx^2/2 DT = 0.01; // Create output directory char comm[80]; sprintf (comm, \"mkdir -p intermediate\"); system(comm); // Run simulation run(); } /** * Initialize temperature field */ event init (t = 0) { foreach() T[] = (fabs(x) [!important] Advantages of Using diffusion.h > > - **Implicit time stepping** allows for much larger timesteps > - **Unconditional stability** removes the CFL restriction > - **Higher accuracy** due to careful implementation of boundary conditions > - **Multigrid acceleration** for faster convergence > - **Adaptive mesh refinement** compatible > - **Handles complex geometries** through embedded boundaries",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#part-4-enhanced-transient-solution-with-diffusion-module",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 5.1 2D Heat Conduction (1-conduction-2D.c)",
    "content": "Now, let's extend our simulations to two dimensions. > [!tldr] Problem Statement Solve the 2D transient heat equation: $$\\frac{\\partial T}{\\partial t} = \\nabla^2 T$$ With Dirichlet boundary conditions: > > - $T = 1$ on the top boundary > - $T = 0$ on all other boundaries Key aspects of the 2D implementation: ```c #include \"run.h\" #include \"diffusion.h\" // Declare scalar field for temperature scalar T[]; // Boundary conditions T[top] = dirichlet(1.); T[bottom] = dirichlet(0.); T[left] = dirichlet(0.); T[right] = dirichlet(0.); int main() { // Domain setup L0 = 10.0; // Domain length X0 = -L0/2; // Left boundary Y0 = -L0/2; // Bottom boundary init_grid (1 [!note] 2D Implementation Notes > > - Similar structure to 1D, but now using a 2D grid > - Uses `init_grid(1 - Boundary conditions for all four sides > - Implicit diffusion solver works in any dimension > - Added adaptive mesh refinement with `adapt_wavelet()`",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#51-2d-heat-conduction-1-conduction-2dc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 5.2 Heat Conduction in an Annulus (1-conduction-2D-annulus.c): Let's look at...",
    "content": "Let's look at a more complex geometry: heat conduction in an annular domain. > [!tldr] Annulus Problem Solve the transient heat equation in an annular domain: $$\\frac{\\partial T}{\\partial t} = \\nabla^2 T$$ With Dirichlet boundary conditions: > > - $T = 1$ on inner boundary (r = 1) > - $T = 0$ on outer boundary (r = 4) ```c #include \"run.h\" #include \"embed.h\" #include \"diffusion.h\" scalar T[]; // Define inner and outer radii #define INNER_RADIUS 1.0 #define OUTER_RADIUS 4.0 event init (t = 0) { // Define annular geometry using embedded boundaries solid (cs, fs, difference (sq(OUTER_RADIUS) - sq(x) - sq(y), sq(INNER_RADIUS) - sq(x) - sq(y))); // Set boundary conditions T[embed] = dirichlet (sq(x) + sq(y) 0. ? 1.0 : 0.0; // Diffusion only in fluid cells // Solve the diffusion equation while respecting embedded boundaries mgd = diffusion (T, dt, D); } ``` > [!important] Embedded Boundaries > > - `embed.h` provides tools for defining complex geometries > - `solid()` creates the embedded boundary using a level-set function > - `difference()` creates the annular region by subtracting two circles > - Boundary conditions are applied using `T[embed]` > - `fs.x[]` restricts diffusion to the fluid domain",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#52-heat-conduction-in-an-annulus-1-conduction-2d-annulusc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 5.3 Axisymmetric Heat Conduction (1-conduction-Axi.c)",
    "content": "Finally, let's look at an axisymmetric problem. > [!tldr] Axisymmetric Problem Solve the heat equation in cylindrical coordinates with axisymmetry: $$\\frac{\\partial T}{\\partial t} = \\frac{1}{r}\\frac{\\partial}{\\partial r}(r\\frac{\\partial T}{\\partial r}) + \\frac{\\partial^2 T}{\\partial z^2}$$ With boundary conditions: > > - Gaussian heat flux at r=0 (left boundary) > - $T = 0$ on top and right boundaries ```c #include \"axi.h\" #include \"run.h\" #include \"diffusion.h\" scalar T[]; int main() { // Domain setup L0 = 10.0; // Domain length X0 = -L0/2; // Left boundary init_grid (1 [!note] Axisymmetric Features > > - `axi.h` handles the axisymmetric formulation automatically > - In axisymmetric coordinates, `y` represents the radial direction (r) > - `fm.x[]` includes the metric terms for the axisymmetric Laplacian > - Neumann boundary with Gaussian profile at r=0 (left boundary) > - All the complexity of cylindrical coordinates is handled by Basilisk",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#53-axisymmetric-heat-conduction-1-conduction-axic",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Exercise 4: Advanced Heat Conduction Problems",
    "content": "> [!task] Tasks > > 1. Modify the 2D heat conduction problem > - Change boundary conditions to have a sinusoidal temperature on top: `T[top] = dirichlet(sin(\u03c0*x/L0))` > - Compare the steady-state solution with the new boundary condition > 2. Experiment with the annulus problem > - Try different inner and outer radius values > - Implement a time-dependent boundary condition on the inner boundary > 3. Extend the axisymmetric problem > - Add a heat source term using `source(T, dt)` > - Visualize the results with different flux profiles",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#exercise-4-advanced-heat-conduction-problems",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Part 6: Post-Processing and Visualization",
    "content": "After running simulations, we need tools to extract and visualize the results. We'll use two key tools: 1. `getData-generic-heatEq.c` - A Basilisk program to extract data from simulation snapshots 2. `Video-generic-heatEq.py` - A Python script to create visualizations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#part-6-post-processing-and-visualization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 6.1 Extracting Data with getData-generic-heatEq.c: C/C++ Code",
    "content": "This Basilisk utility reads simulation snapshots and extracts field data for visualization: ```c // getData-generic-heatEq.c #include \"utils.h\" #include \"output.h\" scalar T[]; scalar cs[] = {1}; char filename[80]; int nx, ny, len; double xmin, ymin, xmax, ymax, Deltax, Deltay; scalar * list = NULL; int main(int a, char const *arguments[]) { // Parse command line arguments sprintf (filename, \"%s\", arguments[1]); // Snapshot file xmin = atof(arguments[2]); ymin = atof(arguments[3]); // Domain min xmax = atof(arguments[4]); ymax = atof(arguments[5]); // Domain max ny = atoi(arguments[6]); // Number of points in y // Add fields to extract list = list_add (list, T); list = list_add (list, cs); // Restore the snapshot restore (file = filename); // Calculate grid parameters FILE * fp = ferr; Deltay = (double)((ymax-ymin)/(ny)); nx = (int)((xmax - xmin)/Deltay); Deltax = (double)((xmax-xmin)/(nx)); len = list_len(list); // Allocate memory for field data double ** field = (double **) matrix_new (nx, ny+1, len*sizeof(double)); // Extract data through interpolation for (int i = 0; i [!note] How getData-generic-heatEq.c Works > > 1.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#61-extracting-data-with-getdata-generic-heateqc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 6.1 Extracting Data with getData-generic-heatEq.c: Reads a simulation...",
    "content": "Reads a simulation snapshot file > 2. Takes domain extents and resolution as input > 3. Restores the simulation state > 4. Interpolates field values onto a regular grid > 5. Outputs coordinates and field values to stderr > > This approach allows flexible post-processing of any Basilisk simulation.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#61-extracting-data-with-getdata-generic-heateqc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 6.2 Visualization with Video-generic-heatEq.py",
    "content": "The Python script processes the extracted data and creates visualizations: ```python",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#62-visualization-with-video-generic-heateqpy",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Example of key components from Video-generic-heatEq.py: Python Function",
    "content": "def gettingfield(filename, zmin, zmax, rmin, rmax, nr): # Run the getData utility and capture its output exe = [\"./getData-generic-heatEq\", filename, str(zmin), str(rmin), str(zmax), str(rmax), str(nr)] p = sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode(\"utf-8\") temp2 = temp1.split(\"\\n\") # Parse the output into arrays Rtemp, Ztemp, Ttemp, cstemp = [], [], [], [] for n1 in range(len(temp2)): temp3 = temp2[n1].split(\" \") if temp3 == ['']: pass else: Ztemp.append(float(temp3[0])) Rtemp.append(float(temp3[1])) Ttemp.append(float(temp3[2])) cstemp.append(float(temp3[3])) # Convert to numpy arrays and reshape R = np.asarray(Rtemp) Z = np.asarray(Ztemp) T = np.asarray(Ttemp) cs = np.asarray(cstemp) nz = int(len(Z)/nr) R.resize((nz, nr)) Z.resize((nz, nr)) T.resize((nz, nr)) cs.resize((nz, nr)) return R, Z, T, cs, nz def process_timestep(ti, caseToProcess, folder, tsnap, GridsPerR, rmin, rmax, zmin, zmax, lw): # Calculate time and filenames t = tsnap * ti place = f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\" name = f\"{folder}/{int(t*1000):08d}.png\" # Extract data nr = int(GridsPerR * rmax) R, Z, T, cs, nz = gettingfield(place, zmin, zmax, rmin, rmax, nr) # Create visualization fig, ax = plt.subplots() fig.set_size_inches(19.20, 10.80) # Mask regions outside the fluid domain T = np.ma.masked_where(cs != 1.0, T) # Plot temperature field cntrl1 = ax.imshow(T, cmap=\"coolwarm\", interpolation='Bilinear', origin='lower', extent=[-rminp, -rmaxp, zminp, zmaxp], vmax=1.0, vmin=0.0) # Add colorbar and save cb1 = fig.add_axes([l-0.04, b, 0.03, h]) c1 = plt.colorbar(cntrl1, cax=cb1, orientation='vertical') c1.set_label(r'$T$', fontsize=TickLabel, labelpad=5) plt.savefig(name, bbox_inches=\"tight\") plt.close() ``` > [!important] Visualization Process > > 1.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#example-of-key-components-from-video-generic-heateqpy",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Example of key components from Video-generic-heatEq.py: For each timestep:...",
    "content": "For each timestep: > - Call `getData-generic-heatEq` to extract data > - Parse the output into NumPy arrays > - Create a plot using matplotlib > - Add appropriate colorbars and labels > - Save as an image file > 2. Parallelization: > - Uses Python's multiprocessing to handle multiple timesteps simultaneously > - Significantly speeds up the visualization process for large simulations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#example-of-key-components-from-video-generic-heateqpy",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 6.3 Running the Post-Processing Pipeline",
    "content": "To visualize your simulation results, follow these steps: 1. Compile the data extraction utility: ```bash basilisk1d getData-generic-heatEq.c -o getData-generic-heatEq ``` 2. Run the visualization script with appropriate parameters: ```bash python Video-generic-heatEq.py --CPUs=4 --nGFS=100 --GridsPerR=128 \\ --ZMAX=4.0 --RMAX=4.0 --ZMIN=-4.0 --RMIN=-4.0 --tsnap=1.0 \\ --caseToProcess=1-conduction-2D-annulus --folderToSave=Video ``` 3. Create a video from the generated images (optional): ```bash ffmpeg -framerate 10 -pattern_type glob -i 'Video/*.png' -c:v libx264 -pix_fmt yuv420p video.mp4 ``` > [!tip] Customizing Visualizations You can adjust the visualization parameters to highlight different aspects of your results: > > - Change the colormap using the `cmap` parameter in `ax.imshow()` > - Adjust the value range with `vmin` and `vmax` > - Modify the plot layout or add additional subplots > - Include contour lines with `ax.contour()`",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#63-running-the-post-processing-pipeline",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Conclusion: Throughout this tutorial,...",
    "content": "Throughout this tutorial, we've progressed from simple 1D steady-state heat conduction problems in vanilla C to complex geometries and dimensions using Basilisk C. The key takeaways include: 1. Basilisk significantly reduces the complexity and verbosity of numerical simulation code 2. The event-based programming model provides a clean separation of concerns 3. Basilisk's domain-specific language makes numerical methods more intuitive 4. Built-in modules like `diffusion.h` and `embed.h` provide powerful, optimized solvers 5. Extending to higher dimensions and complex geometries is straightforward 6.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Conclusion: Results",
    "content": "Post-processing tools are essential for analyzing and interpreting simulation results > [!tip] Next Steps > > - Explore other physical phenomena like advection-diffusion > - Implement variable diffusion coefficients (e.g., temperature-dependent) > - Combine with Navier-Stokes solvers for natural convection problems > - Add source terms for heat generation > - Experiment with more complex geometries using the embedded boundary method > - Create interactive visualizations using tools like Plotly or ParaView",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - References and Resources: Context",
    "content": "- [Basilisk Documentation](http://basilisk.fr/Front%20Page) - [Embedded Boundaries in Basilisk](http://basilisk.fr/src/embed.h) - [Diffusion Module Documentation](http://basilisk.fr/src/diffusion.h) - [Axisymmetric Coordinates](http://basilisk.fr/src/axi.h) - [Adaptive Mesh Refinement](http://basilisk.fr/src/adapt.h) - [Basilisk View for Visualization](http://basilisk.fr/src/view.h) > [!question] Need Help?",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#references-and-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - References and Resources: If you encounter...",
    "content": "If you encounter issues with any of the exercises, please check: > > - Code syntax and structure > - Boundary condition implementation > - Event scheduling and dependencies > - Numerical stability considerations > > Feel free to open an issue on the GitHub repository if you need further assistance. > [!info] Info > Thanks for reading, and feel free to dive deeper (or suggest improvements) via the [GitHub repository](https://github.com/comphy-lab/CoMPhy-Lab-Blogs)! --- > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 25, 2025 at 14:22 > [!link] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#references-and-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - James G. Oldroyd: Life, Work, and Legacy in Rheology",
    "content": "![](../_Media/James%20G.%20Oldroyd-1741128879880.png) > Portrait and bio sketch of James G. Oldroyd. Slide taken from John Hinch's talk on _Oldroyd B, and not A?_",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#james-g-oldroyd-life-work-and-legacy-in-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Early Life and Education: James Gardner Oldroyd...",
    "content": "James Gardner Oldroyd (25 April 1921 \u2013 22 November 1982) demonstrated exceptional mathematical aptitude in Bradford, England. He entered Bradford Grammar School at age 10, matriculating in nine subjects by age 14. Unable to advance immediately to university due to his youth, he dedicated four years in sixth form to developing mathematical expertise while acquiring fluency in German and French. In 1939, Oldroyd secured a state scholarship to Trinity College, Cambridge, where he established an exemplary academic record. He received the Rouse Ball Prize in 1941 and the Mayhew Prize in 1942 as Cambridge's outstanding student in applied mathematics, graduating with first-class honors. Oldroyd maintained strong academic affiliations with Trinity College post-graduation, returning as a research scholar (1945\u201346) and securing a junior fellowship (1947).",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#early-life-and-education",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Early Life and Education: During this period,...",
    "content": "During this period, he completed his PhD thesis titled *\u201cA mathematical discussion of some rheological problems,\u201d* with guidance and critiques from W. R. Dean (of *Dean flow* fame) and Alan H. Wilson. Dean and Wilson $-$ both Cambridge trained mathematicians significantly influenced Oldroyd's approach to fluid mechanics and solid mechanics. His doctoral work (PhD awarded 1949) established fundamental principles in non-Newtonian fluid mechanics, culminating in his Cambridge Sc.D. in 1958 for his substantial contributions to the field [^1].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#early-life-and-education",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: World War II...",
    "content": "World War II interrupted Oldroyd\u2019s academic pursuits but also broadened his experience. From 1942 to 1945 he worked at the Ministry of Supply in Aberporth, Wales, conducting rocket research for Britain\u2019s war effort. This foray into applied physics and engineering gave him practical insight into fluid and material behavior under extreme conditions. After the war, Oldroyd transitioned back to research in emerging areas of fluid mechanics. In 1945 he joined the Fundamental Research Laboratory of **Courtaulds** in Maidenhead, a major industrial lab focused on artificial fibers and polymers [^2]. Notably, his former Cambridge tutor, Alan H. Wilson, had also moved to Courtaulds, and likely helped recruit Oldroyd to this innovative environment [^1]. At Courtaulds, Oldroyd worked closely with experimental rheologists **D. J. Strawbridge** and **B. A. Toms**, who were investigating the unusual flow behavior of polymer solutions [^2].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: Examples",
    "content": "These collaborations exposed Oldroyd to cutting-edge rheometry and puzzling phenomena \u2013 for example, B. A. Toms had just discovered the drag reduction effect (later called the *Toms effect*) where tiny polymer additives dramatically lower turbulent friction. Oldroyd became fascinated by such non-Newtonian effects and even suggested early on that *wall slip* at the pipe boundary might explain Toms\u2019s observations [^3]. This period at Courtaulds was formative: it immersed Oldroyd in real-world rheological problems, from the processing of viscose fibers to the oddities of polymer solution flows, inspiring him to seek a deeper theoretical framework for these `elastic` liquids. Oldroyd\u2019s first publications in the late 1940s already show him tackling non-Newtonian fluid mechanics with a blend of mathematical rigor and practical insight.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: He initially focused...",
    "content": "He initially focused on *viscoplasticity*, analyzing the flow of **Bingham solids** (materials that behave as a solid until a yield stress is exceeded when they flow). In 1947, while still in Cambridge, he published a series of papers on the *plastic flow of Bingham materials*, developing a `rational formulation` of their equations of flow and solving flow problems between moving cylinders. These early works, drawn from his dissertation, addressed how yield-stress fluids deform, essentially bridging solid plasticity and fluid flow. By 1949, Oldroyd had broadened his scope to other types of non-Newtonian fluids: he examined steady laminar flows in non-Newtonian liquids and noted anomalies like pressure gradients in pipe flow that couldn\u2019t be explained by classical viscosity alone. He even proposed experimental methods to detect wall slip and other flow peculiarities at the first International Congress on Rheology in 1948 [^1].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: These experiences convinced...",
    "content": "These experiences convinced Oldroyd that a unifying theoretical description for *complex fluids* was needed \u2013 one that could encompass the behavior of elastic liquids (polymer solutions), viscous suspensions, and even solids with memory. This realization set the stage for his groundbreaking work in 1950.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: In 1950, James...",
    "content": "In 1950, James G. Oldroyd published what is now considered **\u201cprobably the most important single paper in theoretical rheology.\u201d**[^6] Titled *\u201cOn the Formulation of Rheological Equations of State,\u201d*[^4] this paper established the basic principles for mathematical models of complex fluids. Oldroyd addressed a fundamental issue: existing viscoelastic models at the time (such as the Jeffreys model) were not *frame-invariant* \u2013 their predictions could depend on the observer\u2019s frame of reference, which is unphysical [^5]. Influenced by earlier work of Sir Harold Jeffreys and by a 1946 study of bitumen by H. Fr\u00f6hlich and R. Sack, Oldroyd recognized that the way one computes the time-derivative of stress in a flowing material is crucial. In essence, he argued that when a material element moves, rotates, and deforms, the rate-of-change of stress must be evaluated in a *convected frame* moving with the material.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: Definitions",
    "content": "To achieve this, Oldroyd introduced two new definitions of the stress derivative \u2013 the **upper-convected** and **lower-convected** time derivatives \u2013 which account for material rotation and stretching in different ways: > Lower convective Oldroyd derivative: > $$ \\stackrel{\\triangle}{A} = \\frac{DA}{Dt} + \\mathbf{A} \\cdot (\\nabla \\mathbf{u})^T + \\nabla \\mathbf{u} \\cdot \\mathbf{A}. $$ > Upper convective Oldroyd derivative: > $$ \\stackrel{\\nabla}{A} = \\frac{DA}{Dt} - \\mathbf{A} \\cdot (\\nabla \\mathbf{u})^T - \\nabla \\mathbf{u} \\cdot \\mathbf{A}. $$ Applying these ideas, Oldroyd showed that if one takes the classical *Jeffreys model* (a combination of an elastic spring and two viscous dashpots) and replaces the ordinary time derivatives with his convected derivatives, one obtains two consistent viscoelastic models [^5].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: These he called...",
    "content": "These he called \u201cModel A\u201d (using the lower-convected derivative) and \u201cModel B\u201d (using the upper-convected derivative) \u2013 known today as the **Oldroyd-A and Oldroyd-B models** [^5]. > Oldroyd-A (Lower convected derivative): > $$ \\sigma + \\tau_1 \\stackrel{\\triangle}{\\sigma} = 2\\mu^*(\\mathbf{E} + \\tau_2 \\stackrel{\\triangle}{\\mathbf{E}}),$$ > Oldroyd-B (Upper convected derivative): > $$ \\sigma + \\tau_1 \\stackrel{\\nabla}{\\sigma} = 2\\mu^*(\\mathbf{E} + \\tau_2 \\stackrel{\\nabla}{\\mathbf{E}})$$ Both models reduce to the same behavior in a stationary reference frame, but they differ in how they predict stresses in flows involving rotation or deformation of the fluid parcel. Oldroyd\u2019s 1950 paper thus laid down a clear *frame-indifference* requirement for rheological equations, a cornerstone for modern continuum mechanics of non-Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: It was a...",
    "content": "It was a bold theoretical leap that immediately gave researchers two possible constitutive equations for viscoelastic liquids. > [!danger] Note: > Oldroyd, characteristically cautious, noted that choosing between Model A and B `depends on the physics` of the material, though he offered no immediate criteria for selection [^5]. Nonetheless, the mere formulation of these models has been instructive. It provided, for the first time, a concrete mathematical language to describe fluids with both viscous and elastic characteristics (*viscoelastic* fluids) in a way that is invariant under changes of frame. This achievement earned Oldroyd international recognition \u2013 including the Gold Medal of the British Society of Rheology and a special issue of the BSR Bulletin honoring his 60th birthday [^6] \u2013 and it set the stage for much of the theoretical rheology that followed.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: While Oldroyd initially...",
    "content": "While Oldroyd initially presented **Models A and B** as two equally plausible formulations, subsequent insights and experiments soon favored one over the other. In the very same 1950 paper, at the end, Oldroyd himself included a telling calculation: the flow of an elastic liquid around a rotating rod. This was not an arbitrary choice \u2013 it related to a famous experiment by **Karl Weissenberg** a few years earlier. Weissenberg had observed that when a rod is rotated in a polymer solution, the fluid *climbs up* the rod against gravity (now known as the **Weissenberg effect** or rod-climbing effect) due to the elastic normal stresses generated in the fluid. Oldroyd wanted to see how his two model fluids would behave in this scenario. The result was striking: **Oldroyd-B (upper-convected)** predicted the fluid would climb the rod, matching Weissenberg\u2019s observations, whereas **Oldroyd-A (lower-convected)** predicted the opposite \u2013 the fluid would be pushed downwards (a \u201crod-dropping\u201d effect).",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: The latter phenomenon...",
    "content": "The latter phenomenon had never been observed in polymer fluids. Thus, by comparing both models against empirical reality, **Oldroyd-B emerged as the more physically relevant model for polymeric (viscoelastic) fluids**. As Oldroyd and others noted, the *rod-climbing test* essentially singled out Model B as the correct choice for liquids like dilute polymer solutions. Oldroyd commented that Model B should *\u201cbe favoured\u201d* in such cases, aligning with Weissenberg\u2019s findings. (Indeed, the inverse \u201crod-dipping\u201d behavior of Model A was only realized decades later in very different materials, such as dense suspensions of particles, confirming Oldroyd\u2019s intuition that the choice depends on the material\u2019s microphysics.) ![](../_Media/James%20G.%20Oldroyd-1741126421305.png) > A classic demonstration of the **Weissenberg rod-climbing effect**. A rotating rod in a viscoelastic polymer solution causes the fluid to climb up along the rod, due to positive normal stress differences.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: Oldroyd\u2019s upper-convected Model...",
    "content": "Oldroyd\u2019s upper-convected Model B correctly captures this effect, whereas Model A would predict a downward dip, which is not observed in polymer fluids. Figure credits: [Henry Ng and Rob Poole, University of Liverpool](https://fluids.ac.uk/gallery/zoomify/665). Beyond qualitative rod-climbing, more detailed **microstructural studies** in subsequent years reinforced the supremacy of Oldroyd-B for polymeric liquids. In the 1960s, rheologists developed molecular models of polymer solutions \u2013 envisioning long polymer molecules as tiny spring\u2013dashpot elements or \u201cdumbbells\u201d dispersed in a solvent. When **John Hinch** and others revisited Oldroyd\u2019s models in light of these developments, they found a remarkable connection: the simplest molecular model of a polymer chain in flow (the **elastic dumbbell model**) leads mathematically **directly to the Oldroyd-B constitutive equation** [^5].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: In other words,...",
    "content": "In other words, if one treats a polymer molecule as two beads connected by a spring dragged through a viscous solvent, the macroscopic stress evolution follows Oldroyd\u2019s upper-convected form (with the polymer\u2019s finite relaxation time corresponding to Oldroyd-B\u2019s parameters). This result explained why Oldroyd-B captured many polymer solution behaviors so well \u2013 it was essentially *derived from first principles* of polymer micro-dynamics. Oldroyd-A, in contrast, did not emerge from any analogous physical picture for flexible polymers. By the late 20th century, therefore, Oldroyd-B had become the **standard viscoelastic fluid model** for dilute polymer solutions in rheology and computational fluid dynamics, whereas Oldroyd-A largely faded from use.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: As John Hinch...",
    "content": "As John Hinch humorously noted, a survey of literature reveals thousands of papers employing \u201cOldroyd-B\u201d in their title or keywords, but only a handful mentioning \u201cOldroyd-A\u201d. ![](../_Media/James%20G.%20Oldroyd-1741126749363.jpeg) The reason is clear: Oldroyd-B not only passes key experimental tests but also has a firm basis in polymer molecular theory, making it the preferred tool for scientists and engineers modeling viscoelastic flows. The **legacy of Oldroyd\u2019s 1950 insight** is thus encapsulated in the ubiquity of the Oldroyd-B model \u2013 a tribute to his ability to capture the essential physics of elastic fluids in a simple equation.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: After 1950, Oldroyd...",
    "content": "After 1950, Oldroyd continued to build on his framework and ventured into new problems, further cementing his status as a pioneer in rheology. In 1953, he published a notable paper on *\u201cThe elastic and viscous properties of emulsions and suspensions.\u201d* [^7] Here, Oldroyd extended his constitutive modeling to **multiphase systems**, showing how a mixture of a liquid with dispersed droplets or particles could exhibit viscoelastic behavior. He demonstrated (for a dilute emulsion of liquid droplets) that the interfacial tension of the droplets provides a restoring force against deformation, effectively giving the emulsion an elastic component [^3]. This work was an early example of **micro-rheology** \u2013 linking microscopic structure to macroscopic rheological properties \u2013 and it illustrated Oldroyd\u2019s knack for generalizing his models to diverse materials.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: JavaScript",
    "content": "He also investigated the effect of surfactant films on droplet interfaces in emulsions, recognizing that a stabilizing film could alter the combined fluid\u2019s elasticity. These studies by Oldroyd in the 1950s are considered pioneering, as they connected continuum rheology with micro-scale mechanisms in suspensions and emulsions. Oldroyd\u2019s theoretical explorations in the mid-1950s also produced insights into what we now call **\u201csecond-order fluids.\u201d** In a 1958 paper, he analyzed normal stress effects (differences in normal stresses) in steady flows of idealized viscoelastic liquids, using a general invariant formulation that included up to quadratic terms in stresses [^8]. Notably, he examined the conditions for the Weissenberg effect (rod-climbing) to occur \u201cin a positive or negative sense,\u201d essentially exploring the parameter space where a fluid would climb or dip around a rod.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: This comprehensive study...",
    "content": "This comprehensive study brought clarity to how **non-Newtonian normal stresses** arise in shear and rotational flows, and it introduced what became known as the **Oldroyd 8-constant model** (a generalized linear viscoelastic model with eight material constants). Such work laid the groundwork for later researchers like Coleman, Noll, and Rivlin, who in the same era were developing the modern continuum mechanics of fluids. Oldroyd\u2019s approach was always characterized by careful attention to invariant formulation (he cited the earlier convected-coordinate ideas of F. Hencky and others [^3]) and by a desire to keep models as simple as possible while capturing the essential physics. In 1961, he published a survey in *Rheologica Acta* on *\u201cthe hydrodynamics of materials whose rheological properties are complicated,\u201d* [^9] reflecting on how to extend classical hydrodynamics to fluids with memory and elasticity.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: He even ventured...",
    "content": "He even ventured into esoteric territory by exploring constitutive equations in a general relativistic context (a 1970 paper on equations of state in general relativity [^10]), showing the breadth of his mathematical curiosity. Throughout the 1960s and 1970s, Oldroyd remained an active, though not prolific, author. He was selective in his publications, preferring depth over quantity \u2013 in nearly 40 years he published fewer than 30 papers [^1], mostly as a single author. Yet those papers are dense with ideas that continued to influence rheology. He developed a theory of **viscoplastic boundary layers**. He also revisited thermodynamics and continuum mechanics, searching for rheological models consistent with the laws of thermodynamics (as seen in his 1976 reflections).",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: Even in his...",
    "content": "Even in his final years, Oldroyd continued to synthesize his lifetime of insights: his last paper, published posthumously in 1984, was titled *\u201cAn approach to non-Newtonian fluid mechanics,\u201d*[^11] offering a grand overview of the field - a treat to read for our generation.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd\u2019s influence extended...",
    "content": "Oldroyd\u2019s influence extended beyond his written work; he was also a guiding figure and mentor in the rheology community. In 1953, the same year he took up a professorship, he served as **Treasurer of the 2nd International Congress of Rheology** held in Cambridge [^2] \u2013 a gathering of the world\u2019s top rheologists. He later became President of the British Society of Rheology (BSR) from 1955 to 1957, helping to shape the direction of rheological research in the UK [^12]. Oldroyd had moved to academia in 1953 as Professor of Mathematics at the University of Wales, Swansea, where he also headed the Applied Mathematics Department from 1957. In 1965, he was appointed Professor at Liverpool University, eventually becoming Head of the Department of Applied Mathematics and Theoretical Physics there [^2]. In these roles, Oldroyd supervised a small number of doctoral students \u2013 notably **Kenneth Walters**, who completed his PhD under Oldroyd at Swansea.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Walters would go...",
    "content": "Walters would go on to become a prominent rheologist himself (co-founding the *Journal of Non-Newtonian Fluid Mechanics* in 1976) and later reminisced that although Oldroyd guided only *\u201chalf a dozen\u201d* PhD students, his impact on them \u2013 and on the field \u2013 was profound [^13]. Oldroyd\u2019s students and colleagues admired his deep physical intuition and his knack for reducing complex problems to their core elements. Amusingly, Walters recalled that Oldroyd was *\u201cno sportsman,\u201d* yet somehow many of his research students were star cricket players \u2013 a coincidence that Oldroyd, with his gentle humor, tolerated even if he didn\u2019t share their sporting enthusiasm [^13]. In recognition of his scientific contributions, Oldroyd received numerous honors. Cambridge University awarded him the **Adams Prize in 1964**, one of its highest accolades in mathematics, for his work on the mechanics of non-Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: The British Society...",
    "content": "The British Society of Rheology bestowed upon him its **Gold Medal** in 1984 (the year after what would have been Oldroyd\u2019s retirement), celebrating a lifetime of achievement in rheology [^2]. Tributes poured in as he reached his 60th birthday in 1981 \u2013 the BSR dedicated a special issue of its bulletin to him, and luminaries like professor R. B. Bird lauded Oldroyd\u2019s contributions.[^6] In fact, at the 1988 International Congress on Rheology in Sydney, Bob Bird gave an opening lecture entitled *\u201cThe Two JG\u2019s\u201d* in honor of **J. G. Oldroyd** and **J. G. Kirkwood** \u2013 comparing Oldroyd, the continuum mechanician, and Kirkwood, the molecular theorist, as two giants who bridged the gap between macroscopic and microscopic understandings of fluid behavior [^1]. This was a testament to how Oldroyd\u2019s work, particularly the Oldroyd-B model, had become a cornerstone that linked molecular theory with continuum modeling. Unfortunately, James G.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd\u2019s life was...",
    "content": "Oldroyd\u2019s life was cut short in 1982 \u2013 he died suddenly of an apparent heart attack while on his way to the university in Liverpool [^2] \u2013 but his legacy endures vibrantly. His name is forever attached to the **Oldroyd-B model**, a staple in rheology textbooks and simulations, and his ideas on convected derivatives underpin all modern viscoelastic fluid theories. In computational fluid dynamics and engineering today, Oldroyd\u2019s models are routinely used to simulate polymer processing, biological fluid flows, and complex material behavior, enabling predictions of how materials will respond under flow with both viscous and elastic forces at play. In hindsight, John Hinch and other colleagues note that Oldroyd\u2019s genius was in formulating simple yet physically sound models \u2013 *\u201cthe first twelve pages\u201d* of his 1950 paper, as Bob Bird once remarked, *contained the seeds of an entire field*.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: By following a...",
    "content": "By following a historical narrative from classical mechanics to modern rheology, Oldroyd essentially wrote the chapter that connects **Isaac Newton\u2019s** fluid (ideal viscous) to **James Clerk Maxwell\u2019s** elastic solid, and in doing so, he helped create the science of rheology as we know it. His work evolved from early studies of idealized plastic solids to the elegant Oldroyd-B equation, reflecting a consistent vision: to understand and predict the behavior of materials that are not purely solid nor liquid, but something in between. This vision, shaped by great mentors, wartime experiences, industrial collaboration, and personal insight, makes James G. Oldroyd a towering figure in the history of rheology and fluid mechanics \u2013 one whose influence is still climbing upward, much like the fluid on Weissenberg\u2019s spinning rod. [^1]: I. A. Frigaard, G. H. McKinley, R. J. Poole & K.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Walters, Editorial for...",
    "content": "Walters, Editorial for special issue on \"Oldroyd at 100: Celebrating the impact of JG Oldroyd on non-Newtonian fluid mechanics\", J. Non-Newtonian Fluid Mech., 301, 104749 (2022), [Link](https://nnf.mit.edu/sites/default/files/publications/files/Oldroyd_SI_Editorial_FINAL.pdf). [^2]: James G. Oldroyd \u2013 Wikipedia: [German](https://de.wikipedia.org/wiki/James_G._Oldroyd) and [English](https://en.wikipedia.org/wiki/James_G._Oldroyd). [^3]: R. I. Tanner & K. Walters, Rheology: An Historical Perspective, Elsevier (1998). [Link](https://bit.ly/4bohW0t). [^4]: J. G. Oldroyd, On the formulation of rheological equations of state, Proc. R. Soc. Lond. A, 200:1063, 523-541 (1950) [^5]: J. Hinch & O. Harlen, Oldroyd B, and not A?, J. Non-Newtonian Fluid Mech., 298, 104668 (2021) [link](http://www.damtp.cam.ac.uk/user/hinch/publications/Oldroyd12b.pdf#:~:text=Sack%20%281946%29%20,would%20climb%20the%20rod%2C%20as). [^6]: #TODO needs citation and wikipedia is not it [^7]: J. G.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd, The elastic...",
    "content": "Oldroyd, The elastic and viscous properties of emulsions and suspensions, Proc. R. Soc. Lond. A, 218:1132, 122-132 (1953) [^8]: J. G. Oldroyd, Non-Newtonian effects in steady motion of some idealized elastico-viscous liquids, Proc. R. Soc. Lond. A, 245:1241, 278-297 (1958). [^9]: J. G. Oldroyd, The hydrodynamics of materials whose rheological properties are complicated, Rheol. Acta, 1:4, 337-344 (1961) [^10]: J. G. Oldroyd, Equations of state of continuous matter in general relativity, Proc. R. Soc. Lond. A, 316:1524, 1-28 (1970) [^11]: J. G. Oldroyd, An approach to non-Newtonian fluid mechanics, J.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Context",
    "content": "Non-Newtonian Fluid Mech., 14, 9-46 (1984) [^12]: [Former BSR Presidents - British Society of Rheology](https://www.bsr.org.uk/pages/former-bsr-presidents#:~:text=Image%3A%20Photo%20of%20Oldroyd) [^13]: [Oral History Interviews, Kenneth Walters - American Institute of Physics](https://www.aip.org/history-programs/niels-bohr-library/oral-histories/47534#:~:text=match%20at%20L1785%20The%20amazing,Fluid%20Mechanics%2C%E2%80%99%E2%80%99%20Journal%20of%20Non)",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - James G. Oldroyd: Life, Work, and Legacy in Rheology",
    "content": "![Portrait of James G. Oldroyd|1066x24](_Media/James%20G.%20Oldroyd-1741128879880.png) > Portrait and bio sketch of James G. Oldroyd. Slide taken from John Hinch's talk on _Oldroyd B, and not A?_",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#james-g-oldroyd-life-work-and-legacy-in-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Early Life and Education: During this period,...",
    "content": "During this period, he completed his PhD thesis titled _\"A mathematical discussion of some rheological problems,\"_ with guidance and critiques from W. R. Dean (of _Dean flow_ fame) and Alan H. Wilson. Dean and Wilson\u2014both Cambridge-trained mathematicians\u2014significantly influenced Oldroyd's approach to fluid mechanics and solid mechanics. His doctoral work (PhD awarded 1949) established fundamental principles in non-Newtonian fluid mechanics, culminating in his Cambridge Sc.D. in 1958 for his substantial contributions to the field [^1].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#early-life-and-education",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: World War II...",
    "content": "World War II interrupted Oldroyd's academic pursuits but also broadened his experience. From 1942 to 1945 he worked at the Ministry of Supply in Aberporth, Wales, conducting rocket research for Britain's war effort. This foray into applied physics and engineering gave him practical insight into fluid and material behavior under extreme conditions. After the war, Oldroyd transitioned back to research in emerging areas of fluid mechanics. In 1945 he joined the Fundamental Research Laboratory of **Courtaulds** in Maidenhead, a major industrial lab focused on artificial fibers and polymers [^2]. Notably, his former Cambridge tutor, Alan H. Wilson, had also moved to Courtaulds, and likely helped recruit Oldroyd to this innovative environment [^1]. At Courtaulds, Oldroyd worked closely with experimental rheologists **D. J. Strawbridge** and **B. A. Toms**, who were investigating the unusual flow behavior of polymer solutions [^2].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: Examples",
    "content": "These collaborations exposed Oldroyd to cutting-edge rheometry and puzzling phenomena \u2013 for example, B. A. Toms had just discovered the drag reduction effect (later called the _Toms effect_) where tiny polymer additives dramatically lower turbulent friction. Oldroyd became fascinated by such non-Newtonian effects and even suggested early on that _wall slip_ at the pipe boundary might explain Toms's observations [^3]. This period at Courtaulds was formative: it immersed Oldroyd in real-world rheological problems, from the processing of viscose fibers to the oddities of polymer solution flows, inspiring him to seek a deeper theoretical framework for these `elastic` liquids. Oldroyd's first publications in the late 1940s already show him tackling non-Newtonian fluid mechanics with a blend of mathematical rigor and practical insight.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: He initially focused...",
    "content": "He initially focused on _viscoplasticity_, analyzing the flow of **Bingham solids** (materials that behave as a solid until a yield stress is exceeded when they flow). In 1947, while still in Cambridge, he published a series of papers on the _plastic flow of Bingham materials_, developing a `rational formulation` of their equations of flow and solving flow problems between moving cylinders. These early works, drawn from his dissertation, addressed how yield-stress fluids deform, essentially bridging solid plasticity and fluid flow. By 1949, Oldroyd had broadened his scope to other types of non-Newtonian fluids: he examined steady laminar flows in non-Newtonian liquids and noted anomalies like pressure gradients in pipe flow that couldn't be explained by classical viscosity alone. He even proposed experimental methods to detect wall slip and other flow peculiarities at the first International Congress on Rheology in 1948 [^1].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: These experiences convinced...",
    "content": "These experiences convinced Oldroyd that a unifying theoretical description for _complex fluids_ was needed \u2013 one that could encompass the behavior of elastic liquids (polymer solutions), viscous suspensions, and even solids with memory. This realization set the stage for his groundbreaking work in 1950.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: In 1950, James...",
    "content": "In 1950, James G. Oldroyd published what is now considered **\"probably the most important single paper in theoretical rheology.\"**[^6] Titled _\"On the Formulation of Rheological Equations of State,\"_[^4] this paper established the basic principles for mathematical models of complex fluids. Oldroyd addressed a fundamental issue: existing viscoelastic models at the time (such as the Jeffreys model) were not _frame-invariant_ \u2013 their predictions could depend on the observer's frame of reference, which is unphysical [^5]. Influenced by earlier work of Sir Harold Jeffreys and by a 1946 study of bitumen by H. Fr\u00f6hlich and R. Sack, Oldroyd recognized that the way one computes the time-derivative of stress in a flowing material is crucial. In essence, he argued that when a material element moves, rotates, and deforms, the rate-of-change of stress must be evaluated in a _convected frame_ moving with the material.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: Definitions",
    "content": "To achieve this, Oldroyd introduced two new definitions of the stress derivative \u2013 the **upper-convected** and **lower-convected** time derivatives \u2013 which account for material rotation and stretching in different ways: > Lower convective Oldroyd derivative: $$ \\stackrel{\\triangle}{A} = \\frac{DA}{Dt} + \\mathbf{A} \\cdot (\\nabla \\mathbf{u})^T + \\nabla \\mathbf{u} \\cdot \\mathbf{A}. $$ > Upper convective Oldroyd derivative: $$ \\stackrel{\\nabla}{A} = \\frac{DA}{Dt} - \\mathbf{A} \\cdot (\\nabla \\mathbf{u})^T - \\nabla \\mathbf{u} \\cdot \\mathbf{A}. $$ Applying these ideas, Oldroyd showed that if one takes the classical _Jeffreys model_ (a combination of an elastic spring and two viscous dashpots) and replaces the ordinary time derivatives with his convected derivatives, one obtains two consistent viscoelastic models [^5].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: These he called...",
    "content": "These he called \"Model A\" (using the lower-convected derivative) and \"Model B\" (using the upper-convected derivative) \u2013 known today as the **Oldroyd-A and Oldroyd-B models** [^5]. > Oldroyd-A (Lower convected derivative): > $$ \\sigma + \\tau_1 \\stackrel{\\triangle}{\\sigma} = 2\\mu^*(\\mathbf{E} + \\tau_2 \\stackrel{\\triangle}{\\mathbf{E}}),$$ > Oldroyd-B (Upper convected derivative): > $$ \\sigma + \\tau_1 \\stackrel{\\nabla}{\\sigma} = 2\\mu^*(\\mathbf{E} + \\tau_2 \\stackrel{\\nabla}{\\mathbf{E}})$$ Both models reduce to the same behavior in a stationary reference frame, but they differ in how they predict stresses in flows involving rotation or deformation of the fluid parcel. Oldroyd's 1950 paper thus laid down a clear _frame-indifference_ requirement for rheological equations, a cornerstone for modern continuum mechanics of non-Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: It was a...",
    "content": "It was a bold theoretical leap that immediately gave researchers two possible constitutive equations for viscoelastic liquids. > [!danger] Note: Oldroyd, characteristically cautious, noted that choosing between Model A and B `depends on the physics` of the material, though he offered no immediate criteria for selection [^5]. Nonetheless, the mere formulation of these models has been instructive. It provided, for the first time, a concrete mathematical language to describe fluids with both viscous and elastic characteristics (_viscoelastic_ fluids) in a way that is invariant under changes of frame. This achievement earned Oldroyd international recognition \u2013 including the Gold Medal of the British Society of Rheology and a special issue of the BSR Bulletin honoring his 60th birthday [^6] \u2013 and it set the stage for much of the theoretical rheology that followed.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: While Oldroyd initially...",
    "content": "While Oldroyd initially presented **Models A and B** as two equally plausible formulations, subsequent insights and experiments soon favored one over the other. In the very same 1950 paper, at the end, Oldroyd himself included a telling calculation: the flow of an elastic liquid around a rotating rod. This was not an arbitrary choice \u2013 it related to a famous experiment by **Karl Weissenberg** a few years earlier. Weissenberg had observed that when a rod is rotated in a polymer solution, the fluid _climbs up_ the rod against gravity (now known as the **Weissenberg effect** or rod-climbing effect) due to the elastic normal stresses generated in the fluid. Oldroyd wanted to see how his two model fluids would behave in this scenario. The result was striking: **Oldroyd-B (upper-convected)** predicted the fluid would climb the rod, matching Weissenberg's observations, whereas **Oldroyd-A (lower-convected)** predicted the opposite \u2013 the fluid would be pushed downwards (a \"rod-dropping\" effect).",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: The latter phenomenon...",
    "content": "The latter phenomenon had never been observed in polymer fluids. Thus, by comparing both models against empirical reality, **Oldroyd-B emerged as the more physically relevant model for polymeric (viscoelastic) fluids**. As Oldroyd and others noted, the _rod-climbing test_ essentially singled out Model B as the correct choice for liquids like dilute polymer solutions. Oldroyd commented that Model B should _\"be favoured\"_ in such cases, aligning with Weissenberg's findings. (Indeed, the inverse \"rod-dipping\" behavior of Model A was only realized decades later in very different materials, such as dense suspensions of particles, confirming Oldroyd's intuition that the choice depends on the material's microphysics.) ![Weissenberg rod-climbing effect](_Media/James%20G.%20Oldroyd-1741126421305.png) > A classic demonstration of the **Weissenberg rod-climbing effect**.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: A rotating rod...",
    "content": "A rotating rod in a viscoelastic polymer solution causes the fluid to climb up along the rod, due to positive normal stress differences. Oldroyd's upper-convected Model B correctly captures this effect, whereas Model A would predict a downward dip, which is not observed in polymer fluids. Figure credits: [Henry Ng and Rob Poole, University of Liverpool](https://fluids.ac.uk/gallery/zoomify/665). Beyond qualitative rod-climbing, more detailed **microstructural studies** in subsequent years reinforced the supremacy of Oldroyd-B for polymeric liquids. In the 1960s, rheologists developed molecular models of polymer solutions \u2013 envisioning long polymer molecules as tiny spring\u2013dashpot elements or \"dumbbells\" dispersed in a solvent.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: When **John Hinch**...",
    "content": "When **John Hinch** and others revisited Oldroyd's models in light of these developments, they found a remarkable connection: the simplest molecular model of a polymer chain in flow (the **elastic dumbbell model**) leads mathematically **directly to the Oldroyd-B constitutive equation** [^5]. In other words, if one treats a polymer molecule as two beads connected by a spring dragged through a viscous solvent, the macroscopic stress evolution follows Oldroyd's upper-convected form (with the polymer's finite relaxation time corresponding to Oldroyd-B's parameters). This result explained why Oldroyd-B captured many polymer solution behaviors so well \u2013 it was essentially _derived from first principles_ of polymer micro-dynamics. Oldroyd-A, in contrast, did not emerge from any analogous physical picture for flexible polymers.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: By the late...",
    "content": "By the late 20th century, therefore, Oldroyd-B had become the **standard viscoelastic fluid model** for dilute polymer solutions in rheology and computational fluid dynamics, whereas Oldroyd-A largely faded from use. As John Hinch humorously noted, a survey of literature reveals thousands of papers employing \"Oldroyd-B\" in their title or keywords, but only a handful mentioning \"Oldroyd-A\". ![Polymer solution model](https://claude.ai/chat/_Media/James%20G.%20Oldroyd-1741126749363.jpeg) The reason is clear: Oldroyd-B not only passes key experimental tests but also has a firm basis in polymer molecular theory, making it the preferred tool for scientists and engineers modeling viscoelastic flows. The **legacy of Oldroyd's 1950 insight** is thus encapsulated in the ubiquity of the Oldroyd-B model \u2013 a tribute to his ability to capture the essential physics of elastic fluids in a simple equation.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: After 1950, Oldroyd...",
    "content": "After 1950, Oldroyd continued to build on his framework and ventured into new problems, further cementing his status as a pioneer in rheology. In 1953, he published a notable paper on _\"The elastic and viscous properties of emulsions and suspensions.\"_ [^7] Here, Oldroyd extended his constitutive modeling to **multiphase systems**, showing how a mixture of a liquid with dispersed droplets or particles could exhibit viscoelastic behavior. He demonstrated (for a dilute emulsion of liquid droplets) that the interfacial tension of the droplets provides a restoring force against deformation, effectively giving the emulsion an elastic component [^3]. This work was an early example of **micro-rheology** \u2013 linking microscopic structure to macroscopic rheological properties \u2013 and it illustrated Oldroyd's knack for generalizing his models to diverse materials.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: JavaScript",
    "content": "He also investigated the effect of surfactant films on droplet interfaces in emulsions, recognizing that a stabilizing film could alter the combined fluid's elasticity. These studies by Oldroyd in the 1950s are considered pioneering, as they connected continuum rheology with micro-scale mechanisms in suspensions and emulsions. Oldroyd's theoretical explorations in the mid-1950s also produced insights into what we now call **\"second-order fluids.\"** In a 1958 paper, he analyzed normal stress effects (differences in normal stresses) in steady flows of idealized viscoelastic liquids, using a general invariant formulation that included up to quadratic terms in stresses [^8]. Notably, he examined the conditions for the Weissenberg effect (rod-climbing) to occur \"in a positive or negative sense,\" essentially exploring the parameter space where a fluid would climb or dip around a rod.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: This comprehensive study...",
    "content": "This comprehensive study brought clarity to how **non-Newtonian normal stresses** arise in shear and rotational flows, and it introduced what became known as the **Oldroyd 8-constant model** (a generalized linear viscoelastic model with eight material constants). Such work laid the groundwork for later researchers like Coleman, Noll, and Rivlin, who in the same era were developing the modern continuum mechanics of fluids. Oldroyd's approach was always characterized by careful attention to invariant formulation (he cited the earlier convected-coordinate ideas of F. Hencky and others [^3]) and by a desire to keep models as simple as possible while capturing the essential physics. In 1961, he published a survey in _Rheologica Acta_ on _\"the hydrodynamics of materials whose rheological properties are complicated,\"_ [^9] reflecting on how to extend classical hydrodynamics to fluids with memory and elasticity.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: Even in his...",
    "content": "Even in his final years, Oldroyd continued to synthesize his lifetime of insights: his last paper, published posthumously in 1984, was titled _\"An approach to non-Newtonian fluid mechanics,\"_[^11] offering a grand overview of the field - a treat to read for our generation.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd's influence extended...",
    "content": "Oldroyd's influence extended beyond his written work; he was also a guiding figure and mentor in the rheology community. In 1953, the same year he took up a professorship, he served as **Treasurer of the 2nd International Congress of Rheology** held in Cambridge [^2] \u2013 a gathering of the world's top rheologists. He later became President of the British Society of Rheology (BSR) from 1955 to 1957, helping to shape the direction of rheological research in the UK [^12]. Oldroyd had moved to academia in 1953 as Professor of Mathematics at the University of Wales, Swansea, where he also headed the Applied Mathematics Department from 1957. In 1965, he was appointed Professor at Liverpool University, eventually becoming Head of the Department of Applied Mathematics and Theoretical Physics there [^2]. In these roles, Oldroyd supervised a small number of doctoral students \u2013 notably **Kenneth Walters**, who completed his PhD under Oldroyd at Swansea.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Walters would go...",
    "content": "Walters would go on to become a prominent rheologist himself (co-founding the _Journal of Non-Newtonian Fluid Mechanics_ in 1976) and later reminisced that although Oldroyd guided only _\"half a dozen\"_ PhD students, his impact on them \u2013 and on the field \u2013 was profound [^13]. Oldroyd's students and colleagues admired his deep physical intuition and his knack for reducing complex problems to their core elements. Amusingly, Walters recalled that Oldroyd was _\"no sportsman,\"_ yet somehow many of his research students were star cricket players \u2013 a coincidence that Oldroyd, with his gentle humor, tolerated even if he didn't share their sporting enthusiasm [^13]. In recognition of his scientific contributions, Oldroyd received numerous honors. Cambridge University awarded him the **Adams Prize in 1964**, one of its highest accolades in mathematics, for his work on the mechanics of non-Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: The British Society...",
    "content": "The British Society of Rheology bestowed upon him its **Gold Medal** in 1984 (the year after what would have been Oldroyd's retirement), celebrating a lifetime of achievement in rheology [^2]. Tributes poured in as he reached his 60th birthday in 1981 \u2013 the BSR dedicated a special issue of its bulletin to him, and luminaries like professor R. B. Bird lauded Oldroyd's contributions [^6]. In fact, at the 1988 International Congress on Rheology in Sydney, Bob Bird gave an opening lecture entitled _\"The Two JG's\"_ in honor of **J. G. Oldroyd** and **J. G. Kirkwood** \u2013 comparing Oldroyd, the continuum mechanician, and Kirkwood, the molecular theorist, as two giants who bridged the gap between macroscopic and microscopic understandings of fluid behavior [^1]. This was a testament to how Oldroyd's work, particularly the Oldroyd-B model, had become a cornerstone that linked molecular theory with continuum modeling. Unfortunately, James G.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd's life was...",
    "content": "Oldroyd's life was cut short in 1982 \u2013 he died suddenly of an apparent heart attack while on his way to the university in Liverpool [^2] \u2013 but his legacy endures vibrantly. His name is forever attached to the **Oldroyd-B model**, a staple in rheology textbooks and simulations, and his ideas on convected derivatives underpin all modern viscoelastic fluid theories. In computational fluid dynamics and engineering today, Oldroyd's models are routinely used to simulate polymer processing, biological fluid flows, and complex material behavior, enabling predictions of how materials will respond under flow with both viscous and elastic forces at play. In hindsight, John Hinch and other colleagues note that Oldroyd's genius was in formulating simple yet physically sound models \u2013 _\"the first twelve pages\"_ of his 1950 paper, as Bob Bird once remarked, _contained the seeds of an entire field_.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: By following a...",
    "content": "By following a historical narrative from classical mechanics to modern rheology, Oldroyd essentially wrote the chapter that connects **Isaac Newton's** fluid (ideal viscous) to **James Clerk Maxwell's** elastic solid, and in doing so, he helped create the science of rheology as we know it. His work evolved from early studies of idealized plastic solids to the elegant Oldroyd-B equation, reflecting a consistent vision: to understand and predict the behavior of materials that are not purely solid nor liquid, but something in between. This vision, shaped by great mentors, wartime experiences, industrial collaboration, and personal insight, makes James G. Oldroyd a towering figure in the history of rheology and fluid mechanics \u2013 one whose influence is still climbing upward, much like the fluid on Weissenberg's spinning rod. [^1]: I. A. Frigaard, G. H. McKinley, R. J. Poole & K.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Thesis viscous free surface flows",
    "content": "> [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab) > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: > Date modified::",
    "url": "https://blogs.comphy-lab.org/Blog/Thesis-Viscous Free-Surface Flows/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Features of capillary waves during asymmetric bubble coalescence: > [!tldr] TL;DR...",
    "content": "> [!tldr] TL;DR > During the coalescence of bubbles with different sizes, the **speed** of the ensuing capillary waves remains almost unchanged and scales with the inertio\u2010capillary velocity. However, the strength (or curvature) of these waves depends on the bubble size ratio. In the equal\u2010sized case, the wave curvature diminishes and then plateaus, whereas for highly asymmetric (large vs. tiny) bubbles, the curvature initially decreases but then rebounds sharply due to the changing geometry. Two **approximate** scaling laws emerge for the strongest wave curvature: \ufffc in the low\u2010viscosity limit and \ufffc in the moderate\u2010to\u2010higher viscosity regime. Experimental data diverge somewhat from these simple power laws, indicating a need for refined models to explain the distinct curvature behavior at low Ohnesorge numbers. ![Fig-1_schematic](_Media/20250112214056729_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 1. Schematic of asymmetric coalescence of bubbles.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#features-of-capillary-waves-during-asymmetric-bubble-coalescence",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Features of capillary waves during asymmetric bubble coalescence: Following the coalescnece,...",
    "content": "Following the coalescnece, train of capillary waves travel on the surface of both bubbles.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#features-of-capillary-waves-during-asymmetric-bubble-coalescence",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Control parameters",
    "content": "**Ohnesorge number** (ratio of the inertio-capillary and inertio-viscous timescales) $$ Oh = \\frac{\\eta_l}{\\sqrt{\\rho_l\\gamma R_0}} $$ **Asymmetry parameter** (ratio of the radii of the two bubbles) $$ \\chi = \\frac{R}{r} $$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#control-parameters",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Coalescence of equal sized bubbles ($R = r$)",
    "content": "[Open on YouTube](https://youtu.be/Bm4qC0BSGkc)",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#coalescence-of-equal-sized-bubbles-r-r",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Coalescence of tiny bubbles with extremely large ones ($R \\gg r$)",
    "content": "[Open on YouTube](https://youtu.be/QbQ4wrTjTks)",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#coalescence-of-tiny-bubbles-with-extremely-large-ones-r-gg-r",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Looking at the speed of the capillary waves",
    "content": "> [!important] > The velocity of this capillary waves still scales with the inertio-capillary velocity! ![Fig-2_waveTrajectory](_Media/20250112214130458_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 2. Trajectory of the capillary waves during coalescence of same sized bubbles ($R = r$). Different colors represent different Ohnesorge numbers $Oh$. ![Fig-3_waveSpeed](_Media/20250112214151030_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 3. Trajectory of the capillary waves during coalescence of same unequal sized bubbles with $R \\gg r$. Different colors represent different Ohnesorge numbers $Oh$. > [!note] > Infact the velocity hardly changes from $R = r$ to $R \\gg r$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#looking-at-the-speed-of-the-capillary-waves",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Strength of capillary waves for $R = r$",
    "content": "Although the speed of capillary waves remain the same. There can be differences in the strength of the waves. ![Fig-4_capillary-waves-Same-sized](_Media/20250112214226072_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 4. The curvature of the strongest capillary wave decreases in time and then saturates to a constant value. This is different from what happens at $R \\gg r$, ![Fig-5_capillary-waves-champagne-bubbles](_Media/20250112214243110_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 5. The curvature of the strongest capillary wave decreases in time, reaches a minima, and then increases sharply as the bubble cavity configuration changes (see video above, and also see [1]).",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#strength-of-capillary-waves-for-r-r",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Can we understand this change in curvature?: Results",
    "content": "Given the asymmetry at $R \\gg r$, the waves have this feature to come back up and the curvature increases whereas for $R = r$ symmetry of the problem results in no significant geometry change following flow focussing and the curvature does not further increase. Looking at the balance between the kinetic energy (generated immediately following the coalescence event), $$ \\frac{d}{d\\tau}\\int_{\\Omega_\\kappa}\\frac{\\rho V^2}{2}d\\Omega_\\kappa \\sim 2\\eta\\int_{\\Omega_\\eta}\\left(\\boldsymbol{\\mathcal{D}:\\mathcal{D}}\\right)d\\Omega_\\eta $$ **Note:** Here, we balance the kinetic energy of the capillary waves (across volume $\\Omega_\\kappa$) with viscous dissipation across the bulk volume $\\Omega_\\eta$ where velocity gradients are non-zero.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#can-we-understand-this-change-in-curvature",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Can we understand this change in curvature?: Consequently, the volume...",
    "content": "Consequently, the volume scale associated with the kinetic energy carried by the waves is $\\Omega_\\kappa \\sim R\\kappa^{-2}$ and the dissipation volume scales as $\\Omega_\\eta \\sim R\\delta_\\eta^2$ where $\\delta_\\eta$ is the viscous boundary layer attached to the free-surface where velocity gradients are highest (see the videos above, the dark regions in visocus dissipation function characterize $\\Omega_\\eta$ and high velocity regions indicate $\\Omega_\\kappa$) $$ \\frac{1}{\\tau}\\rho V^2 R\\kappa^{-2} \\sim \\eta\\left(\\frac{V}{\\kappa^{-1}}\\right)^2R\\delta^2 $$ Rearranging the above equation, we can find the time scale associated with this transfer process: $$ \\tau \\sim \\frac{\\rho}{\\eta}\\frac{\\kappa^{-4}}{\\delta^2} $$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#can-we-understand-this-change-in-curvature",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Rearranging the expression and substituting inertio-capillary timescale",
    "content": "$$ \\kappa^4\\delta^2 \\sim \\frac{\\rho}{\\eta}\\sqrt{\\frac{\\gamma}{\\rho R^3}} $$ Normalize both sides by $R^2$, $$ \\tilde{\\kappa}^4\\tilde{\\delta}^2 \\sim \\frac{\\sqrt{\\rho\\gamma R}}{\\eta} $$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#rearranging-the-expression-and-substituting-inertio-capillary-timescale",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - In the low viscosity limit,",
    "content": "$\\delta \\sim \\kappa^{-1}$, which giving $$ \\tilde{\\kappa} \\sim Oh^{-1/2} $$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#in-the-low-viscosity-limit",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - In moderate high viscosity limit,: $$ \\delta \\sim...",
    "content": "$$ \\delta \\sim \\sqrt{\\frac{\\eta}{\\rho}t} = \\sqrt{\\frac{\\eta}{\\rho}\\left(\\frac{\\rho\\kappa^{-3}}{\\gamma}\\right)^{1/2}} $$ **Rearranging the expression and filling in the general equation relating $\\kappa$ and $\\delta$ gives** $$ \\tilde{\\kappa}^{5/2} \\sim \\frac{\\rho\\gamma R}{\\eta^2} $$ or, $$ \\tilde{\\kappa} \\sim Oh^{-4/5} $$ ![Fig-6_curvatureAndOh-R](_Media/20250112214304930_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 6. Minumum curvature of the strongest capillary wave as a function of the Ohnesorge number and the radii ratio of the two bubbles. The two scaling relations developed above are reasonable but the deviations observed in the data leave room for improvement. > [!cite] Note: > The scaling laws developed here are also described in detail in [2] So, why does the radii ratio influence the curvature strongly but not the wave speed? **Unfortunately,** this is still an open question.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#in-moderate-high-viscosity-limit",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - In moderate high viscosity limit,: The hand-wavy argument...",
    "content": "The hand-wavy argument is given in this document (including the geometric and asymmetry arguments) but the scaling laws developed here only work approximately and clearly the data for $Oh \\to 0$ shows deviation in curvature. #foodForThought",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#in-moderate-high-viscosity-limit",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - More resources: Context",
    "content": "| [GitHub](https://github.com/VatsalSy/Asymmetries-in-coalescence) | [License](https://github.com/VatsalSy/Asymmetries-in-coalescence/blob/main/LICENSE) | [Latest Changes](https://github.com/VatsalSy/Asymmetries-in-coalescence/commits/main) | [[Features-of-capillary-waves-during-asymmetric-bubble-coalescence.pdf\\|pdf]] | | :--------------------------------------------------------------: | :---------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------------: | ----------------------------------------------------------------------------- | [1] V. Sanjay, D. Lohse, and M. Jalaal, \u201cBursting bubble in a viscoplastic medium,\u201d _J. Fluid Mech._, vol. 922, p. A2, 2021. [2] J. M. Gordillo and J. Rodr\u00edguez-Rodr\u00edguez, \u201cCapillary waves control the ejection of bubble bursting jets,\u201d _J.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#more-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - More resources: Context",
    "content": "Fluid Mech._, vol. 867, pp. 556\u2013571, May 2019, doi: [10.1017/jfm.2019.161](https://doi.org/10.1017/jfm.2019.161). > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 12, 2025 > Date modified:: Jan 26, 2025 at 11:50 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#more-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Stokes waves of arbitrary order: Context",
    "content": "Vatsal Sanjay ([https://comphy-lab.org](https://comphy-lab.org)), CoMPhy Lab, Physics of Fluids, Univ.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#stokes-waves-of-arbitrary-order",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Stokes waves of arbitrary order: Function Definition",
    "content": "Twente $$\\eta(x)=a\\sum_{n=1}^{N}\\left[c_{n}\\,\\epsilon^{n}\\,\\cos\\bigl(nkx\\bigr)\\right],$$ where the function $c_n$ is $$ c_{n} = \\frac{(2n - 1)!!}{2^{n-1}\\,n!}.$$ ```c /** * @brief Calculates the Stokes coefficient for nth order wave * @param n Order of the wave * @return Coefficient value based on double factorial calculation */ double stokes_coefficient (int n) { if (n == 1) return 1.0; int k = 2*n - 1; double double_factorial = 1.0; for (int i = 1; i <= k; i += 2) double_factorial *= i; return double_factorial / (pow(2,(n-1)) * tgamma(n+1)); } /** * @brief Calculates the surface elevation for Stokes wave * @param x Horizontal position * @param a Wave amplitude * @param k Wave number * @param order Order of Stokes expansion * @return Surface elevation at position x */ double eta_stokes (double x, double a, double k, int order) { double eta = 0.0; double epsilon = k*a; for (int n = 1; n <= order; n++) { double c = stokes_coefficient(n); eta += c * pow(epsilon, n)*cos(n*k*x); } return eta * a; } ```",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#stokes-waves-of-arbitrary-order",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Problem Statement",
    "content": "How to describe nonlinear waves? - With a particular emphasis on extending the accuracy and applicability of wave theories for ocean engineering. The primary focus is to address periodic standing waves and Stokes waves, which are critical for understanding wave interactions in shallow and deep water regimes. Central to this is determining coefficients and analytical solutions for arbitrary-order expansions.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#problem-statement",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Methodology",
    "content": "- [[fentonNumericalMethodsNonlinear1999|Fenton (1999)]] emphasizes numerical solutions for nonlinear problems, including high-order Fourier methods for wave field expansions and their convergence properties. [@fentonNumericalMethodsNonlinear1999] - [[fentonNonlinearWaveTheories1990|Fenton (1990)]] extends nonlinear wave theories with cnoidal and Stokes theories to fifth-order expansions, using Fourier techniques for enhanced computational accuracy. [@fentonNonlinearWaveTheories1990] ![schematic-of-problem](_Media/Stokes%20waves_arbitary%20order-20241225034827809.png) Both employ polynomial and trigonometric expansions for solving boundary conditions and streamline the application of nonlinear theories in various wave contexts.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#methodology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Key Findings",
    "content": "1. **Equation of Arbitrary Order Standing Waves**: The governing expressions for surface elevation and velocity components leverage Fourier series expansions or hyperbolic functions, depending on the wave height and wavelength regime: - Standing wave elevation, $\\eta(x, t)$, approximates multiple harmonics where coefficients stem from iterative numerical techniques. - Stokes coefficients for arbitrary-order expansions use factorial-based formulas for precise amplitude corrections. 2. **Numerical Accuracy**: - Both methods demonstrate high accuracy when wave heights and wavelengths align with their regimes of validity, but overlap regions where neither theory performs optimally exist. - The fifth-order Stokes expansion offers excellent performance for waves with moderate wavelengths, while cnoidal approximations excel for shallow water waves.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#key-findings",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Implications",
    "content": "The work advances computational methods to extend the precision of nonlinear wave predictions, enabling: - Safer and more cost-effective coastal structure designs. - Improved models for wave propagation over complex seabeds.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#implications",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Recommendations",
    "content": "One option is to use **mixed-order Stokes-cnoidal** expansions for transitional regimes and refine computational methods for boundary conditions in breaking wave scenarios.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#recommendations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Conclusion",
    "content": "Both approaches present robust solutions for their respective regimes but highlight the need for further refinement in transitional wavelength-depth conditions. ---",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Key Takeaways",
    "content": "- \ud83c\udf0a **Stokes Theory Excellence**: Best for deep water waves where wavelength-depth ratios are small. - \ud83c\udf0d **Cnoidal Theory for Shallow Water**: Ideal for long waves with large wavelength-depth ratios. - \ud83d\udd17 **Overlap Regions**: Transitional wave conditions (e.g., intermediate wavelength-depth ratios) challenge accuracy for both theories. - \ud83e\uddee **Numerical Methods' Power**: Fourier approximations enhance precision across nonlinear wave calculations. - \ud83d\udcc8 **Wave Breaking Limits**: Experiments suggest practical wave heights rarely approach theoretical maxima. - \ud83d\udc68 **Streamline Accuracy**: Velocity and pressure fields computed with Stokes and cnoidal methods align closely with Fourier-derived benchmarks. **One-line summary**: High-order Stokes and cnoidal theories provide accurate tools for nonlinear wave modeling, but computational refinements remain necessary for transitional regimes. ---",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#key-takeaways",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Arbitrary Order Standing Wave Equation",
    "content": "A general formula for Stokes coefficients of the \\(n\\)-th order wave, as described in the texts, resembles: ```c double stokes_coefficient(int n) { if (n == 1) return 1.0; double double_factorial = 1.0; for (int i = 1; i <= 2*n - 1; i += 2) double_factorial *= i; return double_factorial / (pow(2, n - 1) * tgamma(n + 1)); } ``` And for the surface elevation of Stokes waves: ```c double eta_stokes(double x, double a, double k, int order) { double eta = 0.0; double epsilon = k * a; for (int n = 1; n <= order; n++) { double c = stokes_coefficient(n); eta += c * pow(epsilon, n) * cos(n * k * x); } return eta * a; } ``` These computations involve harmonic terms, with coefficients determined iteratively or analytically, ensuring convergence and numerical stability.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#arbitrary-order-standing-wave-equation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - For dispersion relation in higher order: For the 0th...",
    "content": "For the 0th order: $$\\omega_0 = \\sqrt{gk},$$ Corrections for higher order gives $$\\frac{\\omega}{\\omega_0} = 1 + \\tfrac12\\epsilon^{2} + \\tfrac38\\epsilon^{4} + \\tfrac{5}{16}\\epsilon^{6} + \\tfrac{35}{128}\\epsilon^{8} +\\dots$$ * This is order `8`. - The trick here is how to calculate higher order coefficients. - Ref. - Stokes (1847), for the original perturbation approach [@stokes1847theory] - Longuet-Higgins [@longuet-higginsNewIntegralRelations1984] and other related works. - Lamb (1932): See Chapter 9 (especially art. 246\u2013250). Although Lamb typically writes out the celerity expansions $(c = \\omega / k)$, the frequency version is equivalent. [@Lamb1932] - **Most Importantly** $$c^2 = 1 + h^2 + \\frac{4}{3}h^4 + \\frac{17}{9}h^6 - \\frac{22}{9}h^8 + \\dots$$where $h = ak$ [[schwartzComputerExtensionAnalytic1974#^e59b15|page 11]] of [@schwartzComputerExtensionAnalytic1974].",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#for-dispersion-relation-in-higher-order",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - For dispersion relation in higher order: High\u2010order expansions of...",
    "content": "High\u2010order expansions of the Stokes dispersion relation up to ($\\epsilon^8$) have been verified numerically by Schwartz (1974). -> A good place for review is Annu. Rev. Fluid Mech. by L. W. Schwartz and J. D. Fenton [@schwartzStronglyNonlinearWaves1982] -> The code at [@sanjayComphylabStandingnonlinearwavesStanding2024] implements the above formulation for calculating the dispersion relation as a function of $ak$. It also uses the initial condition mentioned at the top of this document as the initial condition for the direct numerical simulations. ![[Stokes waves_arbitary order-20250125232439287.png]] ---",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#for-dispersion-relation-in-higher-order",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The role of viscosity on drop impact forces on non-wetting surfaces: From Raindrops to Inkjet Printing: When a liquid...",
    "content": "When a liquid drop hits a surface, the impact creates fascinating fluid dynamics that are crucial for applications ranging from inkjet printing to agricultural sprays. In this work, we uncover how a liquid's viscosity dramatically affects the forces generated during these impacts. Let's explore the key findings. ![[_Media/JFM-viscous-drop-impact-blog-1740211822831.png]] > [!tldr] TL;DR > Viscosity alters the forces a liquid drop exerts when it strikes a non-wetting surface, shifting the balance from inertia-dominated (like water) to enhanced viscous effects (like honey). Two force peaks arise: one at the initial impact and another tied to the Worthington jet just before bounce. Dimensionless numbers (Weber and Ohnesorge) govern these regimes, showing why higher-viscosity drops can yield unexpectedly large forces.",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-role-of-viscosity-on-drop-impact-forces-on-non-wetting-surfaces-from-raindrops-to-inkjet-printing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The role of viscosity on drop impact forces on non-wetting surfaces: From Raindrops to Inkjet Printing: Summary",
    "content": "The findings unify scaling laws across viscosities, guiding applications in printing, agriculture, and beyond, and pointing to future inquiries on soft surfaces and non-Newtonian fluids. > [!summary] Podcast >",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-role-of-viscosity-on-drop-impact-forces-on-non-wetting-surfaces-from-raindrops-to-inkjet-printing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The Basics: What Happens When a Drop Hits a Surface?",
    "content": "> [!note] Key Point > On a non-wetting surface, a drop goes through distinct phases: impact, spreading, retracting, and sometimes bouncing off. During this process, the surface experiences varying forces that can now be precisely measured and predicted. The impact process reveals two distinct force peaks: 1. An initial peak when the drop first hits 2. A second peak just before the drop potentially bounces off What makes this especially interesting is how these forces change based on two key properties: - Weber number ($We = \\rho V_0^2D_0/\\gamma$): Measures the dimensionless kinetic energy of the impacting drop. - Ohnesorge number ($Oh = \\eta/\\sqrt{\\rho\\gamma D_0}$): Represents the dimensionless viscosity of the impacting drop.",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-basics-what-happens-when-a-drop-hits-a-surface",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The First Impact: A Tale of Two Regimes",
    "content": "> [!important] First Peak Findings > The study reveals that the first impact force follows distinctly different patterns depending on the liquid's viscosity: > - For low viscosity liquids (like water), the force mainly depends on inertia > - For high viscosity liquids (like honey), viscous effects create stronger forces than expected",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-first-impact-a-tale-of-two-regimes",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Low Viscosity Behavior",
    "content": "For liquids with low viscosity ($Oh < 0.1$), the first impact force ($F_1$) scales with the inertial force: $$ F_1 \\sim \\rho V_0^2D_0^2 $$ where $\\rho$ is density, $V_0$ is impact velocity, and $D_0$ is drop diameter. This relationship holds remarkably well for viscosities up to 100 times that of water!",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#low-viscosity-behavior",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - High Viscosity Surprises",
    "content": "When viscosity becomes significant ($Oh > 0.1$), the force increases beyond what inertia alone would predict: $$ F_1 \\sim \\rho V_0^2D_0^2\\sqrt{Oh} $$ This enhancement occurs because viscous forces resist the drop's deformation, leading to higher impact pressures.",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#high-viscosity-surprises",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The Second Peak: Worthington Jets and Bouncing",
    "content": "> [!note] Worthington Jet > The second force peak coincides with a fascinating phenomenon called a Worthington jet - a thin liquid column that can shoot upward just before the drop bounces off. The second peak reveals an intricate balance between different forces: - For low viscosity and high speed impacts: Force scales with inertia - For low speed impacts: Surface tension dominates - At a special condition ($We \\approx 9$, $Oh < 0.01$): A `singular` jet forms with surprisingly high forces ![[_Media/JFM-viscous-drop-impact-blog-1740211923766.png]]",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-second-peak-worthington-jets-and-bouncing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Practical Implications",
    "content": "> [!important] Applications > These findings have direct applications in: > - Inkjet printing: Controlling droplet behavior > - Agricultural sprays: Optimizing pesticide application > - Respiratory disease transmission: Understanding droplet impacts > - Industrial cooling: Enhancing heat transfer through controlled droplet impacts",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#practical-implications",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Future Research Directions",
    "content": "This work opens several interesting avenues for future investigation: - Unifying theories for maximum spread diameter across all viscosities - Understanding impact forces on soft or compliant surfaces - Extending findings to non-Newtonian fluids like polymer solutions",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#future-research-directions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Technical Significance",
    "content": "> [!note] For the technically inclined > The study provides a comprehensive framework for predicting impact forces through dimensionless numbers and scaling laws. For researchers working in this field, the paper presents new scaling laws that unify previous observations and provide a foundation for future work. The careful experimental validation combined with theoretical analysis makes this a significant contribution to our understanding of drop impact dynamics. > [!faq] Original Paper > Sanjay, V., Zhang, B., Lv, C., & Lohse, D. (2025). The role of viscosity on drop impact forces. Journal of Fluid Mechanics, 1004, A6. [Open Access](https://doi.org/10.1017/jfm.2024.982).",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#technical-significance",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Cover of J. Fluid Mech. vol 1004",
    "content": "![[_Media/JFM-viscous-drop-impact-blog-1740211513533.jpg]]",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#cover-of-j-fluid-mech-vol-1004",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Videos",
    "content": "--- > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Feb 22, 2025 > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab), [Blogs](https://blogs.comphy-lab.org)",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#videos",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Executive Summary",
    "content": "Arrowhead structures, nicknamed \"narwhals,\" were initially discovered as coherent patterns in elastoinertial turbulence (EIT) simulations. While these structures provided valuable insights into polymer-flow interactions $-$ they can be the pathway to explain elastoinertial turbulence $-$ recent research reveals they might be artifacts of 2D simulations that become unstable in realistic 3D flows. > [!abstract] Key Points Overview > - Coherent structures could explain the pathway to elastoinertial turbulence. > - Arrowhead (one such traveling wave coherent solution of viscoelastic channel flow) structures are unstable in 3D flows > - Lack of experimental validation. > - Numerical artifacts play significant role $-$ presence or lack of polymeric diffusion. > - Transient appearances may still influence flow dynamics.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#executive-summary",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Problem Statement",
    "content": "- **Central Issue:** The existence and significance of arrowhead structures in elastoinertial turbulence. - **Importance:** Understanding these structures could reveal fundamental mechanisms of polymer-flow interactions and turbulence development.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#problem-statement",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Historical note",
    "content": "The two Phys. Rev. Lett. outline the exact traveling wave solutions $-$ now commonly called arrowheads or narwhals. ![|750](_Media/Arrowheads-in-elastoinertial-turbulence-1740331019797.png) [J. Page, Y. Dubief & R. R. Kerswell, Phys. Rev. Lett., 125:15, 154501 (2020)](https://doi.org/10.1103/PhysRevLett.125.154501) ![](_Media/Arrowheads-in-elastoinertial-turbulence-1740331094800.png) [A. Morozov, Phys. Rev. Lett., 129:1, 017801 (2022)](https://doi.org/10.1103/PhysRevLett.129.017801)",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#historical-note",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Methodology",
    "content": "The research community has employed multiple approaches to study arrowhead structures: > [!method] Research Methods > - 2D and 3D numerical simulations > - Linear stability analysis > - Flow visualization experiments > - Polymer diffusion modeling",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#methodology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - What are arrowheads?: **Elastoinertial turbulence (EIT)**...",
    "content": "**Elastoinertial turbulence (EIT)** is a chaotic flow state in dilute polymer solutions that arises when fluid inertia and polymer elasticity jointly drive instabilities. In this regime, simulations have revealed distinctive **arrowhead-shaped coherent structures** (nicknamed \u201cnarwhal\u201d structures for their horn-like appearance). These are highly organized patterns embedded within the turbulence, consisting of a polymer stress distribution coupled with a vortical flow pattern. An arrowhead structure has * **Localized polymer stretch:** a thin sheet of highly stretched polymer (high elastic stress) forming a triangular, arrowhead-like region spanning from the near-wall area to the channel center (symmetric about the mid-plane). * **Flanking vortices:** a pair of counter-rotating vortices on either side of this polymer sheet.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#what-are-arrowheads",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - What are arrowheads?: These vortices pull...",
    "content": "These vortices pull fluid (and polymers) up from the walls toward the center, feeding and elongating the polymer-rich \u201chorn\u201d of the arrowhead. * **Coherent propagation:** the structure travels downstream as a **traveling wave**, maintaining its shape over time rather than dissipating like a random eddy.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#what-are-arrowheads",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Why do arrowheads form?: Arrowhead structures emerge...",
    "content": "Arrowhead structures emerge from a flow instability driven by polymer elasticity. At high Weissenberg number ($Wi$, dimensionless stress relaxation time $-$ high $Wi$ imply strong elastic effects) and moderate Reynolds number ($Re$), an otherwise laminar channel flow becomes unstable to disturbances at the channel center. This **center-mode instability** begins as a pattern of vortices and polymer stretch in the middle of the channel, which grows and nonlinearly saturates into the arrowhead form. Above a critical $Wi$, the flow spontaneously develops arrowhead patterns; at higher $Wi$, these patterns persist and can dominate as a stable wave. At sufficiently large $Wi$, the chaotic EIT can give way to a single steady arrowhead state, indicating that this coherent structure becomes a stable attractor when elasticity dominates. **Polymer\u2013flow coupling:** The self-sustaining nature of an arrowhead comes from a feedback loop between polymer stretching and fluid motion.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#why-do-arrowheads-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Why do arrowheads form?: The polymer\u2019s evolution...",
    "content": "The polymer\u2019s evolution equation captures this interplay: $$ \\frac{D \\mathbf{C}}{Dt} = \\mathbf{C}\\cdot(\\nabla \\mathbf{u})^T + (\\nabla \\mathbf{u})\\cdot \\mathbf{C} - \\frac{1}{Wi}(\\mathbf{C} - \\mathbf{I}) $$ where $C$ is the polymer conformation tensor. In an arrowhead, the vortex pair generates strong shear and extensional flow that continuously amplifies polymer stretch along its arms. Because relaxation is slow at high $Wi$, a persistent high-tension polymer zone forms instead of relaxing away. That stretched-polymer zone exerts elastic stress back on the fluid, reinforcing the vortices that created it. Thus the vortices and polymer sheet sustain each other: the flow keeps the polymers stretched, and the polymer tension keeps the flow organized in the arrowhead pattern.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#why-do-arrowheads-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Different types of arrowheads",
    "content": "![](_Media/Arrowheads-in-elastoinertial-turbulence-1740342415364.png) Fig. Different realizations of arrowheads. Figure taken from [Y. Dubief, J. Page, R. R. Kerswell, V. E. Terrapon & V. Steinberg, Phys. Rev. Fluids, 7:7, 073301 (2022)](https://arxiv.org/pdf/2006.06770)",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#different-types-of-arrowheads",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Why are arrowheads important?",
    "content": "Identifying arrowhead structures can be pivotal for understanding EIT. They are the viscoelastic analog of coherent structures in Newtonian turbulence (like near-wall streaks and rolls), providing a clear `skeleton` for the turbulence. This shows that EIT is not just random; it is built around repeatable polymer\u2013flow patterns. Arrowhead structures also showcase a new route to sustain turbulence: they show that **elastic forces can maintain complex flow structures even at Reynolds numbers where a Newtonian flow would stay laminar**. Finally, they offer a bridge between regimes, connecting purely elastic turbulence ($Re \u2248 0$) with elastoinertial turbulence at higher $Re$ with $Wi \\gg 1$.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#why-are-arrowheads-important",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Numerical vs. Experimental Evidence: Do Arrowheads Exist in 3D or in Reality?: A critical question...",
    "content": "A critical question is whether these arrowhead structures are present in **3D flows** and experiments, or if they are artifacts of idealized 2D simulations. It has been claimed \u2013 and largely supported by evidence \u2013 that a single arrowhead wave _disappears_ in fully 3D simulations and has never been observed in experiments. Recent studies confirm that in a 3D domain, an arrowhead (narwhal) state is **linearly unstable** and quickly breaks down into turbulence. Morozov and co-workers performed a linear stability analysis of the 2D travelling-wave solution and found it unstable to spanwise perturbations when embedded in a 3D domain ([M. Lellep, M. Linkmann & A. Morozov, Proc. Natl. Acad. Sci., 121:9, e2318851121 (2024)](https://doi.org/10.1073/pnas.2318851121)). In other words, _\u201cunlike 2D, in 3D the narwhal in a channel appears to become unstable, leading to chaotic flows\u201d_.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#numerical-vs-experimental-evidence-do-arrowheads-exist-in-3d-or-in-reality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Numerical vs. Experimental Evidence: Do Arrowheads Exist in 3D or in Reality?: This means that...",
    "content": "This means that a coherent arrowhead structure cannot persist as a steady state in a wide 3D channel; it inevitably triggers its own demise into disordered motion. Indeed, direct 3D simulations of EIT show the flow filled with multiscale, transient structures rather than a single arrowhead. The characteristic structures of 3D EIT are **sheet-like regions of high polymer stretch** and streamwise vortices (often aligned in the spanwise direction) $\u2013$ no long-lived arrowhead pattern is evident. Experimentally, too, **no** arrowhead or narwhal-shaped structures have been directly observed. Laboratory studies (using techniques like flow visualization or velocimetry in polymer solutions) report chaotic fluctuations and elastic \u201csheets\u201d of polymer stretch, but not a stable arrowhead wave. For example, experimental and high-Reynolds 3D DNS studies show polymers stretched in thin sheets inclined to the flow and emerging vortex tubes, with **no mention of a sustained arrowhead** structure.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#numerical-vs-experimental-evidence-do-arrowheads-exist-in-3d-or-in-reality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Numerical vs. Experimental Evidence: Do Arrowheads Exist in 3D or in Reality?: Recent research largely...",
    "content": "Recent research largely _supports_ these claims. The consensus is that the arrowhead/narwhal is a **2D artifact** in the sense that it cannot survive the spanwise degrees of freedom of a real 3D flow. Additionally, **no experimental evidence** of arrowheads has emerged, despite the intensive study of EIT in channels and pipes over the past decade \u2013 reinforcing the idea that such structures, if they form, are immediately disrupted in real flows. However, recent findings do _nuance_ this picture: even though a **stable** narwhal does not exist in 3D, researchers have noted that **transient** arrowhead-like patterns can _appear fleetingly_ within a 3D turbulent flow. For instance, simulations of low-Re viscoelastic turbulence sometimes display instantaneous polymer-stress contours resembling the arrowhead shape ([J. R. C. King, R. J. Poole, C. P. Fonte & S. J. Lind, arXiv:2501.09421 (2025)](https://arxiv.org/abs/2501.09421)).",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#numerical-vs-experimental-evidence-do-arrowheads-exist-in-3d-or-in-reality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Numerical vs. Experimental Evidence: Do Arrowheads Exist in 3D or in Reality?: Summary",
    "content": "These transient appearances suggest that the arrowhead solution still exists as an organizing saddle or ephemeral structure in phase space, even if it\u2019s not sustained. In summary, the latest evidence indicates that arrowhead/narwhal structures **do not persist** in fully 3D EIT or experiments \u2013 they are replaced by more complex chaotic dynamics \u2013 but they may manifest momentarily, hinting that they influence the flow as part of its underlying state space (rather than as an observable steady feature).",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#numerical-vs-experimental-evidence-do-arrowheads-exist-in-3d-or-in-reality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Role of Diffusion, Resolution, and Modeling Choices: Physical Feature or Numerical Artifact?: The formation and...",
    "content": "The formation and persistence of arrowhead structures are highly sensitive to modeling choices like polymer diffusion and domain dimensionality, raising the question of whether these structures are genuine physical features or numerical artifacts. **Polymer stress diffusion** in particular plays a pivotal role. In simulations of viscoelastic fluids (Oldroyd-B or FENE-P models), a small artificial diffusion term is often added to the polymer constitutive equations for numerical stability. Recent work showed that even an _infinitesimal_ polymer diffusion can qualitatively change the flow\u2019s stability characteristics. [M. Beneitez, J. Page, Y. Dubief & R. R. Kerswell, J. Fluid Mech., 981, A30 (2024)](https://doi.org/10.1017/jfm.2024.50) discovered a _polymer diffusive instability (PDI)_: with a nonzero diffusion, the laminar flow becomes linearly unstable, producing a small-scale traveling wave at the wall as the primary bifurcation.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#role-of-diffusion-resolution-and-modeling-choices-physical-feature-or-numerical-artifact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Role of Diffusion, Resolution, and Modeling Choices: Physical Feature or Numerical Artifact?: Notably, this instability...",
    "content": "Notably, this instability does _not_ exist when polymer diffusion is strictly zero \u2013 the base flow would be linearly stable in the absence of diffusion. The implication is that the arrowhead structure in 2D simulations can arise from the PDI \u2013 essentially a numerical artifact of including diffusion. The diffusive term \u201ctriggers\u201d a finite-amplitude arrowhead-like wave that would not naturally appear at that parameter set without diffusion. In reality, molecular diffusion of polymers is extremely small, so such an instability might never dominate the transition; the flow could bypass it via a subcritical route. Thus, one must be cautious: the beautiful arrowhead patterns seen in some simulations may owe their existence to an unphysically large diffusion or other numerical regularization. In that sense, they are partly a _numerical artifact_. **Numerical resolution** and dimensionality further affect arrowhead formation.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#role-of-diffusion-resolution-and-modeling-choices-physical-feature-or-numerical-artifact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Role of Diffusion, Resolution, and Modeling Choices: Physical Feature or Numerical Artifact?: Insufficient resolution can...",
    "content": "Insufficient resolution can introduce excessive numerical diffusion (smoothing out small scales), potentially _artificially stabilizing_ a large-scale structure like the arrowhead. Likewise, restricting the simulation to 2D (as was done in the initial arrowhead studies) removes the 3D disturbances that would break up the arrowhead. The 2D assumption is a strong modeling simplification that essentially _locks in_ the coherent structure. As [M. Lellep, M. Linkmann & A. Morozov, Proc. Natl. Acad. Sci., 121:9, e2318851121 (2024)](https://doi.org/10.1073/pnas.2318851121) note, one cannot draw reliable conclusions about EIT dynamics from strictly 2D simulations. In 2D, the narwhal is \u201cbenign\u201d and can remain as a steady state, but this is sustained only because the normal 3D instability modes are disallowed. In a fully resolved 3D simulation, that arrowhead state sits on a razor\u2019s edge \u2013 any slight spanwise perturbation will cause it to oscillate or breakdown.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#role-of-diffusion-resolution-and-modeling-choices-physical-feature-or-numerical-artifact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Role of Diffusion, Resolution, and Modeling Choices: Physical Feature or Numerical Artifact?: Thus, the arrowhead\u2019s...",
    "content": "Thus, the arrowhead\u2019s longevity in 2D is not reflective of physical reality; it\u2019s a consequence of an artificially constrained simulation. On the other hand, it\u2019s too strong to dismiss arrowheads entirely as a \u201cmere artifact.\u201d They are _mathematically legitimate_ nonlinear solutions of the viscoelastic flow equations (even if attained under special conditions) and they capture real physics \u2013 notably, a mechanism of polymer stretching and feedback. The consensus view is that arrowhead/narwhal structures are **embedded but unstable** features of the real system. They are \u201creal\u201d solutions, but one that the unconstrained system will only transiently visit. Diffusion and other numerical choices can exaggerate their prominence. In summary, high-fidelity simulations indicate that arrowheads do **not** represent a permanent physical flow pattern; rather, they are a byproduct of low-dimensional or diffusive modeling that nonetheless offer insight into the polymer\u2013flow interactions in EIT.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#role-of-diffusion-resolution-and-modeling-choices-physical-feature-or-numerical-artifact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Conclusion: Recent research converges...",
    "content": "Recent research converges on a nuanced view of arrowhead (narwhal) structures in EIT. They were a landmark discovery as a coherent viscoelastic wave, and they have deepened our insight into polymer\u2013flow interactions. However, both simulations and theory now indicate that they are **transient players** in fully developed 3D turbulence rather than the primary architects of it. In fact, the energy transfer analysis between flow and polymer reveals that both chaotic regimes maintain through the same near-wall mechanism, independent of the weak arrowhead structure. These findings indicate that the arrowhead represents a passive flow structure, detached from the self-sustaining mechanics of elastic turbulence inertia (EIT) ([M. Beneitez, J. Page, Y. Dubief & R. R. Kerswell, J. Fluid Mech., 981, A30 (2024)](https://doi.org/10.1017/jfm.2024.50)).",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Conclusion: The community\u2019s focus...",
    "content": "The community\u2019s focus has shifted to how such structures populate the state space and trigger transitions, rather than expecting them to appear as steady patterns in experiments. Ongoing work continues to unravel the multi-stage transition to elastic and elasto-inertial turbulence $\u2013$ with arrowhead/narwhal waves serving as a valuable piece of the puzzle, albeit one with clear limitations. This critical understanding ensures that we appreciate the arrowhead structures for what they are: insightful and pedagogical solutions that illuminate EIT\u2019s mechanics, but ultimately unstable in the wild chaos of real 3D turbulence. --- > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Feb 24, 2025 > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab), [Blogs](https://blogs.comphy-lab.org)",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "reset_install_requirements.sh | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # tested on MacOS only.",
    "url": "https://comphy-lab.org/documentationWeb/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Test documentation: Lid driven cavity using dye injection: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue. # modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk # Check if --hard flag is passed HARD_RESET = \\f alse if [[ \" \\$ 1\" == \"--hard\" ]]; then HARD_RESET = \\t rue fi # Function to install basilisk install_basilisk() { darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make -k make } # Remove project config always rm -rf .project_config # Check if basilisk needs to be installed if [[ \" \\$ HARD_RESET\" == true ]] || [[ ! -d \"basilisk\" ]]; then echo \"Installing basilisk...\" rm -rf basilisk install_basilisk else echo \"Using existing basilisk installation...\" cd basilisk/src fi # Setup environment variables echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config # Check if qcc is working properly echo \"\\nChecking qcc installation...\" if ! qcc --version > /dev/null 2 >& 1 ; then echo \"\\033[0;31mError: qcc is not working properly.\\033[0m\" echo \"Please ensure you have Xcode Command Line Tools installed.\" echo \"You can install them by running: xcode-select --install\" echo \"For more details, visit: http://basilisk.fr/src/INSTALL\" exit 1 else echo \"\\033[0;32mqcc is properly installed.\\033[0m\" qcc --version fi",
    "url": "https://comphy-lab.org/documentationWeb/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Test documentation: Lid driven cavity using dye injection - Code Example: #!/bin/zsh# tested on...",
    "content": "#!/bin/zsh# tested on MacOS only.",
    "url": "https://comphy-lab.org/documentationWeb/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Test documentation: Lid driven cavity using dye injection - Code Example: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue.# modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basilisk# Check if --hard flag is passedHARD_RESET=\\falseif[[\"\\$1\"==\"--hard\"]];thenHARD_RESET=\\truefi# Function to install basiliskinstall_basilisk(){darcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake-kmake}# Remove project config alwaysrm-rf.project_config# Check if basilisk needs to be installedif[[\"\\$HARD_RESET\"==true]]||[[!-d\"basilisk\"]];thenecho\"Installing basilisk...\"rm-rfbasiliskinstall_basiliskelseecho\"Using existing basilisk installation...\"cdbasilisk/srcfi# Setup environment variablesecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config# Check if qcc is working properlyecho\"\\nChecking qcc installation...\"if!qcc--version>/dev/null2>&1;thenecho\"\\033[0;31mError: qcc is not working properly.\\033[0m\"echo\"Please ensure you have Xcode Command Line Tools installed.\"echo\"You can install them by running: xcode-select --install\"echo\"For more details, visit: http://basilisk.fr/src/INSTALL\"exit1elseecho\"\\033[0;32mqcc is properly installed.\\033[0m\"qcc--versionfi",
    "url": "https://comphy-lab.org/documentationWeb/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Test documentation: Lid...",
    "content": "Test documentation: Lid driven cavity using dye injection This repository contains the computational framework and tools for multiphase fluid dynamics simulations based on the Basilisk C framework. The codebase specializes in the simulation and analysis of lid driven cavity flow with dye injection. Documentation The full documentation for this project is available at comphy-lab.org/documentationWeb/ . This website contains detailed explanations of the code, examples, and usage instructions. Overview The codebase implements a classical lid driven cavity flow problem with dye injection using the Basilisk CFD library with custom implementations for specific dye injection including.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Repository Structure basilisk/src/...",
    "content": "Repository Structure basilisk/src/ - Core Basilisk CFD library (reference only, do not modify) simulationCases/ - Test cases for simulation LidDrivenCavity-Newtonian-dyeInjection.c - Lid-driven cavity with dye injection src-local/ - Custom header files extending Basilisk functionality dye-injection.h - Dye injection for flow visualization postProcess/ - Project-specific post-processing tools LidDrivenCavity-Newtonian-dyeInjection.ipynb - Jupyter notebook for analysis and visualization LidDrivenCavity-Newtonian-dyeInjection.py - Python script for post-processing getData-LidDriven.c - Data extraction utility src-local/ Directory The src-local/ directory contains custom header files that extend the base Basilisk functionality: dye-injection.h : Implements a circular tracer (dye) injection for flow visualization with: Configurable injection time and position Circular dye region with adjustable radius Integration with Basilisk\u2019s tracer module for advection postProcess/ Directory The postProcess/ directory provides tools for analyzing and visualizing simulation results: LidDrivenCavity-Newtonian-dyeInjection.ipynb : Jupyter notebook that: Provides interactive analysis of simulation results Visualizes dye transport in the cavity Contains both code and documentation in a single document Allows for reproducible analysis workflow LidDrivenCavity-Newtonian-dyeInjection.py : Python script for generating visualizations that: Processes simulation timesteps in parallel Creates two-panel plots showing dye concentration and velocity magnitude Adds streamlines to visualize flow patterns Uses \u2018getData-LidDriven\u2019 utility to extract field data getData-LidDriven.c : C utility that extracts and processes numerical data from simulation output files simulationCases/ Directory The simulationCases/ directory contains simulation configurations: LidDrivenCavity-Newtonian-dyeInjection.c : Main simulation case that implements: Classical lid-driven cavity flow for a Newtonian fluid Configurable Reynolds number (default: Re = 1) Dye injection in the upper center of the cavity at t=0.05 Adaptive grid with level 8 refinement Proper boundary conditions for the moving lid and no-slip walls Regular snapshot generation for visualization Getting Started Prerequisites Basilisk C installed ( Installation instructions ) C compiler (gcc recommended) Make build system Scientific visualization tools (optional: ParaView, Gnuplot, etc.) Installation Clone this repository: git clone https://github.com/username/comphy-lab.git cd comphy-lab Make sure Basilisk is properly installed and the BASILISK environment variable is set.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Compile a test...",
    "content": "Compile a test case to verify the setup: cd simulationCases make test_name.tst Usage Compiling Simulation Files Basic compilation: qcc -autolink file.c -o executable -lm Compilation with custom headers: qcc -I $PWD /src-local -autolink file.c -o executable -lm Running Simulations Run a compiled executable: ./executable Execute a specific test case: cd simulationCases && make test_name.tst Post-Processing The postProcess/ directory contains tools for post-processing simulation results: Visualization Generation : Automated generation of two-panel plots showing: Dye concentration with coolwarm colormap Velocity magnitude with viridis colormap Streamlines to visualize flow patterns Data Extraction : Utility to extract numerical data from simulation output files Parallel Processing : Multi-core processing of simulation timesteps for efficient visualization LaTeX Integration : Formatted plots with mathematical notation using LaTeX Code Style Guidelines Indentation : 2 spaces (no tabs) Line length : 80 characters maximum Documentation : Use markdown in comments starting with /** .",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Do not use...",
    "content": "Do not use * in comments.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Spacing : Space...",
    "content": "Spacing : Space after commas, spaces around operators (+, -) Files : Core functionality in .h headers, tests in .c files Naming : Snake_case for variables, camelCase for functions Error handling : Return values with stderr messages Example Here\u2019s the actual lid-driven cavity flow with dye injection implementation: #include \"navier-stokes/centered.h\" #include \"dye-injection.h\" // Constants #define LEVEL 8 // Grid refinement level #define MAXDT ( 1e-4 ) // Maximum timestep // Global variables int imax = 1e5 ; // Maximum iterations double tmax = 1.0 ; // Maximum simulation time double tsnap = 0.01 ; // Time interval between snapshots double end = 2.0 ; // End time for simulation // Scalar field for convergence check scalar un []; // Previous x-velocity const face vector muv [] = { 1.0 , 1.0 }; // Face-centered viscosity field /** ## Boundary Conditions */ // Top moving wall (lid) u . t [ top ] = dirichlet ( 1 ); // Other no-slip boundaries u . t [ bottom ] = dirichlet ( 0 ); u . t [ left ] = dirichlet ( 0 ); u . t [ right ] = dirichlet ( 0 ); /** ## Initialization */ event init ( t = 0 ) { // Set constant viscosity for Newtonian fluid mu = muv ; // Initialize velocity field foreach () { u . x [] = 0 ; u . y [] = 0 ; un [] = 0 ; } dump ( file = \"start\" ); } /** ## Snapshot Generation Save snapshots at regular intervals for flow visualization */ event writingFiles ( t = 0. ; t += tsnap ; t < tmax + tsnap ) { char filename [ 100 ]; sprintf ( filename , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = filename ); } int main () { // Initialize grid and parameters init_grid ( 1 << LEVEL ); L0 = 1.0 ; origin (- 0.5 , - 0.5 ); DT = MAXDT ; TOLERANCE = 1e-5 ; CFL = 0.25 ; // Store current velocity for convergence check foreach () { un [] = u . x []; } // dye injection parameters tInjection = 0.05 ; // Inject the dye after flow is established xInjection = 0.00 ; // X position (center of cavity) yInjection = 0.40 ; // Y position (upper center of cavity) // Create a folder for simulation snapshots char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Run simulation run (); } Contributing Fork the repository Create your feature branch ( git checkout -b feature/amazing-feature ) Commit your changes ( git commit -m 'Add some amazing feature' ) Push to the branch ( git push origin feature/amazing-feature ) Open a Pull Request Reporting Issues and Feature Requests We use GitHub Issues to track bugs, feature requests, and example requests for this repository.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: When creating an...",
    "content": "When creating an issue, please select the appropriate template to help us address your needs efficiently. Issue Templates Bug Report: Report here For problems with installation, compilation, or running code.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Please include: Detailed...",
    "content": "Please include: Detailed description of the issue Your environment (OS, compiler version) Steps to reproduce Expected vs. actual behavior Error messages and logs Code snippets or files that demonstrate the issue Feature/Topic Request: Report here - For requesting specific topics or functionality - New examples or tutorials - Additional functionality in the codebase - Improvements to existing materials Example Request: Report here - For requesting specific examples that demonstrate: - Particular Basilisk features - Solutions to common problems - Implementation of specific physics or numerical methods General Question: Report here - For any other questions How to Create an Issue Go to the \u201cIssues\u201d tab in the GitHub repository Click the \u201cNew Issue\u201d button Select the appropriate template from the options Fill in the required information according to the template Add relevant labels if available Submit the issue License This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "Acknowledgments S. Popinet & collaborators, Basilisk C, http://basilisk.fr (Last accessed: June 2025) (2013-2025) Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/LidDrivenCavity-Newtonian-dyeInjection.ipynb postProcess/LidDrivenCavity-Newtonian-dyeInjection.py postProcess/getData-LidDriven.c simulationCases simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c simulationCases/Makefile src-local src-local/dye-injection.h",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "gitclone https://github.com/username/comphy-lab.gitcdcomphy-lab",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection - C/C++ Code: C/C++ Code",
    "content": "#include\"navier-stokes/centered.h\"#include\"dye-injection.h\"// Constants#define LEVEL8// Grid refinement level#define MAXDT(1e-4)// Maximum timestep// Global variablesintimax=1e5;// Maximum iterationsdoubletmax=1.0;// Maximum simulation timedoubletsnap=0.01;// Time interval between snapshotsdoubleend=2.0;// End time for simulation// Scalar field for convergence checkscalar un[];// Previous x-velocityconstface vector muv[]={1.0,1.0};// Face-centered viscosity field/**## Boundary Conditions*/// Top moving wall (lid)u.t[top]=dirichlet(1);// Other no-slip boundariesu.t[bottom]=dirichlet(0);u.t[left]=dirichlet(0);u.t[right]=dirichlet(0);/**## Initialization*/event init(t=0){// Set constant viscosity for Newtonian fluidmu=muv;// Initialize velocity fieldforeach(){u.x[]=0;u.y[]=0;un[]=0;}dump(file=\"start\");}/**## Snapshot GenerationSave snapshots at regular intervals for flow visualization*/event writingFiles(t=0.;t+=tsnap;t<tmax+tsnap){charfilename[100];sprintf(filename,\"intermediate/snapshot-%5.4f\",t);dump(file=filename);}intmain(){// Initialize grid and parametersinit_grid(1<<LEVEL);L0=1.0;origin(-0.5,-0.5);DT=MAXDT;TOLERANCE=1e-5;CFL=0.25;// Store current velocity for convergence checkforeach(){un[]=u.x[];}// dye injection parameterstInjection=0.05;// Inject the dye after flow is establishedxInjection=0.00;// X position (center of cavity)yInjection=0.40;// Y position (upper center of cavity)// Create a folder for simulation snapshotscharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Run simulationrun();}",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases LidDrivenCavity-Newtonian-dyeInjection.c This simulation models a lid-driven cavity flow for a Newtonian fluid with constant viscosity and includes dye inject... Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje...",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Test documentation: Lid driven cavity using dye injection",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) ifeq ( \\$ ( strip \\$ ( BASILISK )) , ) \\$ ( error \"BASILISK not set in .project_config\" ) endif CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local .PHONY: fix-permissions # Fix permissions for runtest script fix-permissions: @chmod +x \\$ ( BASILISK ) /src/runtest # Make all test targets depend on fix-permissions %.tst: fix-permissions include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)ifeq(\\$(strip\\$(BASILISK)),)\\$(error\"BASILISK not set in .project_config\")endifCFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-local.PHONY:fix-permissions# Fix permissions for runtest scriptfix-permissions:@chmod+x\\$(BASILISK)/src/runtest# Make all test targets depend on fix-permissions%.tst:fix-permissionsinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c See raw file Lid-Driven Cavity Flow of a Newtonian Fluid with dye Injection This simulation models a lid-driven cavity flow for a Newtonian fluid with constant viscosity and includes dye injection for flow visualization. This extends the classic benchmark case with a passive tracer to visualize flow patterns.",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: Parameters Reynolds number:...",
    "content": "Parameters Reynolds number: \\(Re = \\frac{\\rho U L}{\\mu} = \\frac{1}{\\mu} \\quad \\text{(with } \\rho=1, U=1, L=1\\text{)}\\) We use \\(\\mu = 1.0\\) by default (Re = 1) dye injection at t=0.05 in the upper center of the cavity #include \"navier-stokes/centered.h\" #include \"dye-injection.h\" // Constants #define LEVEL 8 // Grid refinement level #define MAXDT ( 1e-4 ) // Maximum timestep // Global variables int imax = 1e5 ; // Maximum iterations double tmax = 1.0 ; // Maximum simulation time double tsnap = 0.01 ; // Time interval between snapshots double end = 2.0 ; // End time for simulation // Scalar field for convergence check scalar un []; // Previous x-velocity const face vector muv [] = { 1.0 , 1.0 }; // Face-centered viscosity field Boundary Conditions // Top moving wall (lid) u . t [ top ] = dirichlet ( 1 ); // Other no-slip boundaries u . t [ bottom ] = dirichlet ( 0 ); u . t [ left ] = dirichlet ( 0 ); u . t [ right ] = dirichlet ( 0 ); // uf.n[left] = 0; // uf.n[right] = 0; // uf.n[top] = 0; // uf.n[bottom] = 0; Initialization event init ( t = 0 ) { // Set constant viscosity for Newtonian fluid mu = muv ; // Initialize velocity field foreach () { u . x [] = 0 ; u . y [] = 0 ; un [] = 0 ; } dump ( file = \"start\" ); } Snapshot Generation Save snapshots at regular intervals for flow visualization event writingFiles ( t = 0. ; t += tsnap ; t < tmax + tsnap ) { char filename [ 100 ]; sprintf ( filename , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = filename ); } Logs simulation progress and convergence details.",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: On each iteration,...",
    "content": "On each iteration, this event updates the stored x-velocity field for convergence checking and logs the current iteration number, timestep (dt), simulation time (t), and the convergence error (difference between the current and previous x-velocity fields) to the log file. event logfile ( i ++; i <= imax ) { foreach () { un [] = u . x []; } fprintf ( ferr , \"i = %d : dt = %g , t = %g , err = %g\\n \" , i , dt , t , change ( u . x , un )); } Outputs final simulation results for visualization. When the simulation reaches the end time, this event outputs the final state of simulation fields to a file named \u201cresults\u201d for post-processing and visualization. event end ( t = end ) { // Output fields in a format suitable for visualization dump ( file = \"results\" ); } Entry point for the lid-driven cavity flow simulation with dye injection.",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: Initializes the computational...",
    "content": "Initializes the computational grid and simulation parameters (domain size, timestep, tolerance, and CFL condition), and stores the initial velocity field for convergence monitoring.",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: Configures dye injection...",
    "content": "Configures dye injection settings by defining the injection time and location, creates a directory for saving intermediate simulation snapshots, and triggers the simulation run. @return int Exit status code (typically 0 upon successful completion). int main () { // Initialize grid and parameters init_grid ( 1 << LEVEL ); L0 = 1.0 ; origin (- 0.5 , - 0.5 ); DT = MAXDT ; TOLERANCE = 1e-5 ; CFL = 0.25 ; // Store current velocity for convergence check foreach () { un [] = u . x []; } // dye injection parameters tInjection = 0.05 ; // Inject the dye after flow is established xInjection = 0.00 ; // X position (center of cavity) yInjection = 0.40 ; // Y position (center of cavity) // Create a folder named intermediate where all the simulation snapshots are stored. char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Run simulation run (); }",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - C/C++ Code",
    "content": "#include\"navier-stokes/centered.h\"#include\"dye-injection.h\"// Constants#define LEVEL8// Grid refinement level#define MAXDT(1e-4)// Maximum timestep// Global variablesintimax=1e5;// Maximum iterationsdoubletmax=1.0;// Maximum simulation timedoubletsnap=0.01;// Time interval between snapshotsdoubleend=2.0;// End time for simulation// Scalar field for convergence checkscalar un[];// Previous x-velocityconstface vector muv[]={1.0,1.0};// Face-centered viscosity field",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "// Top moving wall (lid)u.t[top]=dirichlet(1);// Other no-slip boundariesu.t[bottom]=dirichlet(0);u.t[left]=dirichlet(0);u.t[right]=dirichlet(0);// uf.n[left]   = 0;// uf.n[right]  = 0;// uf.n[top]    = 0;// uf.n[bottom] = 0;",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "event init(t=0){// Set constant viscosity for Newtonian fluidmu=muv;// Initialize velocity fieldforeach(){u.x[]=0;u.y[]=0;un[]=0;}dump(file=\"start\");}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "event writingFiles(t=0.;t+=tsnap;t<tmax+tsnap){charfilename[100];sprintf(filename,\"intermediate/snapshot-%5.4f\",t);dump(file=filename);}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "event logfile(i++;i<=imax){foreach(){un[]=u.x[];}fprintf(ferr,\"i =%d: dt =%g, t =%g, err =%g\\n\",i,dt,t,change(u.x,un));}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "event end(t=end){// Output fields in a format suitable for visualizationdump(file=\"results\");}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example: intmain(){// Initialize grid...",
    "content": "intmain(){// Initialize grid and parametersinit_grid(1<<LEVEL);L0=1.0;origin(-0.5,-0.5);DT=MAXDT;TOLERANCE=1e-5;CFL=0.25;// Store current velocity for convergence checkforeach(){un[]=u.x[];}// dye injection parameterstInjection=0.05;// Inject the dye after flow is establishedxInjection=0.00;// X position (center of cavity)yInjection=0.40;// Y position (center of cavity)// Create a folder named intermediate where all the simulation snapshots are stored.charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Run simulationrun();}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData-LidDriven.c Vatsal Sanjay Email: vatsalsy@comphy-lab.org CoMPhy Lab Physics of Fluids Department Last updated: Mar 8, 2025 ~~~c LidDrivenCavity-Newtonian-dyeInjection.ipynb Import all relevant libraries. LidDrivenCavity-Newtonian-dyeInjection.py Rtemp, Ztemp, Ttemp, veltemp, Psitemp = [],[],[],[], [] for n1 in range(len(temp2)): temp3 = temp2[n1].split(' ') if ...",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Import Statements",
    "content": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py See raw file import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter from mpl_toolkits.axes_grid1 import make_axes_locatable import argparse # Add at top with other imports import multiprocessing as mp from functools import partial matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingfield(filename, zmin, zmax, rmin, rmax, nr): Extract simulation field data from a simulation file. This function executes the external program \u201cgetData-LidDriven\u201d with the given simulation file and boundary parameters to extract numerical data for axial and radial coordinates, temperature, velocity, and stream function.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: The output is...",
    "content": "The output is parsed into NumPy arrays, reshaped to a (nz, nr) grid based on the number of radial grid points (nr), rotated 90\u00b0 counterclockwise, and flipped vertically to ensure the correct orientation for further processing. It returns the processed field arrays along with the total number of axial grid points (nz). Args: filename: Path to the simulation data file. zmin: Minimum axial coordinate. zmax: Maximum axial coordinate. rmin: Minimum radial coordinate. rmax: Maximum radial coordinate. nr: Number of grid points in the radial direction.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Returns: tuple: A...",
    "content": "Returns: tuple: A tuple containing: - R (numpy.ndarray): 2D array of radial coordinate values. - Z (numpy.ndarray): 2D array of axial coordinate values. - T (numpy.ndarray): 2D array of temperature values. - vel (numpy.ndarray): 2D array of velocity values. - psi (numpy.ndarray): 2D array of stream function values. - nz (int): Number of grid points in the axial direction. exe = [ \"./getData-LidDriven\" , filename, str (zmin), str (rmin), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, Ttemp, veltemp, Psitemp = [],[],[],[], [] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) Ttemp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) Psitemp.append( float (temp3[ 4 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) T = np.asarray(Ttemp) vel = np.asarray(veltemp) psi = np.asarray(Psitemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) T.resize((nz, nr)) vel.resize((nz, nr)) psi.resize((nz, nr)) # rotate the arrays by 90 degrees R = np.rot90(R, k = 1 ) Z = np.rot90(Z, k = 1 ) T = np.rot90(T, k = 1 ) vel = np.rot90(vel, k = 1 ) psi = np.rot90(psi, k = 1 ) # flip the array R = np.flip(R, axis = 0 ) Z = np.flip(Z, axis = 0 ) T = np.flip(T, axis = 0 ) vel = np.flip(vel, axis = 0 ) psi = np.flip(psi, axis = 0 ) return R, Z, T, vel, psi, nz # ---------------------------------------------------------------------------------------------------------------------- def process_timestep(ti, caseToProcess, folder, tsnap, GridsPerR, rmin, rmax, zmin, zmax, lw): Generates and saves a two-panel plot for a simulation timestep.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Calculates the simulation...",
    "content": "Calculates the simulation time using the timestep index and a time increment, then retrieves field data from an intermediate snapshot file. Creates a figure with two subplots\u2014one displaying the dye color (with a coolwarm heat map) and the other showing velocity magnitude (with a viridis heat map). Both panels include domain boundaries and streamlines for the stream function.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Function Definition",
    "content": "If the snapshot file is missing or the output image already exists, the function prints a warning and exits. t = tsnap * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" # Check if the file exists if not os.path.exists(place): print ( f\" { place } File not found!\" ) return # if name exits, return if os.path.exists(name): print ( f\" { name } already exists!\" ) return # if folder does not exist, create it if not os.path.exists(folder): os.makedirs(folder) # Calculate number of grid points in r-direction based on domain size nr = int (GridsPerR * rmax) # Extract field data from the simulation file R, Z, T, vel, psi, nz = gettingfield(place, zmin, zmax, rmin, rmax, nr) # Get actual domain bounds from the data zminp, zmaxp, rminp, rmaxp = Z. min (), Z. max (), R. min (), R. max () # Set up the figure with two subplots AxesLabel, TickLabel = 50 , 20 fig, (ax1, ax2) = plt.subplots( 1 , 2 , figsize = ( 24 , 11 ), constrained_layout = True ) # First subplot - Rate of Strain Tensor (D2) # Draw domain boundaries ax1.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax1.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax1.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax1.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Plot the dye with a heat map cntrl1 = ax1.pcolormesh(Z, R, T, cmap = \"coolwarm\" , edgecolor = 'face' , vmax = 1 , vmin = 0 ) # Add streamlines using the stream function ax1.contour(Z, R, psi, 20 , colors = 'black' , linewidths = 2 ) # Configure the first subplot ax1.set_aspect( 'equal' ) ax1.set_xlim(rmin, rmax) ax1.set_ylim(zmin, zmax) ax1.set_title( r'Rate of Strain Tensor' , fontsize = TickLabel) # Add colorbar to the first subplot divider1 = make_axes_locatable(ax1) cax1 = divider1.append_axes( \"right\" , size = \"5%\" , pad = 0.1 ) c1 = plt.colorbar(cntrl1, cax = cax1) c1.set_label( r' $ log_ {10} ( \\| \\m athcal{D}_{ij} \\| ) $ ' , fontsize = TickLabel, labelpad = 5 ) c1.ax.tick_params(labelsize = TickLabel) # Second subplot - Velocity Magnitude # Draw domain boundaries ax2.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax2.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax2.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax2.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Plot velocity magnitude with viridis colormap cntrl2 = ax2.pcolormesh(Z, R, vel, cmap = \"viridis\" , edgecolor = 'face' , vmax = 1 , vmin = 0 ) # Add streamlines using the stream function ax2.contour(Z, R, psi, 20 , colors = 'black' , linewidths = 2 ) # Configure the second subplot ax2.set_aspect( 'equal' ) ax2.set_xlim(rmin, rmax) ax2.set_ylim(zmin, zmax) ax2.set_title( r'Velocity Magnitude' , fontsize = TickLabel) # Add colorbar to the second subplot divider2 = make_axes_locatable(ax2) cax2 = divider2.append_axes( \"right\" , size = \"5%\" , pad = 0.1 ) c2 = plt.colorbar(cntrl2, cax = cax2) c2.set_label( r'Velocity' , fontsize = TickLabel, labelpad = 5 ) c2.ax.tick_params(labelsize = TickLabel) # Turn off axes for cleaner visualization ax1.axis( 'off' ) ax2.axis( 'off' ) plt.savefig(name, bbox_inches = 'tight' ) # Display the figure plt.close() def main(): # Get number of CPUs from command line argument, or use all available Parses command-line arguments and processes simulation timesteps in parallel.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Reads simulation and...",
    "content": "Reads simulation and processing parameters from the command line, prepares the output directory, and uses a multiprocessing pool to generate visualizations for each simulation timestep concurrently. parser = argparse.ArgumentParser() parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use' ) parser.add_argument( '--nGFS' , type = int , default = 150 , help = 'Number of restart files to process' ) parser.add_argument( '--GridsPerR' , type = int , default = 512 , help = 'Number of grids per R' ) parser.add_argument( '--ZMAX' , type = float , default = 0.5 , help = 'Maximum Z value' ) parser.add_argument( '--RMAX' , type = float , default = 0.5 , help = 'Maximum R value' ) parser.add_argument( '--ZMIN' , type = float , default =- 0.5 , help = 'Minimum Z value' ) parser.add_argument( '--RMIN' , type = float , default =- 0.5 , help = 'Minimum R value' ) parser.add_argument( '--tsnap' , type = float , default = 0.01 , help = 'Time snap' ) parser.add_argument( '--caseToProcess' , type = str , default = '../simulationCases/LidDrivenCavity-Newtonian-dyeInjection' , help = 'Case to process' ) parser.add_argument( '--folderToSave' , type = str , default = 'LidDrivenCavity-Newtonian-dyeInjection' , help = 'Folder to save' ) args = parser.parse_args() num_processes = args.CPUs nGFS = args.nGFS tsnap = args.tsnap ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN RMIN = args.RMIN rmin, rmax, zmin, zmax = [RMIN, RMAX, ZMIN, ZMAX] GridsPerR = args.GridsPerR lw = 2 folder = args.folderToSave caseToProcess = args.caseToProcess if not os.path.isdir(folder): os.makedirs(folder) # Create a pool of worker processes with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, caseToProcess = caseToProcess, folder = folder, tsnap = tsnap, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw) # Map the process_func to all timesteps pool. map (process_func, range (nGFS)) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterfrommpl_toolkits.axes_grid1importmake_axes_locatableimportargparse# Add at top with other importsimportmultiprocessingasmpfromfunctoolsimportpartialmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingfield(filename, zmin, zmax, rmin, rmax, nr):",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "exe=[\"./getData-LidDriven\", filename,str(zmin),str(rmin),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, Ttemp, veltemp, Psitemp=[],[],[],[], []forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))Ttemp.append(float(temp3[2]))veltemp.append(float(temp3[3]))Psitemp.append(float(temp3[4]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)T=np.asarray(Ttemp)vel=np.asarray(veltemp)psi=np.asarray(Psitemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))T.resize((nz, nr))vel.resize((nz, nr))psi.resize((nz, nr))# rotate the arrays by 90 degreesR=np.rot90(R, k=1)Z=np.rot90(Z, k=1)T=np.rot90(T, k=1)vel=np.rot90(vel, k=1)psi=np.rot90(psi, k=1)# flip the arrayR=np.flip(R, axis=0)Z=np.flip(Z, axis=0)T=np.flip(T, axis=0)vel=np.flip(vel, axis=0)psi=np.flip(psi, axis=0)returnR, Z, T, vel, psi, nz# ----------------------------------------------------------------------------------------------------------------------defprocess_timestep(ti, caseToProcess, folder, tsnap, GridsPerR, rmin, rmax, zmin, zmax, lw):",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "t=tsnap*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"# Check if the file existsifnotos.path.exists(place):print(f\"{place}File not found!\")return# if name exits, returnifos.path.exists(name):print(f\"{name}already exists!\")return# if folder does not exist, create itifnotos.path.exists(folder):os.makedirs(folder)# Calculate number of grid points in r-direction based on domain sizenr=int(GridsPerR*rmax)# Extract field data from the simulation fileR, Z, T, vel, psi, nz=gettingfield(place, zmin, zmax, rmin, rmax, nr)# Get actual domain bounds from the datazminp, zmaxp, rminp, rmaxp=Z.min(), Z.max(), R.min(), R.max()# Set up the figure with two subplotsAxesLabel, TickLabel=50,20fig, (ax1, ax2)=plt.subplots(1,2, figsize=(24,11), constrained_layout=True)# First subplot - Rate of Strain Tensor (D2)# Draw domain boundariesax1.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax1.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax1.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax1.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Plot the dye with a heat mapcntrl1=ax1.pcolormesh(Z, R, T, cmap=\"coolwarm\", edgecolor='face', vmax=1, vmin=0)# Add streamlines using the stream functionax1.contour(Z, R, psi,20, colors='black', linewidths=2)# Configure the first subplotax1.set_aspect('equal')ax1.set_xlim(rmin, rmax)ax1.set_ylim(zmin, zmax)ax1.set_title(r'Rate of Strain Tensor', fontsize=TickLabel)# Add colorbar to the first subplotdivider1=make_axes_locatable(ax1)cax1=divider1.append_axes(\"right\", size=\"5%\", pad=0.1)c1=plt.colorbar(cntrl1, cax=cax1)c1.set_label(r'$log_{10}(\\|\\mathcal{D}_{ij}\\|)$', fontsize=TickLabel, labelpad=5)c1.ax.tick_params(labelsize=TickLabel)# Second subplot - Velocity Magnitude# Draw domain boundariesax2.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax2.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax2.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax2.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Plot velocity magnitude with viridis colormapcntrl2=ax2.pcolormesh(Z, R, vel, cmap=\"viridis\", edgecolor='face', vmax=1, vmin=0)# Add streamlines using the stream functionax2.contour(Z, R, psi,20, colors='black', linewidths=2)# Configure the second subplotax2.set_aspect('equal')ax2.set_xlim(rmin, rmax)ax2.set_ylim(zmin, zmax)ax2.set_title(r'Velocity Magnitude', fontsize=TickLabel)# Add colorbar to the second subplotdivider2=make_axes_locatable(ax2)cax2=divider2.append_axes(\"right\", size=\"5%\", pad=0.1)c2=plt.colorbar(cntrl2, cax=cax2)c2.set_label(r'Velocity', fontsize=TickLabel, labelpad=5)c2.ax.tick_params(labelsize=TickLabel)# Turn off axes for cleaner visualizationax1.axis('off')ax2.axis('off')plt.savefig(name, bbox_inches='tight')# Display the figureplt.close()defmain():# Get number of CPUs from command line argument, or use all available",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "parser=argparse.ArgumentParser()parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use')parser.add_argument('--nGFS',type=int, default=150,help='Number of restart files to process')parser.add_argument('--GridsPerR',type=int, default=512,help='Number of grids per R')parser.add_argument('--ZMAX',type=float, default=0.5,help='Maximum Z value')parser.add_argument('--RMAX',type=float, default=0.5,help='Maximum R value')parser.add_argument('--ZMIN',type=float, default=-0.5,help='Minimum Z value')parser.add_argument('--RMIN',type=float, default=-0.5,help='Minimum R value')parser.add_argument('--tsnap',type=float, default=0.01,help='Time snap')parser.add_argument('--caseToProcess',type=str, default='../simulationCases/LidDrivenCavity-Newtonian-dyeInjection',help='Case to process')parser.add_argument('--folderToSave',type=str, default='LidDrivenCavity-Newtonian-dyeInjection',help='Folder to save')args=parser.parse_args()num_processes=args.CPUsnGFS=args.nGFStsnap=args.tsnapZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMINRMIN=args.RMINrmin, rmax, zmin, zmax=[RMIN, RMAX, ZMIN, ZMAX]GridsPerR=args.GridsPerRlw=2folder=args.folderToSavecaseToProcess=args.caseToProcessifnotos.path.isdir(folder):os.makedirs(folder)# Create a pool of worker processeswithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep, caseToProcess=caseToProcess,folder=folder, tsnap=tsnap,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw)# Map the process_func to all timestepspool.map(process_func,range(nGFS))if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.ipynb | Test documentation: Lid driven cavity using dye injection",
    "content": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.ipynb See raw file Post-processing test for Lid-Driven Cavity flow with dye injection. Jupyter Notebook: Post-processing test for Lid-Driven Cavity flow with dye injection. Download Notebook View in nbviewer Open in Colab About this notebook Import all relevant libraries. Key Features: Visualization of data and results Analysis of simulation outputs Interactive exploration of parameters Tip: For the best interactive experience, download the notebook or open it in Google Colab. Notebook Preview Notebook Preview Unavailable The notebook preview could not be loaded. This may be because: The notebook file is not yet available in the repository The nbviewer service is temporarily unavailable The repository is private or has access restrictions You can still download the notebook using the button above or view it directly through one of the external services.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "postProcess/getData-LidDriven.c See raw file getting Data from simulation snapshot Author Vatsal Sanjay Email: vatsalsy@comphy-lab.org CoMPhy Lab Physics of Fluids Department Last updated: Mar 8, 2025 #include \"utils.h\" #include \"output.h\" #include \"poisson.h\" vector u []; char filename [ 1000 ]; int nx , ny , len ; double xmin , ymin , xmax , ymax , Deltax , Deltay ; scalar T [], vel [], psi [], omega []; scalar * list = NULL ; Main entry point for processing fluid dynamics simulation data. This function validates the command-line arguments and initializes the simulation by reading in the file name and domain parameters (xmin, ymin, xmax, ymax, ny). It registers the necessary scalar fields (T, vel, psi), restores simulation data, applies Dirichlet boundary conditions for both the velocity and streamfunction, computes the velocity magnitude and vorticity, and then solves the Poisson equation to update the streamfunction.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection: Finally, it calculates...",
    "content": "Finally, it calculates grid spacing and interpolates the scalar fields over the designated grid. Command-line arguments: arguments[0]: Program name. arguments[1]: Filename of the simulation snapshot. arguments[2]: Lower bound (xmin) of the x-domain. arguments[3]: Lower bound (ymin) of the y-domain. arguments[4]: Upper bound (xmax) of the x-domain. arguments[5]: Upper bound (ymax) of the y-domain. arguments[6]: Number of grid points along the y-direction (ny).",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection: C/C++ Main",
    "content": "Return Returns 1 if the argument validation fails; otherwise, the program proceeds with simulation processing. int main ( int a , char const * arguments []) { if ( a != 7 ) { fprintf ( ferr , \"Error: Expected 6 arguments \\n \" ); fprintf ( ferr , \"Usage: %s <filename> <xmin> <ymin> <xmax> <ymax> <ny> \\n \" , arguments [ 0 ]); return 1 ; } sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); list = list_add ( list , T ); list = list_add ( list , vel ); list = list_add ( list , psi ); /* Actual run and codes! */ restore ( file = filename ); // Top moving wall u . t [ top ] = dirichlet ( 1 ); For the other no-slip boundaries this gives u . t [ bottom ] = dirichlet ( 0 ); u . t [ left ] = dirichlet ( 0 ); u . t [ right ] = dirichlet ( 0 ); // solve for the streamfunction psi [ top ] = dirichlet ( 0 ); psi [ bottom ] = dirichlet ( 0 ); psi [ left ] = dirichlet ( 0 ); psi [ right ] = dirichlet ( 0 ); foreach () { vel [] = sqrt ( sq ( u . x [])+ sq ( u . y [])); } foreach () { omega [] = ( u . y [ 1 ] - u . y [- 1 ] - u . x [ 0 , 1 ] + u . x [ 0 ,- 1 ])/( 2. * Delta ); psi [] = 0. ; } poisson ( psi , omega ); FILE * fp = ferr ; Deltay = ( double )(( ymax - ymin )/( ny )); // fprintf(ferr, \"%g\\n\", Deltay); nx = ( int )(( xmax - xmin )/ Deltay ); // fprintf(ferr, \"%d\\n\", nx); Deltax = ( double )(( xmax - xmin )/( nx )); // fprintf(ferr, \"%g\\n\", Deltax); len = list_len ( list ); // fprintf(ferr, \"%d\\n\", len); double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); for ( int i = 0 ; i < nx ; i ++) { double x = Deltax *( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay *( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ){ field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } for ( int i = 0 ; i < nx ; i ++) { double x = Deltax *( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay *( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ){ fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } fflush ( fp ); fclose ( fp ); matrix_free ( field ); }",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"poisson.h\"vector u[];charfilename[1000];intnx,ny,len;doublexmin,ymin,xmax,ymax,Deltax,Deltay;scalar T[],vel[],psi[],omega[];scalar*list=NULL;",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "intmain(inta,charconst*arguments[]){if(a!=7){fprintf(ferr,\"Error: Expected 6 arguments\\n\");fprintf(ferr,\"Usage:%s<filename> <xmin> <ymin> <xmax> <ymax> <ny>\\n\",arguments[0]);return1;}sprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);list=list_add(list,T);list=list_add(list,vel);list=list_add(list,psi);/*Actual run and codes!*/restore(file=filename);// Top moving wallu.t[top]=dirichlet(1);",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "u.t[bottom]=dirichlet(0);u.t[left]=dirichlet(0);u.t[right]=dirichlet(0);// solve for the streamfunctionpsi[top]=dirichlet(0);psi[bottom]=dirichlet(0);psi[left]=dirichlet(0);psi[right]=dirichlet(0);foreach(){vel[]=sqrt(sq(u.x[])+sq(u.y[]));}foreach(){omega[]=(u.y[1]-u.y[-1]-u.x[0,1]+u.x[0,-1])/(2.*Delta);psi[]=0.;}poisson(psi,omega);FILE*fp=ferr;Deltay=(double)((ymax-ymin)/(ny));// fprintf(ferr, \"%g\\n\", Deltay);nx=(int)((xmax-xmin)/Deltay);// fprintf(ferr, \"%d\\n\", nx);Deltax=(double)((xmax-xmin)/(nx));// fprintf(ferr, \"%g\\n\", Deltax);len=list_len(list);// fprintf(ferr, \"%d\\n\", len);double**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));for(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}for(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}fflush(fp);fclose(fp);matrix_free(field);}",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files dye-injection.h This module introduces a circular tracer (dye) into the flow at a specified time and location. The dye then advects w...",
    "url": "https://comphy-lab.org/documentationWeb/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/dye-injection.h | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "src-local/dye-injection.h See raw file dye Injection for Flow Visualization This module introduces a circular tracer (dye) into the flow at a specified time and location. The dye then advects with the flow, allowing visualization of flow patterns. This is useful for visualizing complex flow structures in simulations like lid-driven cavity flow.",
    "url": "https://comphy-lab.org/documentationWeb/src-local/dye-injection.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/dye-injection.h | Test documentation: Lid driven cavity using dye injection: C/C++ Code",
    "content": "Parameters tInjection : time at which to inject the dye xInjection , yInjection : position where the dye is injected dyeRadius : radius of the circular dye #include \"tracer.h\" // dye tracer parameters (can be overridden by the user) double tInjection = 0.1 ; // Default injection time double xInjection = 0.0 ; // Default X-position for injection double yInjection = 0.0 ; // Default Y-position for injection double dyeRadius = 0.05 ; // Default radius of the circular dye // Define the scalar field for the dye scalar T []; scalar * tracers = { T }; // Initialize the dye tracer to zero everywhere event init ( t = 0 ) { foreach () T [] = 0.0 ; } // Inject the dye at the specified time event inject_dye ( t = tInjection ) { fprintf ( stderr , \"Injecting dye at t = %g , position = ( %g , %g ), radius = %g\\n \" , t , xInjection , yInjection , dyeRadius ); // Set dye concentration to 1.0 within the circular region foreach () { double dist = sqrt ( sq ( x - xInjection ) + sq ( y - yInjection )); if ( dist <= dyeRadius ) T [] = 1.0 ; } }",
    "url": "https://comphy-lab.org/documentationWeb/src-local/dye-injection.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/dye-injection.h | Test documentation: Lid driven cavity using dye injection - C/C++ Code: C/C++ Code",
    "content": "#include\"tracer.h\"// dye tracer parameters (can be overridden by the user)doubletInjection=0.1;// Default injection timedoublexInjection=0.0;// Default X-position for injectiondoubleyInjection=0.0;// Default Y-position for injectiondoubledyeRadius=0.05;// Default radius of the circular dye// Define the scalar field for the dyescalar T[];scalar*tracers={T};// Initialize the dye tracer to zero everywhereevent init(t=0){foreach()T[]=0.0;}// Inject the dye at the specified timeevent inject_dye(t=tInjection){fprintf(stderr,\"Injecting dye at t =%g, position = (%g,%g), radius =%g\\n\",t,xInjection,yInjection,dyeRadius);// Set dye concentration to 1.0 within the circular regionforeach(){doubledist=sqrt(sq(x-xInjection)+sq(y-yInjection));if(dist<=dyeRadius)T[]=1.0;}}",
    "url": "https://comphy-lab.org/documentationWeb/src-local/dye-injection.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # MacOS only. modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk rm -rf basilisk rm -rf .project_config darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config",
    "url": "https://comphy-lab.org/Viscoelastic3D/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#!/bin/zsh# MacOS only. modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basiliskrm-rfbasiliskrm-rf.project_configdarcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimakeecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config",
    "url": "https://comphy-lab.org/Viscoelastic3D/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: ElastoFlow: 2D/3D Viscoelastic...",
    "content": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework \ud83d\ude80 ElastoFlow is a state-of-the-art, open-source framework for simulating viscoelastic fluid flows in 2D and 3D, built as an extension to the Basilisk C CFD library.",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "It implements the log-conformation method for robust, high-Weissenberg number simulations, with a focus on clarity, extensibility, and scientific rigor. \u2728 Key Features Full 3D Log-Conformation Method : Complete scalar implementation for 3D viscoelastic fluids ( log-conform-viscoelastic-scalar-3D.h ) Robust 2D/Axi Support : Scalar and tensor-based log-conformation for 2D and axisymmetric cases ( log-conform-viscoelastic-scalar-2D.h , log-conform-viscoelastic.h ) Optimized Matrix Algebra : Efficient, stable eigenvalue and tensor operations ( eigen_decomposition.h ) Advanced Initialization : Functions for pseudo vectors/tensors in 2D/3D Error Handling : Negative eigenvalue checks, eigenvalue clamping, and detailed diagnostics Performance : Simplified acceleration term calculations and optimized tensor operations Documentation : Extensive inline documentation, mathematical background, and verification notes Compatibility : GPLv3 license, fully compatible with Basilisk and previous ElastoFlow versions \ud83d\udc1b Bug Fixes (v2.5/v2.6) Corrected matrix algebra in 3D Fixed rotation tensor and eigenvalue edge cases Improved error reporting and diagnostics Enhanced axisymmetric and 2D/3D compatibility \ud83d\uddc2\ufe0f Repository Structure basilisk/src/ - # Core Basilisk CFD library (reference only, do not modify) src-local/ - # Custom viscoelastic solvers and tensor utilities log-conform-viscoelastic-scalar-3D.h - # 3D log-conformation (scalar) log-conform-viscoelastic-scalar-2D.h - # 2D/axi log-conformation (scalar) log-conform-viscoelastic.h - # 2D/axi log-conformation (tensor) two-phaseVE.h - # Two-phase viscoelastic extension eigen_decomposition.h - # 3x3 symmetric eigenvalue solver simulationCases/ - # Example/test cases and post-processing scripts dropAtomisation.c - # 3D drop atomisation simulation pinchOff.c - # Pinch-off of viscoelastic jet (2D/axi) testEigenDecomposition.c - # Eigenvalue solver test/verification dropImpact.c - # Drop impact simulation verifyWtihPlots.ipynb - # Jupyter notebook for verification/plots postProcess/ - # Project-specific post-processing tools and utilities getData-elastic-scalar2D.c - # Data extraction utility getFacet2D.c - # Facet extraction utility VideoAxi.py - # Python visualization script \ud83d\udcda Documentation docs/ \u2014 Full HTML documentation, mathematical background, and API Inline documentation in all major headers (see src-local/ ) Example simulation and post-processing scripts in simulationCases/ \ud83d\ude80 Quick Start 1.",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Prerequisites Basilisk C...",
    "content": "Prerequisites Basilisk C (included as submodule in basilisk/ ) C compiler (e.g., gcc) Python 3 (for post-processing) Optional: Jupyter for notebooks 2. Compiling & Running Simulations A. Vanilla Basilisk method: qcc -O2 -Wall -I. /src-local -disable-dimensions simulationCases/{CaseName}.c -o {CaseName} -lm ./{CaseName} B. Using the Makefile (with bview browser): CFLAGS = -DDISPLAY=-1 make simulationCases/{CaseName}.tst For interactive visualization, open the generated display.html in your browser (see Basilisk bview ). 3. Post-Processing & Analysis Python scripts and Jupyter notebooks for data extraction and visualization are in simulationCases/ (e.g., VideoAxi.py , verifyWtihPlots.ipynb ).",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "Example utilities: getData-elastic-scalar2D.c , getFacet2D.c . \ud83d\udcdd Example: Running a 3D Drop Atomisation Simulation qcc -O2 -Wall -I. /src-local -disable-dimensions simulationCases/dropAtomisation.c -o dropAtomisation -lm ./dropAtomisation \ud83d\udd0d Technical Details Log-Conformation Method : See src-local/log-conform-viscoelastic-scalar-3D.h and src-local/log-conform-viscoelastic-scalar-2D.h for mathematical background and implementation notes. Eigenvalue Solver : src-local/eigen_decomposition.h provides robust 3x3 symmetric eigensystem routines. Two-Phase Flows : src-local/two-phaseVE.h extends Basilisk\u2019s two-phase solver for viscoelasticity. Axisymmetric/2D/3D : Use the appropriate header for your geometry (see comments in each header for guidance). \ud83e\uddd1\u200d\ud83d\udcbb Contributing See CLAUDE.md for code style and development guidelines. Issue templates and feature requests: GitHub Issue Templates Pull requests are welcome!",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "Please document your changes and update relevant tests/examples. \ud83d\udccb License This project is licensed under the GNU GPLv3 , in line with the Basilisk codebase. \ud83d\ude4f Acknowledgments Thanks to all contributors and the Basilisk community \ud83d\udd17 References Fattal & Kupferman (2004, 2005): Log-conformation method Comminal et al. (2015): Constitutive model functions Hao & Pan (2007): Split scheme implementation Basilisk C For detailed documentation, see the docs/ folder or open docs/index.html in your browser.",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Generated Documentation Root...",
    "content": "Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/VideoAxi.py postProcess/getData-elastic-scalar2D.c postProcess/getFacet2D.c simulationCases simulationCases/dropAtomisation.c simulationCases/dropImpact.c simulationCases/pinchOff.c simulationCases/testEigenDecomposition.c simulationCases/verifyWtihPlots.ipynb src-local src-local/eigen_decomposition.h src-local/log-conform-viscoelastic-scalar-2D.h src-local/log-conform-viscoelastic-scalar-3D.h src-local/log-conform-viscoelastic.h src-local/two-phaseVE.h",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "qcc-O2-Wall-I./src-local-disable-dimensionssimulationCases/{CaseName}.c-o{CaseName}-lm./{CaseName}",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "CFLAGS=-DDISPLAY=-1makesimulationCases/{CaseName}.tst",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "qcc-O2-Wall-I./src-local-disable-dimensionssimulationCases/dropAtomisation.c-odropAtomisation-lm./dropAtomisation",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "simulationCases/testEigenDecomposition.c See raw file 3D Matrix Diagonalization and Eigendecomposition This module implements the diagonalization of 3D symmetric matrices through eigendecomposition, allowing the computation of eigenvalues and eigenvectors for 3x3 symmetric matrices.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The implementation follows...",
    "content": "The implementation follows standard linear algebra approaches to compute \\(A = R \\times \\Lambda \\times R^T\\) where: \\(A\\) is the original symmetric matrix \\(R\\) is the orthogonal matrix of eigenvectors \\(\\Lambda\\) is the diagonal matrix of eigenvalues Numerical Parameters EPSILON: Used for floating-point comparisons to zero RELATIVE_TOLERANCE: Used for relative error checks in verification #include <stdio.h> #include <math.h> #include <stdlib.h> #include \"eigen_decomposition.h\" #define EPSILON 1e-9 24 #define RELATIVE_TOLERANCE 1e-6 25 #define sq ( x ) (( x )*( x )) 26 27 Data Structures 3D Vector Represents a 3D vector with long double precision components. typedef struct { long double x , y , z ; } pseudo_v3d ; 3D Tensor/Matrix Represents a 3x3 matrix or tensor with long double precision components. Organized as three row vectors (x, y, z). typedef struct { pseudo_v3d x , y , z ; } pseudo_t3d ; diagonalization_3D Performs eigendecomposition of a 3D symmetric matrix.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "This function computes the eigenvalues and eigenvectors of a 3x3 symmetric matrix using the eigen_decomposition function. It handles special cases where the matrix is already diagonal.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Parameters: - Lambda: Output parameter to store the eigenvalues - R: Output parameter to store the eigenvectors as columns of R - A: Input symmetric matrix to be diagonalized The function maps the struct-based representation to arrays for computation and then maps the results back to the struct-based representation. static void diagonalization_3D ( pseudo_v3d * Lambda , pseudo_t3d * R , pseudo_t3d * A ) { // Check if the matrix is already diagonal if ( sq ( A -> x . y ) + sq ( A -> x . z ) + sq ( A -> y . z ) < 1e-15 ) { R -> x . x = R -> y . y = R -> z . z = 1. ; R -> y . x = R -> x . y = R -> z . x = R -> x . z = R -> z . y = R -> y . z = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; Lambda -> z = A -> z . z ; return ; } // Compute eigenvalues using the eigen_decomposition function double matrix [ 3 ][ 3 ] = { { A -> x . x , A -> x . y , A -> x . z }, { A -> x . y , A -> y . y , A -> y . z }, { A -> x . z , A -> y . z , A -> z . z } }; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); // Store eigenvalues and eigenvectors with proper index mapping Lambda -> x = eigenvalues [ 0 ]; Lambda -> y = eigenvalues [ 1 ]; Lambda -> z = eigenvalues [ 2 ]; R -> x . x = eigenvectors [ 0 ][ 0 ]; R -> x . y = eigenvectors [ 0 ][ 1 ]; R -> x . z = eigenvectors [ 0 ][ 2 ]; R -> y . x = eigenvectors [ 1 ][ 0 ]; R -> y . y = eigenvectors [ 1 ][ 1 ]; R -> y . z = eigenvectors [ 1 ][ 2 ]; R -> z . x = eigenvectors [ 2 ][ 0 ]; R -> z . y = eigenvectors [ 2 ][ 1 ]; R -> z . z = eigenvectors [ 2 ][ 2 ]; } print_pseudo_t3d Prints a 3x3 matrix to standard output with formatting.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: JavaScript",
    "content": "Parameters: - name: Label for the matrix output - matrix: Pointer to the 3x3 matrix to be printed void print_pseudo_t3d ( const char * name , const pseudo_t3d * matrix ) { printf ( \" %s : \\n \" , name ); printf ( \" %12.9Lf %12.9Lf %12.9Lf\\n \" , matrix -> x . x , matrix -> x . y , matrix -> x . z ); printf ( \" %12.9Lf %12.9Lf %12.9Lf\\n \" , matrix -> y . x , matrix -> y . y , matrix -> y . z ); printf ( \" %12.9Lf %12.9Lf %12.9Lf\\n \" , matrix -> z . x , matrix -> z . y , matrix -> z . z ); printf ( \" \\n \" ); } print_pseudo_v3d Prints a 3D vector to standard output with formatting. Parameters: - name: Label for the vector output - vector: Pointer to the 3D vector to be printed void print_pseudo_v3d ( const char * name , const pseudo_v3d * vector ) { printf ( \" %s : %12.9Lf %12.9Lf %12.9Lf\\n\\n \" , name , vector -> x , vector -> y , vector -> z ); } verify_orthonormality Verifies that the eigenvectors form an orthonormal basis. This function checks two key properties of eigenvectors: 1.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Each eigenvector has...",
    "content": "Each eigenvector has unit norm (normalized) 2. Eigenvectors are mutually orthogonal (dot product is zero) Parameters: - R: Matrix containing eigenvectors as columns Returns: - 1 if eigenvectors are orthonormal - 0 otherwise, with diagnostic messages printed to stdout int verify_orthonormality ( const pseudo_t3d * R ) { for ( int i = 0 ; i < 3 ; i ++) { long double norm = sq ((( long double *) R )[ i ]) + sq ((( long double *) R )[ i + 3 ]) + sq ((( long double *) R )[ i + 6 ]); if ( fabsl ( norm - 1.0 L ) > EPSILON ) { printf ( \"Eigenvector %d is not normalized. Norm = %Lf\\n \" , i , sqrtl ( norm )); return 0 ; } for ( int j = i + 1 ; j < 3 ; j ++) { long double dot_product = (( long double *) R )[ i ] * (( long double *) R )[ j ] + (( long double *) R )[ i + 3 ] * (( long double *) R )[ j + 3 ] + (( long double *) R )[ i + 6 ] * (( long double *) R )[ j + 6 ]; if ( fabsl ( dot_product ) > EPSILON ) { printf ( \"Eigenvectors %d and %d are not orthogonal.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Dot product =...",
    "content": "Dot product = %Lf\\n \" , i , j , dot_product ); return 0 ; } } } return 1 ; } verify_diagonalization Verifies that the matrix is properly diagonalized by computing R^T * A * R and checking if it approximates a diagonal matrix with eigenvalues. Parameters: - A: Original matrix - R: Matrix of eigenvectors - Lambda: Vector of eigenvalues Returns: - 1 if diagonalization is verified - 0 otherwise, with diagnostic messages printed to stdout The function checks two properties: 1. Diagonal elements match the eigenvalues within relative tolerance 2.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: JavaScript",
    "content": "Off-diagonal elements are approximately zero int verify_diagonalization ( const pseudo_t3d * A , const pseudo_t3d * R , const pseudo_v3d * Lambda ) { pseudo_t3d temp , diagonalized ; // Compute R^T * A * R for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& temp )[ i * 3 + j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++) { (( long double *)& temp )[ i * 3 + j ] += (( long double *) R )[ k * 3 + i ] * (( long double *) A )[ k * 3 + j ]; } } } for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& diagonalized )[ i * 3 + j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++) { (( long double *)& diagonalized )[ i * 3 + j ] += (( long double *)& temp )[ i * 3 + k ] * (( long double *) R )[ k * 3 + j ]; } } } // Print the diagonalized matrix print_pseudo_t3d ( \"Diagonalized matrix: (R^T * A * R)\" , & diagonalized ); for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { if ( i == j ) { long double relative_error = fabsl ((( long double *)& diagonalized )[ i * 3 + j ] - (( long double *) Lambda )[ i ]) / ( fabsl ((( long double *) Lambda )[ i ]) + EPSILON ); if ( relative_error > RELATIVE_TOLERANCE ) { printf ( \"Diagonal element ( %d , %d ) does not match eigenvalue. %Lf != %Lf \" \"(relative error: %Lf ) \\n \" , i , j , (( long double *)& diagonalized )[ i * 3 + j ], (( long double *) Lambda )[ i ], relative_error ); } } else { if ( fabsl ((( long double *)& diagonalized )[ i * 3 + j ]) > EPSILON ) { printf ( \"Off-diagonal element ( %d , %d ) is not zero.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Value = %Lf\\n \" , i , j , (( long double *)& diagonalized )[ i * 3 + j ]); } } } } return 1 ; } verify_eigenpairs Verifies that \\(A \\times v = \\lambda \\times v\\) for each eigenpair. This function checks the fundamental eigenvalue equation by: 1. Computing \\(A \\times v\\) for each eigenvector 2. Computing \\(\\lambda \\times v\\) for each eigenvector 3.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Comparing the results for approximate equality Parameters: - A: Original matrix - R: Matrix containing eigenvectors as columns - Lambda: Vector of eigenvalues Returns: - 1 if all eigenpairs are verified - 0 otherwise, with diagnostic messages printed to stdout int verify_eigenpairs ( const pseudo_t3d * A , const pseudo_t3d * R , const pseudo_v3d * Lambda ) { printf ( \"Verifying A * v = \u03bb * v for each eigenpair: \\n \" ); for ( int i = 0 ; i < 3 ; i ++) { pseudo_v3d Av = { 0 }, lambda_v = { 0 }; // Compute A * v for ( int j = 0 ; j < 3 ; j ++) { (( double *)& Av )[ j ] = (( double *) A )[ j * 3 ] * (( double *) R )[ i ] + (( double *) A )[ j * 3 + 1 ] * (( double *) R )[ i + 3 ] + (( double *) A )[ j * 3 + 2 ] * (( double *) R )[ i + 6 ]; } // Compute \u03bb * v for ( int j = 0 ; j < 3 ; j ++) { (( double *)& lambda_v )[ j ] = (( double *) Lambda )[ i ] * (( double *) R )[ i + j * 3 ]; } printf ( \"Eigenpair %d : \\n \" , i + 1 ); printf ( \"A * v = %8.4Lf %8.4Lf %8.4Lf\\n \" , Av . x , Av . y , Av . z ); printf ( \"\u03bb * v = %8.4Lf %8.4Lf %8.4Lf\\n \" , lambda_v . x , lambda_v . y , lambda_v . z ); // Check if A * v \u2248 \u03bb * v for ( int j = 0 ; j < 3 ; j ++) { if ( fabs ((( double *)& Av )[ j ] - (( double *)& lambda_v )[ j ]) > EPSILON ) { printf ( \"Mismatch for eigenpair %d , component %d\\n \" , i + 1 , j + 1 ); } } printf ( \"Verification A * v = \u03bb * v for each eigenpair done. \" \"See the messages above! \\n\\n \" ); } return 1 ; } verify_eigendecomposition Main verification function that combines all verification tests.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "This function verifies the eigendecomposition by: 1. Checking orthonormality of eigenvectors 2. Verifying diagonalization ( \\(R^T \\times A \\times R \\approx \\Lambda\\) ) 3.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Confirming the eigenpair...",
    "content": "Confirming the eigenpair equation ( \\(A \\times v = \\lambda \\times v\\) ) Parameters: - A: Original matrix - R: Matrix of eigenvectors - Lambda: Vector of eigenvalues Returns: - 1 when verification completes - Messages about verification status are printed to stdout int verify_eigendecomposition ( const pseudo_t3d * A , const pseudo_t3d * R , const pseudo_v3d * Lambda ) { if (! verify_orthonormality ( R )) { printf ( \"Eigenvectors are not orthonormal. \\n \" ); } else { printf ( \"Eigenvectors are orthonormal. \\n \" ); } printf ( \" \\n \" ); if (! verify_diagonalization ( A , R , Lambda )) { printf ( \"Matrix is not properly diagonalized. \\n \" ); } else { printf ( \"Matrix is properly diagonalized. \\n \" ); } if (! verify_eigenpairs ( A , R , Lambda )) { printf ( \"Eigenpair verification failed. \\n \" ); } else { printf ( \"Eigenpair verification passed. \\n \" ); } printf ( \"Eigendecomposition verification completed.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: See the messages...",
    "content": "See the messages above! \\n \" ); return 1 ; } verify_reconstruction Verifies that \\(A = R \\times \\Lambda \\times R^T\\) by reconstructing \\(A\\) from the eigendecomposition. This function: 1. Creates a diagonal matrix from the eigenvalues 2. Computes \\(R \\times \\Lambda \\times R^T\\) 3.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Compares the result with the original matrix \\(A\\) Parameters: - A: Original matrix - R: Matrix of eigenvectors - Lambda: Vector of eigenvalues Returns: - 1 when verification completes - Differences between original and reconstructed matrices are printed to stdout int verify_reconstruction ( const pseudo_t3d * A , const pseudo_t3d * R , const pseudo_v3d * Lambda ) { pseudo_t3d Lambda_diag , temp , A_reconstructed ; // Create diagonal matrix from Lambda for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& Lambda_diag )[ i * 3 + j ] = ( i == j ) ? (( long double *) Lambda )[ i ] : 0.0 L ; } } // Compute R * Lambda for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& temp )[ i * 3 + j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++) { (( long double *)& temp )[ i * 3 + j ] += (( long double *) R )[ i * 3 + k ] * (( long double *)& Lambda_diag )[ k * 3 + j ]; } } } // Compute (R * Lambda) * R^T for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& A_reconstructed )[ i * 3 + j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++) { (( long double *)& A_reconstructed )[ i * 3 + j ] += (( long double *)& temp )[ i * 3 + k ] * (( long double *) R )[ j * 3 + k ]; } } } print_pseudo_t3d ( \"Reconstructed A = R * Lambda * R^T\" , & A_reconstructed ); // Compare original A with reconstructed A for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { long double diff = fabsl ((( long double *) A )[ i * 3 + j ] - (( long double *)& A_reconstructed )[ i * 3 + j ]); if ( diff > EPSILON ) { printf ( \"Mismatch at ( %d , %d ): original = %Lf , reconstructed = %Lf , \" \"difference = %Lf\\n \" , i , j , (( long double *) A )[ i * 3 + j ], (( long double *)& A_reconstructed )[ i * 3 + j ], diff ); } } } printf ( \"A = R * Lambda * R^T verification completed.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: See the messages...",
    "content": "See the messages above! \\n \" ); return 1 ; } Main Function Entry point of the program that demonstrates matrix diagonalization and verification. The function: 1. Initializes a symmetric matrix A (default or from command line arguments) 2. Performs eigendecomposition to compute eigenvalues and eigenvectors 3.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Runs verification procedures to confirm the correctness of the results Command-line usage: ./program A11 A12 A13 A22 A23 A33 Where A11\u2026A33 are the elements of the symmetric matrix If no arguments are provided, a default matrix is used: A = [ 1 2 3 ] [ 2 4 5 ] [ 3 5 -6 ] Returns: - 0 on successful execution int main ( int argc , char * argv []) { pseudo_t3d A , R ; pseudo_v3d Lambda ; // Initialize A with the given values Matrix Initialization Options Uncomment one of the following blocks to use a specific test matrix: Diagonal (not identity) matrix: A.x.x = 1; A.x.y = 0; A.x.z = 0; A.y.x = 0; A.y.y = 2; A.y.z = 0; A.z.x = 0; A.z.y = 0; A.z.z = 3; Identity matrix: A.x.x = 1; A.x.y = 0; A.x.z = 0; A.y.x = 0; A.y.y = 1; A.y.z = 0; A.z.x = 0; A.z.y = 0; A.z.z = 1; Non-diagonal matrix: A.x.x = 1; A.x.y = 2; A.x.z = 3; A.y.x = 2; A.y.y = 4; A.y.z = 5; A.z.x = 3; A.z.y = 5; A.z.z = -6; Small magnitude matrix: A.x.x = 1e-6; A.x.y = 0; A.x.z = 0; A.y.x = 0; A.y.y = 1e-12; A.y.z = 0; A.z.x = 0; A.z.y = 0; A.z.z = 1e-10; Large magnitude matrix: A.x.x = 100; A.x.y = 100; A.x.z = 10; A.y.x = 100; A.y.y = 10; A.y.z = 1; A.z.x = 10; A.z.y = 1; A.z.z = 0.1; if ( argc != 7 ) { A . x . x = 1 ; A . x . y = 2 ; A . x . z = 3 ; A . y . x = 2 ; A . y . y = 4 ; A . y . z = 5 ; A . z . x = 3 ; A . z . y = 5 ; A . z . z = - 6 ; } else { // Get matrix elements from command line arguments A . x . x = atof ( argv [ 1 ]); A . x . y = atof ( argv [ 2 ]); A . x . z = atof ( argv [ 3 ]); A . y . x = atof ( argv [ 2 ]); A . y . y = atof ( argv [ 4 ]); A . y . z = atof ( argv [ 5 ]); A . z . x = atof ( argv [ 3 ]); A . z . y = atof ( argv [ 5 ]); A . z . z = atof ( argv [ 6 ]); } print_pseudo_t3d ( \"Original matrix A\" , & A ); diagonalization_3D (& Lambda , & R , & A ); print_pseudo_t3d ( \"Eigenvectors R\" , & R ); print_pseudo_v3d ( \"Eigenvalues Lambda\" , & Lambda ); verify_eigendecomposition (& A , & R , & Lambda ); // Verify that A = R * Lambda * R^T verify_reconstruction (& A , & R , & Lambda ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#include<stdio.h>#include<math.h>#include<stdlib.h>#include\"eigen_decomposition.h\"#define EPSILON1e-924#define RELATIVE_TOLERANCE1e-625#define sq(x)((x)*(x))2627",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: staticvoiddiagonalization_3D(pseudo_v3d*Lambda,pseudo_t3d*R,pseudo_t3d*A){// Check if...",
    "content": "staticvoiddiagonalization_3D(pseudo_v3d*Lambda,pseudo_t3d*R,pseudo_t3d*A){// Check if the matrix is already diagonalif(sq(A->x.y)+sq(A->x.z)+sq(A->y.z)<1e-15){R->x.x=R->y.y=R->z.z=1.;R->y.x=R->x.y=R->z.x=R->x.z=R->z.y=R->y.z=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;Lambda->z=A->z.z;return;}// Compute eigenvalues using the eigen_decomposition functiondoublematrix[3][3]={{A->x.x,A->x.y,A->x.z},{A->x.y,A->y.y,A->y.z},{A->x.z,A->y.z,A->z.z}};doubleeigenvectors[3][3];doubleeigenvalues[3];compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);// Store eigenvalues and eigenvectors with proper index mappingLambda->x=eigenvalues[0];Lambda->y=eigenvalues[1];Lambda->z=eigenvalues[2];R->x.x=eigenvectors[0][0];R->x.y=eigenvectors[0][1];R->x.z=eigenvectors[0][2];R->y.x=eigenvectors[1][0];R->y.y=eigenvectors[1][1];R->y.z=eigenvectors[1][2];R->z.x=eigenvectors[2][0];R->z.y=eigenvectors[2][1];R->z.z=eigenvectors[2][2];}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "voidprint_pseudo_t3d(constchar*name,constpseudo_t3d*matrix){printf(\"%s:\\n\",name);printf(\"%12.9Lf%12.9Lf%12.9Lf\\n\",matrix->x.x,matrix->x.y,matrix->x.z);printf(\"%12.9Lf%12.9Lf%12.9Lf\\n\",matrix->y.x,matrix->y.y,matrix->y.z);printf(\"%12.9Lf%12.9Lf%12.9Lf\\n\",matrix->z.x,matrix->z.y,matrix->z.z);printf(\"\\n\");}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "voidprint_pseudo_v3d(constchar*name,constpseudo_v3d*vector){printf(\"%s:%12.9Lf%12.9Lf%12.9Lf\\n\\n\",name,vector->x,vector->y,vector->z);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_orthonormality(constpseudo_t3d*R){for(inti=0;i<3;i++){longdoublenorm=sq(((longdouble*)R)[i])+sq(((longdouble*)R)[i+3])+sq(((longdouble*)R)[i+6]);if(fabsl(norm-1.0L)>EPSILON){printf(\"Eigenvector%dis not normalized.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "Norm =%Lf\\n\",i,sqrtl(norm));return0;}for(intj=i+1;j<3;j++){longdoubledot_product=((longdouble*)R)[i]*((longdouble*)R)[j]+((longdouble*)R)[i+3]*((longdouble*)R)[j+3]+((longdouble*)R)[i+6]*((longdouble*)R)[j+6];if(fabsl(dot_product)>EPSILON){printf(\"Eigenvectors%dand%dare not orthogonal. Dot product =%Lf\\n\",i,j,dot_product);return0;}}}return1;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_diagonalization(constpseudo_t3d*A,constpseudo_t3d*R,constpseudo_v3d*Lambda){pseudo_t3d temp,diagonalized;// Compute R^T * A * Rfor(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&temp)[i*3+j]=0;for(intk=0;k<3;k++){((longdouble*)&temp)[i*3+j]+=((longdouble*)R)[k*3+i]*((longdouble*)A)[k*3+j];}}}for(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&diagonalized)[i*3+j]=0;for(intk=0;k<3;k++){((longdouble*)&diagonalized)[i*3+j]+=((longdouble*)&temp)[i*3+k]*((longdouble*)R)[k*3+j];}}}// Print the diagonalized matrixprint_pseudo_t3d(\"Diagonalized matrix: (R^T * A * R)\",&diagonalized);for(inti=0;i<3;i++){for(intj=0;j<3;j++){if(i==j){longdoublerelative_error=fabsl(((longdouble*)&diagonalized)[i*3+j]-((longdouble*)Lambda)[i])/(fabsl(((longdouble*)Lambda)[i])+EPSILON);if(relative_error>RELATIVE_TOLERANCE){printf(\"Diagonal element (%d,%d) does not match eigenvalue.%Lf!=%Lf\"\"(relative error:%Lf)\\n\",i,j,((longdouble*)&diagonalized)[i*3+j],((longdouble*)Lambda)[i],relative_error);}}else{if(fabsl(((longdouble*)&diagonalized)[i*3+j])>EPSILON){printf(\"Off-diagonal element (%d,%d) is not zero.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "Value =%Lf\\n\",i,j,((longdouble*)&diagonalized)[i*3+j]);}}}}return1;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_eigenpairs(constpseudo_t3d*A,constpseudo_t3d*R,constpseudo_v3d*Lambda){printf(\"Verifying A * v = \u03bb * v for each eigenpair:\\n\");for(inti=0;i<3;i++){pseudo_v3d Av={0},lambda_v={0};// Compute A * vfor(intj=0;j<3;j++){((double*)&Av)[j]=((double*)A)[j*3]*((double*)R)[i]+((double*)A)[j*3+1]*((double*)R)[i+3]+((double*)A)[j*3+2]*((double*)R)[i+6];}// Compute \u03bb * vfor(intj=0;j<3;j++){((double*)&lambda_v)[j]=((double*)Lambda)[i]*((double*)R)[i+j*3];}printf(\"Eigenpair%d:\\n\",i+1);printf(\"A * v =%8.4Lf%8.4Lf%8.4Lf\\n\",Av.x,Av.y,Av.z);printf(\"\u03bb * v =%8.4Lf%8.4Lf%8.4Lf\\n\",lambda_v.x,lambda_v.y,lambda_v.z);// Check if A * v \u2248 \u03bb * vfor(intj=0;j<3;j++){if(fabs(((double*)&Av)[j]-((double*)&lambda_v)[j])>EPSILON){printf(\"Mismatch for eigenpair%d, component%d\\n\",i+1,j+1);}}printf(\"Verification A * v = \u03bb * v for each eigenpair done. \"\"See the messages above!\\n\\n\");}return1;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_eigendecomposition(constpseudo_t3d*A,constpseudo_t3d*R,constpseudo_v3d*Lambda){if(!verify_orthonormality(R)){printf(\"Eigenvectors are not orthonormal.\\n\");}else{printf(\"Eigenvectors are orthonormal.\\n\");}printf(\"\\n\");if(!verify_diagonalization(A,R,Lambda)){printf(\"Matrix is not properly diagonalized.\\n\");}else{printf(\"Matrix is properly diagonalized.\\n\");}if(!verify_eigenpairs(A,R,Lambda)){printf(\"Eigenpair verification failed.\\n\");}else{printf(\"Eigenpair verification passed.\\n\");}printf(\"Eigendecomposition verification completed.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: See the messages...",
    "content": "See the messages above!\\n\");return1;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_reconstruction(constpseudo_t3d*A,constpseudo_t3d*R,constpseudo_v3d*Lambda){pseudo_t3d Lambda_diag,temp,A_reconstructed;// Create diagonal matrix from Lambdafor(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&Lambda_diag)[i*3+j]=(i==j)?((longdouble*)Lambda)[i]:0.0L;}}// Compute R * Lambdafor(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&temp)[i*3+j]=0;for(intk=0;k<3;k++){((longdouble*)&temp)[i*3+j]+=((longdouble*)R)[i*3+k]*((longdouble*)&Lambda_diag)[k*3+j];}}}// Compute (R * Lambda) * R^Tfor(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&A_reconstructed)[i*3+j]=0;for(intk=0;k<3;k++){((longdouble*)&A_reconstructed)[i*3+j]+=((longdouble*)&temp)[i*3+k]*((longdouble*)R)[j*3+k];}}}print_pseudo_t3d(\"Reconstructed A = R * Lambda * R^T\",&A_reconstructed);// Compare original A with reconstructed Afor(inti=0;i<3;i++){for(intj=0;j<3;j++){longdoublediff=fabsl(((longdouble*)A)[i*3+j]-((longdouble*)&A_reconstructed)[i*3+j]);if(diff>EPSILON){printf(\"Mismatch at (%d,%d): original =%Lf, reconstructed =%Lf, \"\"difference =%Lf\\n\",i,j,((longdouble*)A)[i*3+j],((longdouble*)&A_reconstructed)[i*3+j],diff);}}}printf(\"A = R * Lambda * R^T verification completed.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intmain(intargc,char*argv[]){pseudo_t3d A,R;pseudo_v3d Lambda;// Initialize A with the given values",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 1;  A.x.y = 0; A.x.z = 0;\nA.y.x = 0; A.y.y = 2;  A.y.z = 0;\nA.z.x = 0;  A.z.y = 0;  A.z.z = 3;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 1;  A.x.y = 0; A.x.z = 0;\nA.y.x = 0; A.y.y = 1;  A.y.z = 0;\nA.z.x = 0;  A.z.y = 0;  A.z.z = 1;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 1;  A.x.y = 2; A.x.z = 3;\nA.y.x = 2; A.y.y = 4;  A.y.z = 5;\nA.z.x = 3;  A.z.y = 5;  A.z.z = -6;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 1e-6;  A.x.y = 0; A.x.z = 0;\nA.y.x = 0; A.y.y = 1e-12;  A.y.z = 0;\nA.z.x = 0;  A.z.y = 0;  A.z.z = 1e-10;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 100;  A.x.y = 100; A.x.z = 10;\nA.y.x = 100; A.y.y = 10;  A.y.z = 1;\nA.z.x = 10;  A.z.y = 1;  A.z.z = 0.1;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "if(argc!=7){A.x.x=1;A.x.y=2;A.x.z=3;A.y.x=2;A.y.y=4;A.y.z=5;A.z.x=3;A.z.y=5;A.z.z=-6;}else{// Get matrix elements from command line argumentsA.x.x=atof(argv[1]);A.x.y=atof(argv[2]);A.x.z=atof(argv[3]);A.y.x=atof(argv[2]);A.y.y=atof(argv[4]);A.y.z=atof(argv[5]);A.z.x=atof(argv[3]);A.z.y=atof(argv[5]);A.z.z=atof(argv[6]);}print_pseudo_t3d(\"Original matrix A\",&A);diagonalization_3D(&Lambda,&R,&A);print_pseudo_t3d(\"Eigenvectors R\",&R);print_pseudo_v3d(\"Eigenvalues Lambda\",&Lambda);verify_eigendecomposition(&A,&R,&Lambda);// Verify that A = R * Lambda * R^Tverify_reconstruction(&A,&R,&Lambda);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "simulationCases/dropImpact.c See raw file Drop Impact Simulation This file contains the simulation code for drop impact on a solid surface using a Volume of Fluid (VOF) method with viscoelastic fluid modeling capabilities. The simulation uses an adaptive mesh refinement approach to efficiently resolve the interface dynamics during impact. The model can handle both Newtonian and viscoelastic fluids through a log-conformation formulation for the polymeric stress tensor. Physical Model The simulation solves the Navier-Stokes equations for incompressible flow coupled with a viscoelastic constitutive equation. The interface between the two fluids is tracked using a VOF method with surface tension.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Key dimensionless parameters:...",
    "content": "Key dimensionless parameters: Weber number ( \\(We\\) ): Ratio of inertia to surface tension Ohnesorge number ( \\(Oh\\) ): Ratio of viscous to inertial and surface tension forces Deborah number ( \\(De\\) ): Ratio of relaxation time to characteristic flow time Elastocapillary number ( \\(Ec\\) ): Ratio of elastic to capillary forces @file dropImpact.c @author Vatsal Sanjay @version 0.2 @date Oct 18, 2024 // #include \"axi.h\" #include \"grid/octree.h\" // #include \"grid/quadtree.h\" #include \"navier-stokes/centered.h\" #define VANILLA 0 36 #if VANILLA #include \"log-conform-viscoelastic.h\" #define logFile \"logAxi-vanilla.dat\" 39 #else #if AXI #include \"log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 43 #else #include \"log-conform-viscoelastic-scalar-3D.h\" #define logFile \"log3D-scalar.dat\" 46 #endif #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" Simulation Parameters Timing Parameters tsnap: Time interval between snapshots (1e-2) #define tsnap ( 1e-2 ) 62 63 Numerical Error Tolerances fErr: Error tolerance in VOF function f1 (1e-3) KErr: Error tolerance in VOF curvature calculated using height function method (1e-6) VelErr: Error tolerances in velocity (1e-2) Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define fErr ( 1e-3 ) 71 #define KErr ( 1e-6 ) 72 #define VelErr ( 1e-2 ) 73 74 Domain Configuration xDist: Initial horizontal displacement of droplet center from boundary (5e-2) R2: Function to calculate squared distance from droplet center #define xDist ( 5e-2 ) 80 #define R2 ( x , y , z ) ( sq ( x - 1. - xDist ) + sq ( y ) + sq ( z )) 81 82 Boundary Conditions Dirichlet boundary condition for volume fraction at left boundary.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Note: No-slip boundary...",
    "content": "Note: No-slip boundary conditions are commented out for testing purposes. // u.t[left] = dirichlet(0.); // todo: later on use no-slip. For testing, free-slip is faster. // u.r[left] = dirichlet(0.); // todo: later on use no-slip. For testing, free-slip is faster. f [ left ] = dirichlet ( 0.0 ); Global Variables MAXlevel: Maximum level of grid refinement We: Weber number of the drop Oh: Solvent Ohnesorge number Oha: Air Ohnesorge number De: Deborah number Ec: Elasto-capillary number tmax: Maximum simulation time nameOut: Output filename for snapshots dumpFile: Filename for restart dumps int MAXlevel ; double We , Oh , Oha , De , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; Main Function Initializes the simulation parameters and grid, then starts the simulation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: C/C++ Main",
    "content": "Parameters argc: Command-line argument count argv: Command-line argument array Return Value Returns 0 on successful completion int main ( int argc , char const * argv []) { dtmax = 1e-5 ; L0 = 4.0 ; // Values taken from the terminal MAXlevel = 6 ; tmax = 3.0 ; We = 5.0 ; Oh = 1e-2 ; Oha = 1e-2 * Oh ; De = 1.0 ; Ec = 1.0 ; init_grid ( 1 << 4 ); // Create a folder named intermediate where all the simulation snapshots are stored char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file sprintf ( dumpFile , \"restart\" ); // Set fluid properties for both phases rho1 = 1.0 , rho2 = 1e-3 ; mu1 = Oh / sqrt ( We ), mu2 = Oha / sqrt ( We ); G1 = Ec / We , G2 = 0.0 ; lambda1 = De * sqrt ( We ), lambda2 = 0.0 ; f . sigma = 1.0 / We ; run (); return 0 ; } Initialization Event Sets up the initial condition for the droplet and velocity field. The event initializes a spherical droplet using the VOF method and sets an initial horizontal velocity.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: If a restart...",
    "content": "If a restart file exists, the simulation state is restored from it instead. @param t Time (set to 0 for initialization) event init ( t = 0 ) { if (! restore ( file = dumpFile )) { refine ( R2 ( x , y , z ) < ( 1.1 ) && R2 ( x , y , z ) > ( 0.9 ) && level < MAXlevel ); fraction ( f , ( 1 - R2 ( x , y , z ))); foreach () { u . x [] = - f [] * 1.0 ; } } } Adaptive Mesh Refinement Refines the computational mesh based on wavelet error estimates for the tracked fields to efficiently allocate computational resources.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: JavaScript",
    "content": "The refinement criteria track errors in: - Volume fraction field (f) - Velocity components (u.x, u.y, u.z) @param i Current iteration number event adapt ( i ++) { adapt_wavelet (( scalar *){ f , u . x , u . y , u . z }, ( double []){ fErr , VelErr , VelErr , VelErr }, MAXlevel , 4 ); } Snapshot Writing Creates periodic dumps of the simulation state for visualization and restarts. @param t Current simulation time @param tsnap Time interval between snapshots @param tmax Maximum simulation time event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Simulation Termination Outputs final simulation parameters to standard error when the simulation ends. @param t End time event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); } Simulation Logging Records simulation progress and checks for numerical stability.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "This event: 1. Calculates the total kinetic energy of the system 2. Writes simulation data to the log file 3. Checks for numerical stability based on kinetic energy values 4.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Terminates the simulation...",
    "content": "Terminates the simulation if energy values indicate instability @param i Current iteration number @return Returns 1 (terminating the simulation) if instability is detected event logWriting ( i ++) { // Calculate kinetic energy double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 2 * pi * y ) * ( 0.5 * rho ( f []) * ( sq ( u . x []) + sq ( u . y []))) * sq ( Delta ); } static FILE * fp ; if ( pid () == 0 ) { const char * mode = ( i == 0 ) ? \"w\" : \"a\" ; fp = fopen ( logFile , mode ); if ( fp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } if ( i == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke \\n \" ); fprintf ( fp , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( fp , \"i dt t ke rM \\n \" ); } fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); fflush ( fp ); fclose ( fp ); } assert ( ke > - 1e-10 ); // Stability check based on kinetic energy if ( i > 1e1 && pid () == 0 ) { if ( ke > 1e2 || ke < 1e-8 ) { const char * message = ( ke > 1e2 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"Kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: C/C++ Code",
    "content": "// #include \"axi.h\"#include\"grid/octree.h\"// #include \"grid/quadtree.h\"#include\"navier-stokes/centered.h\"#define VANILLA036#if VANILLA#include\"log-conform-viscoelastic.h\"#define logFile\"logAxi-vanilla.dat\"39#else#if AXI#include\"log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"43#else#include\"log-conform-viscoelastic-scalar-3D.h\"#define logFile\"log3D-scalar.dat\"46#endif#endif#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define fErr(1e-3)71#define KErr(1e-6)72#define VelErr(1e-2)7374",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define xDist(5e-2)80#define R2(x,y,z)(sq(x-1.-xDist)+sq(y)+sq(z))8182",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "// u.t[left] = dirichlet(0.); // todo: later on use no-slip. For testing, free-slip is faster.// u.r[left] = dirichlet(0.); // todo: later on use no-slip. For testing, free-slip is faster.f[left]=dirichlet(0.0);",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intMAXlevel;doubleWe,Oh,Oha,De,Ec,tmax;charnameOut[80],dumpFile[80];",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intmain(intargc,charconst*argv[]){dtmax=1e-5;L0=4.0;// Values taken from the terminalMAXlevel=6;tmax=3.0;We=5.0;Oh=1e-2;Oha=1e-2*Oh;De=1.0;Ec=1.0;init_grid(1<<4);// Create a folder named intermediate where all the simulation snapshots are storedcharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart filesprintf(dumpFile,\"restart\");// Set fluid properties for both phasesrho1=1.0,rho2=1e-3;mu1=Oh/sqrt(We),mu2=Oha/sqrt(We);G1=Ec/We,G2=0.0;lambda1=De*sqrt(We),lambda2=0.0;f.sigma=1.0/We;run();return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z)<(1.1)&&R2(x,y,z)>(0.9)&&level<MAXlevel);fraction(f,(1-R2(x,y,z)));foreach(){u.x[]=-f[]*1.0;}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event adapt(i++){adapt_wavelet((scalar*){f,u.x,u.y,u.z},(double[]){fErr,VelErr,VelErr,VelErr},MAXlevel,4);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event logWriting(i++){// Calculate...",
    "content": "event logWriting(i++){// Calculate kinetic energydoubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])))*sq(Delta);}staticFILE*fp;if(pid()==0){constchar*mode=(i==0)?\"w\":\"a\";fp=fopen(logFile,mode);if(fp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}if(i==0){fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(ferr,\"i dt t ke\\n\");fprintf(fp,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(fp,\"i dt t ke rM\\n\");}fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);fflush(fp);fclose(fp);}assert(ke>-1e-10);// Stability check based on kinetic energyif(i>1e1&&pid()==0){if(ke>1e2||ke<1e-8){constchar*message=(ke>1e2)?\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Stopping simulation\\n\":\"Kinetic energy...",
    "content": "Stopping simulation\\n\":\"Kinetic energy too small now! Stopping!\\n\";fprintf(ferr,\"%s\",message);fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases dropAtomisation.c This file contains the simulation code for multiphase drop atomisation processes, with capabilities for both axisymme... dropImpact.c This file contains the simulation code for drop impact on a solid surface using a Volume of Fluid (VOF) method with v... pinchOff.c This file implements an axisymmetric simulation of the pinch-off dynamics of a viscoelastic liquid jet. The simulatio... testEigenDecomposition.c This module implements the diagonalization of 3D symmetric matrices through eigendecomposition, allowing the computat... verifyWtihPlots.ipynb This notebook provides visualization and analysis related to verifyWtihPlots.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/verifyWtihPlots.ipynb | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework",
    "content": "simulationCases/verifyWtihPlots.ipynb See raw file verifyWtihPlots.ipynb Jupyter Notebook: verifyWtihPlots.ipynb Download Notebook View in nbviewer Open in Colab About this notebook This notebook provides visualization and analysis related to verifyWtihPlots. Key Features: Visualization of data and results Analysis of simulation outputs Interactive exploration of parameters Tip: For the best interactive experience, download the notebook or open it in Google Colab. Notebook Preview Notebook Preview Unavailable The notebook preview could not be loaded. This may be because: The notebook file is not yet available in the repository The nbviewer service is temporarily unavailable The repository is private or has access restrictions You can still download the notebook using the button above or view it directly through one of the external services.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/verifyWtihPlots.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "simulationCases/pinchOff.c See raw file Viscoelastic Liquid Jet Pinch-Off Simulation This file implements an axisymmetric simulation of the pinch-off dynamics of a viscoelastic liquid jet. The simulation uses a two-phase approach with log-conformation formulation for the viscoelastic stress tensor.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The model incorporates:...",
    "content": "The model incorporates: - Axisymmetric Navier-Stokes equations - Log-conformation viscoelastic constitutive model - Two-phase interface with surface tension - Adaptive mesh refinement based on interface curvature and velocity gradients File Information File: pinchOff.c Version: 0.2 Author: Vatsal Sanjay Date: Oct 18, 2024 #include \"axi.h\" // #include \"grid/octree.h\" // #include \"grid/quadtree.h\" #include \"navier-stokes/centered.h\" #define VANILLA 1 26 #if VANILLA #include \"../src-local/log-conform-viscoelastic.h\" #define logFile \"logAxi-vanilla.dat\" 29 #else #if AXI #include \"../src-local/log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 33 #else #include \"../src-local/log-conform-viscoelastic-scalar-3D.h\" #define logFile \"log3D-scalar.dat\" 36 #endif #endif #define FILTERED // Smear density and viscosity jumps #include \"../src-local/two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" ## Simulation Parameters Configuration of time steps, error tolerances, and physical parameters.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Time between snapshots...",
    "content": "Time between snapshots #define tsnap ( 1e-2 ) 53 54 ### Error Tolerances fErr: Error tolerance in volume fraction field (f1 VOF) KErr: Error tolerance in interface curvature calculation using height function VelErr: Error tolerances in velocity field Use 1e-2 for low Oh (Ohnesorge number) cases Use 1e-3 to 5e-3 for high Oh/moderate to high J cases #define fErr ( 1e-3 ) 64 #define KErr ( 1e-6 ) 65 #define VelErr ( 1e-2 ) 66 67 ### Geometry Parameters Parameters defining the initial geometry of the liquid jet #define epsilon ( 0.5 ) 73 #define R2 ( x , y , z , e ) ( sqrt ( sq ( y ) + sq ( z )) + ( e * sin ( x / 4. ))) 74 75 ## Boundary Conditions Neumann boundary condition for velocity and Dirichlet for pressure at the top u . n [ top ] = neumann ( 0.0 ); p [ top ] = dirichlet ( 0.0 ); ## Global Variables MAXlevel: Maximum level of mesh refinement Oh: Ohnesorge number for the liquid phase (solvent) Oha: Ohnesorge number for the gas phase (air) De: Deborah number - ratio of relaxation time to flow time Ec: Elasto-capillary number - ratio of elastic to capillary forces int MAXlevel ; double Oh , Oha , De , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; ## Main Function Initializes the simulation parameters and starts the simulation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Sets domain size...",
    "content": "Sets domain size Configures physical parameters (Oh, De, Ec) Initializes grid Sets up file storage Configures material properties ### Parameters - argc: Command line argument count - argv: Command line argument values ### Returns - Exit status code int main ( int argc , char const * argv []) { L0 = 2 * pi ; // Values taken from the terminal MAXlevel = 6 ; tmax = 10 ; Oh = 1e-2 ; Oha = 1e-2 * Oh ; De = 1.0 ; // 1e-1; Ec = 1.0 ; // 1e-2; init_grid ( 1 << 4 ); // Create a folder named intermediate where all the simulation snapshots are stored char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file. See writingFiles event sprintf ( dumpFile , \"restart\" ); // Set material properties rho1 = 1. , rho2 = 1e-3 ; mu1 = Oh , mu2 = Oha ; lambda1 = De , lambda2 = 0. ; G1 = Ec , G2 = 0. ; f . sigma = 1.0 ; run (); } ## Initialization Event Sets up the initial condition for the simulation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Attempts to restore from a restart file if available Otherwise initializes the interface using the geometric function Refines the mesh around the interface ### Parameters - t: Simulation time (starts at 0) event init ( t = 0 ) { if (! restore ( file = dumpFile )) { refine ( R2 ( x , y , z , epsilon ) < ( 1 + epsilon ) && R2 ( x , y , z , epsilon ) > ( 1 - epsilon ) && level < MAXlevel ); fraction ( f , ( 1 - R2 ( x , y , z , epsilon ))); } } ## Adaptive Mesh Refinement Dynamically adjusts the mesh resolution based on interface curvature and flow features. Calculates interface curvature Refines mesh based on error criteria for volume fraction, velocity, and curvature fields ### Parameters - i: Iteration number event adapt ( i ++) { scalar KAPPA []; curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , u . x , u . y , KAPPA }, ( double []){ fErr , VelErr , VelErr , KErr }, MAXlevel , 4 ); } ## Snapshot Generation Saves the state of the simulation at regular intervals.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Creates a restart...",
    "content": "Creates a restart file for potential simulation recovery Generates a snapshot file with timestamped name ### Parameters - t: Simulation time (starts at 0, incremented by tsnap until tmax) event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } ## Simulation Termination Outputs final information when the simulation ends. Prints the maximum refinement level and Ohnesorge number ### Parameters - t: Simulation time (at end) event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , Oh %2.1e\\n \" , MAXlevel , Oh ); } ## Data Logging Records simulation statistics at each iteration.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Calculates total kinetic...",
    "content": "Calculates total kinetic energy Identifies the minimum position of the interface along the y-axis Writes data to the log file Checks for simulation stability based on kinetic energy ### Parameters - i: Iteration number ### Notes - Terminates the simulation if kinetic energy is too high (blow-up) or too low - Creates a final restart file if the simulation is terminated early event logWriting ( i ++) { // Calculate kinetic energy double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 2 * pi * y )*( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y [])+ sq ( u . z [])))* sq ( Delta ); } static FILE * fp ; if ( pid () == 0 ) { const char * mode = ( i == 0 ) ? \"w\" : \"a\" ; fp = fopen ( logFile , mode ); if ( fp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } // Find minimum position of interface along y-axis scalar pos []; position ( f , pos , { 0 , 1 , 0 }); double ymin = statsf ( pos ). min ; // Write header for first iteration if ( i == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke ymin \\n \" ); fprintf ( fp , \"Level %d , Oh %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , Oha , De , Ec ); fprintf ( fp , \"i dt t ke ymin \\n \" ); } // Write data row fprintf ( fp , \" %d %g %g %g %g\\n \" , i , dt , t , ke , ymin ); fprintf ( ferr , \" %d %g %g %g %g\\n \" , i , dt , t , ke , ymin ); fflush ( fp ); fclose ( fp ); } // Check for negative kinetic energy (should never happen) assert ( ke > - 1e-10 ); // Check for simulation stability after a few iterations if ( i > 1e1 && pid () == 0 ) { if ( ke > 1e2 || ke < 1e-8 ) { const char * message = ( ke > 1e2 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: C/C++ Code",
    "content": "#include\"axi.h\"// #include \"grid/octree.h\"// #include \"grid/quadtree.h\"#include\"navier-stokes/centered.h\"#define VANILLA126#if VANILLA#include\"../src-local/log-conform-viscoelastic.h\"#define logFile\"logAxi-vanilla.dat\"29#else#if AXI#include\"../src-local/log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"33#else#include\"../src-local/log-conform-viscoelastic-scalar-3D.h\"#define logFile\"log3D-scalar.dat\"36#endif#endif#define FILTERED// Smear density and viscosity jumps#include\"../src-local/two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define fErr(1e-3)64#define KErr(1e-6)65#define VelErr(1e-2)6667",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define epsilon(0.5)73#define R2(x,y,z,e)(sqrt(sq(y)+sq(z))+(e*sin(x/4.)))7475",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intMAXlevel;doubleOh,Oha,De,Ec,tmax;charnameOut[80],dumpFile[80];",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intmain(intargc,charconst*argv[]){L0=2*pi;// Values taken from the terminalMAXlevel=6;tmax=10;Oh=1e-2;Oha=1e-2*Oh;De=1.0;// 1e-1;Ec=1.0;// 1e-2;init_grid(1<<4);// Create a folder named intermediate where all the simulation snapshots are storedcharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file. See writingFiles eventsprintf(dumpFile,\"restart\");// Set material propertiesrho1=1.,rho2=1e-3;mu1=Oh,mu2=Oha;lambda1=De,lambda2=0.;G1=Ec,G2=0.;f.sigma=1.0;run();}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z,epsilon)<(1+epsilon)&&R2(x,y,z,epsilon)>(1-epsilon)&&level<MAXlevel);fraction(f,(1-R2(x,y,z,epsilon)));}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);adapt_wavelet((scalar*){f,u.x,u.y,KAPPA},(double[]){fErr,VelErr,VelErr,KErr},MAXlevel,4);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, Oh%2.1e\\n\",MAXlevel,Oh);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event logWriting(i++){// Calculate...",
    "content": "event logWriting(i++){// Calculate kinetic energydoubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])+sq(u.z[])))*sq(Delta);}staticFILE*fp;if(pid()==0){constchar*mode=(i==0)?\"w\":\"a\";fp=fopen(logFile,mode);if(fp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}// Find minimum position of interface along y-axisscalar pos[];position(f,pos,{0,1,0});doubleymin=statsf(pos).min;// Write header for first iterationif(i==0){fprintf(ferr,\"Level%d, Oh%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,Oha,De,Ec);fprintf(ferr,\"i dt t ke ymin\\n\");fprintf(fp,\"Level%d, Oh%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,Oha,De,Ec);fprintf(fp,\"i dt t ke ymin\\n\");}// Write data rowfprintf(fp,\"%d%g%g%g%g\\n\",i,dt,t,ke,ymin);fprintf(ferr,\"%d%g%g%g%g\\n\",i,dt,t,ke,ymin);fflush(fp);fclose(fp);}// Check for negative kinetic energy (should never happen)assert(ke>-1e-10);// Check for simulation stability after a few iterationsif(i>1e1&&pid()==0){if(ke>1e2||ke<1e-8){constchar*message=(ke>1e2)?\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Stopping simulation\\n\":\"kinetic energy...",
    "content": "Stopping simulation\\n\":\"kinetic energy too small now! Stopping!\\n\";fprintf(ferr,\"%s\",message);fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "simulationCases/dropAtomisation.c See raw file Drop Atomisation Simulation This file contains the simulation code for multiphase drop atomisation processes, with capabilities for both axisymmetric (2D) and full 3D simulations of viscoelastic fluid dynamics.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The physics model...",
    "content": "The physics model incorporates: - Two-phase flow with sharp interface tracking - Surface tension effects (parameterized by Weber number) - Viscous effects in both phases (parameterized by Ohnesorge numbers) - Optional viscoelastic behavior (controlled by Deborah and Elasto-capillary numbers) - Adaptive mesh refinement to efficiently resolve interfaces and high gradient regions File information File: dropAtomisation.c Author: Ayush Dixit & Vatsal Sanjay Version: 5.0 Date: Oct 20, 2024 // #include \"axi.h\" #include \"grid/octree.h\" // #include \"grid/quadtree.h\" #include \"navier-stokes/centered.h\" Viscoelastic Model Configuration Different implementations of the log-conformation viscoelastic model are available depending on simulation dimensionality: - VANILLA: Original implementation (2D only) - AXI: Axisymmetric scalar implementation - 3D: Full three-dimensional scalar implementation #define VANILLA 0 // vanilla cannot do 3D #if VANILLA #include \"log-conform-viscoelastic.h\" #define logFile \"logAxi-vanilla.dat\" 39 #else #if AXI #include \"log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 43 #else #include \"log-conform-viscoelastic-scalar-3D.h\" #define logFile \"log3D-scalar.dat\" 46 #endif #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" Simulation Parameters tsnap: Time interval between simulation snapshots Error tolerances: fErr: VOF function tolerance KErr: Curvature calculation tolerance VelErr: Velocity field tolerance AErr: Conformation tensor tolerance #define tsnap ( 0.1 ) // 0.001 only for some cases. // Error tolerances #define fErr ( 1e-2 ) // Error tolerance in f1 VOF #define KErr ( 1e-4 ) // Error tolerance in VoF curvature calculated using height function #define VelErr ( 1e-2 ) // Error tolerances in velocity // Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define AErr ( 1e-3 ) // Error tolerances in conformation inside the liquid Domain and Initial Condition R2 defines a spherical distance function from point (3,0,0) #define R2 ( x , y , z ) ( sq ( x - 3. ) + sq ( y ) + sq ( z )) 80 81 Boundary Conditions Left boundary: Inflow with fixed velocity Right boundary: Outflow with zero pressure // Inflow: left u . n [ left ] = dirichlet ( 1. ); // p[left] = dirichlet(0); // Outflow: right u . n [ right ] = neumann ( 0. ); p [ right ] = dirichlet ( 0 ); Global Variables MAXlevel: Maximum refinement level We: Weber number (ratio of inertial to surface tension forces) Oh: Solvent Ohnesorge number (ratio of viscous to inertial and surface forces) Oha: Air Ohnesorge number De: Deborah number (ratio of relaxation time to flow time) Ec: Elasto-capillary number (ratio of elastic to surface tension forces) RhoInOut: Density ratio between phases tmax: Maximum simulation time int MAXlevel ; double Oh , Oha , De , We , RhoInOut , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; Main Function Initializes the simulation domain, sets physical parameters, and starts the simulation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Parameters L0: Domain...",
    "content": "Parameters L0: Domain size RhoInOut: Density ratio between phases We, Oh, Oha: Dimensionless flow parameters De, Ec: Viscoelastic parameters @param argc Number of command line arguments @param argv Array of command line arguments @return Exit status int main ( int argc , char const * argv []) { // dtmax = 1e-5; // BEWARE of this for stability issues. L0 = 20 ; init_grid ( 1 << 6 ); origin ( 0 , - L0 / #if dimension == , - L0 / #endif ); // Values taken from the terminal MAXlevel = 7 ; RhoInOut = 830. ; // Elastic parts De = 0.0 ; Ec = 0.0 ; // Newtonian parts We = 15000 ; // Based on the density of the gas Oh = 3e-3 ; // Based on the density of the liquid Oha = 0.018 * Oh ; // Based on the density of the liquid tmax = 200 ; // Create a folder named intermediate where all the simulation snapshots are stored char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: See writingFiles event...",
    "content": "See writingFiles event sprintf ( dumpFile , \"restart\" ); // Phase properties rho1 = RhoInOut , rho2 = 1e0 ; // As both densities are based on the density of the liquid, we must multiply // the Ohnesorge number by the square root of the density ratio mu1 = sqrt ( RhoInOut )* Oh / sqrt ( We ), mu2 = sqrt ( RhoInOut )* Oha / sqrt ( We ); // Elastic parts // In G1, we need to multiply by the density ratio (again, because Ec is based // on the density of the liquid but in the code it is based on the density of the gas) G1 = Ec / We , G2 = 0.0 ; // Here, lambda is essentially the Weissenberg number, so there is no density // in the expression lambda1 = De * sqrt ( We ), lambda2 = 0.0 ; // Surface tension -- the Weber number is based on the density of the gas! f . sigma = 1.0 / We ; run (); } Initialization Sets up the initial condition as a spherical drop centered at (3,0,0) with radius 1, using adaptive mesh refinement to resolve the interface.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: If a restart...",
    "content": "If a restart file exists, the simulation state is loaded from it instead. event init ( t = 0 ) { if (! restore ( file = dumpFile )) { refine ( R2 ( x , y , z ) < 1.1 && R2 ( x , y , z ) > 0.9 && level < MAXlevel ); fraction ( f , 1. - R2 ( x , y , z )); } } Adaptive Mesh Refinement Dynamically refines the computational mesh based on error criteria for: - Volume fraction (f) - Interface curvature (KAPPA) - Velocity components (u.x, u.y, u.z) This ensures optimal resolution where needed while maintaining computational efficiency in regions with smooth solutions. event adapt ( i ++) { scalar KAPPA []; curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , KAPPA , u . x , u . y #if dimension == , u . z #endif }, ( double []){ fErr , KErr , VelErr , VelErr , #if dimension == VelErr #endif }, MAXlevel , 4 ); } Simulation Snapshots Periodically saves the full state of the simulation for: - Visualization - Analysis - Restart capability Files are saved in the \u2018intermediate\u2019 directory with timestamps. event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Simulation Termination Executed at the end of the simulation to print a summary of key parameters. event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); } Logging and Monitoring Tracks simulation progress and stability by: - Computing total kinetic energy - Writing timestep information - Monitoring for stability issues - Terminating if energy becomes too high (explosion) or too low (stagnation) Log files include: - Iteration number - Time step size - Current simulation time - Total kinetic energy event logWriting ( i ++) { // Calculate total kinetic energy double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y []) #if dimension == + sq ( u . z []) #endif ))* pow ( Delta , dimension ); } static FILE * fp ; if ( pid () == 0 ) { const char * mode = ( i == 0 ) ? \"w\" : \"a\" ; fp = fopen ( logFile , mode ); if ( fp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } if ( i == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke \\n \" ); fprintf ( fp , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( fp , \"i dt t ke rM \\n \" ); } fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); fflush ( fp ); fclose ( fp ); } assert ( ke > - 1e-10 ); // Check for simulation stability issues after initial iterations if ( i > 1e1 && pid () == 0 ) { if ( ke > 1e6 || ke < 1e-6 ) { const char * message = ( ke > 1e6 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"Kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "// #include \"axi.h\"#include\"grid/octree.h\"// #include \"grid/quadtree.h\"#include\"navier-stokes/centered.h\"",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#define VANILLA0// vanilla cannot do 3D#if VANILLA#include\"log-conform-viscoelastic.h\"#define logFile\"logAxi-vanilla.dat\"39#else#if AXI#include\"log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"43#else#include\"log-conform-viscoelastic-scalar-3D.h\"#define logFile\"log3D-scalar.dat\"46#endif#endif#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define tsnap(0.1)// 0.001 only for some cases.// Error tolerances#define fErr(1e-2)// Error tolerance in f1 VOF#define KErr(1e-4)// Error tolerance in VoF curvature calculated using height function#define VelErr(1e-2)// Error tolerances in velocity// Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J#define AErr(1e-3)// Error tolerances in conformation inside the liquid",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "// Inflow: leftu.n[left]=dirichlet(1.);// p[left] = dirichlet(0);// Outflow: rightu.n[right]=neumann(0.);p[right]=dirichlet(0);",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intMAXlevel;doubleOh,Oha,De,We,RhoInOut,Ec,tmax;charnameOut[80],dumpFile[80];",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: intmain(intargc,charconst*argv[]){// dtmax =...",
    "content": "intmain(intargc,charconst*argv[]){// dtmax = 1e-5; //  BEWARE of this for stability issues.L0=20;init_grid(1<<6);origin(0,-L0/#if dimension ==,-L0/#endif);// Values taken from the terminalMAXlevel=7;RhoInOut=830.;// Elastic partsDe=0.0;Ec=0.0;// Newtonian partsWe=15000;// Based on the density of the gasOh=3e-3;// Based on the density of the liquidOha=0.018*Oh;// Based on the density of the liquidtmax=200;// Create a folder named intermediate where all the simulation snapshots are storedcharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: See writingFiles eventsprintf(dumpFile,\"restart\");//...",
    "content": "See writingFiles eventsprintf(dumpFile,\"restart\");// Phase propertiesrho1=RhoInOut,rho2=1e0;// As both densities are based on the density of the liquid, we must multiply// the Ohnesorge number by the square root of the density ratiomu1=sqrt(RhoInOut)*Oh/sqrt(We),mu2=sqrt(RhoInOut)*Oha/sqrt(We);// Elastic parts// In G1, we need to multiply by the density ratio (again, because Ec is based// on the density of the liquid but in the code it is based on the density of the gas)G1=Ec/We,G2=0.0;// Here, lambda is essentially the Weissenberg number, so there is no density// in the expressionlambda1=De*sqrt(We),lambda2=0.0;// Surface tension -- the Weber number is based on the density of the gas!f.sigma=1.0/We;run();}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z)<1.1&&R2(x,y,z)>0.9&&level<MAXlevel);fraction(f,1.-R2(x,y,z));}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);adapt_wavelet((scalar*){f,KAPPA,u.x,u.y#if dimension ==,u.z#endif},(double[]){fErr,KErr,VelErr,VelErr,#if dimension ==VelErr#endif},MAXlevel,4);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event logWriting(i++){// Calculate...",
    "content": "event logWriting(i++){// Calculate total kinetic energydoubleke=0.;foreach(reduction(+:ke)){ke+=(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])#if dimension ==+sq(u.z[])#endif))*pow(Delta,dimension);}staticFILE*fp;if(pid()==0){constchar*mode=(i==0)?\"w\":\"a\";fp=fopen(logFile,mode);if(fp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}if(i==0){fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(ferr,\"i dt t ke\\n\");fprintf(fp,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(fp,\"i dt t ke rM\\n\");}fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);fflush(fp);fclose(fp);}assert(ke>-1e-10);// Check for simulation stability issues after initial iterationsif(i>1e1&&pid()==0){if(ke>1e6||ke<1e-6){constchar*message=(ke>1e6)?\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Stopping simulation\\n\":\"Kinetic energy...",
    "content": "Stopping simulation\\n\":\"Kinetic energy too small now! Stopping!\\n\";fprintf(ferr,\"%s\",message);fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData-elastic-scalar2D.c This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoela... getFacet2D.c A utility for extracting interface facets from fluid simulation data. VideoAxi.py Viscoelastic Visualization Tool =========================================== This script processes and visualizes flui...",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "postProcess/VideoAxi.py See raw file #!/usr/bin/env python3 # -*- coding: utf-8 -*- Viscoelastic Visualization Tool This script processes and visualizes fluid dynamics simulation data, particularly focused on droplet impact and deformable soft matter like liquid drops, sheets, and bubbles. It extracts interface positions and scalar field data from simulation files and creates visualizations showing physical quantities like strain rates and stresses. The script is designed to process multiple simulation snapshots in parallel, extracting data using external executables and generating visualizations with proper colormaps, scales, and mathematical labels.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Features: - Extracts...",
    "content": "Features: - Extracts fluid interfaces and scalar fields from simulation files - Generates visualizations with proper colormaps and mathematical labels - Processes multiple timesteps in parallel using multiprocessing - Configurable via command-line arguments for different simulation cases - Creates publication-quality figures with LaTeX-rendered mathematical expressions Usage: python fluid_vis.py [options] Command-line Arguments: \u2013CPUs Number of CPUs to use for parallel processing (default: all available) \u2013nGFS Number of restart files to process (default: 550) \u2013ZMAX Maximum Z coordinate for visualization (default: 4.0) \u2013RMAX Maximum R coordinate for visualization (default: 2.0) \u2013ZMIN Minimum Z coordinate for visualization (default: -4.0) \u2013caseToProcess Path to simulation case directory (default: \u2018../simulationCases/dropImpact\u2019) \u2013folderToSave Directory to save visualization images (default: \u2018dropImpact\u2019) Dependencies: External executables: getFacet2D, getData-elastic-scalar2D Python libraries: numpy, matplotlib, subprocess, multiprocessing Author: Vatsal Sanjay Email: vatsalsanjay@gmail.com Affiliation: Physics of Fluids Last updated: Jul 24, 2024 import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import multiprocessing as mp from functools import partial import argparse import matplotlib.colors as mcolors custom_colors = [ \"white\" , \"#DA8A67\" , \"#A0522D\" , \"#400000\" ] custom_cmap = mcolors.LinearSegmentedColormap.from_list( \"custom_hot\" , custom_colors) # Configure matplotlib for publication-quality figures with LaTeX rendering matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingFacets(filename, includeCoat = 'true' ): Extract interface positions (facets) from simulation files.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file includeCoat (str, optional): Whether to include coating layer. Defaults to \u2018true\u2019. Returns: list: List of line segments defining fluid interfaces exe = [ \"./getFacet2D\" , filename, includeCoat] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) skip = True return segs def gettingfield(filename, zmin, zmax, rmax, nr): Extract scalar field data from simulation files.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate rmax (float): Maximum R coordinate nr (int): Number of grid points in R direction Returns: tuple: (R, Z, D2, vel, taup, nz) arrays of coordinates and field values exe = [ \"./getData-elastic-scalar2D\" , filename, str (zmin), str ( 0 ), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, D2temp, veltemp, taupTemp = [],[],[],[],[] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) taupTemp.append( float (temp3[ 4 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) taup = np.asarray(taupTemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) taup.resize((nz, nr)) return R, Z, D2, vel, taup, nz # ---------------------------------------------------------------------------------------------------------------------- def process_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess): Process a single timestep from simulation data and generate visualization.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Args: ti (int):...",
    "content": "Args: ti (int): Timestep index folder (str): Directory to save output images nGFS (int): Total number of timesteps GridsPerR (int): Grid points per unit length in R direction rmin (float): Minimum R coordinate rmax (float): Maximum R coordinate zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate lw (float): Line width for plot elements caseToProcess (str): Path to simulation case directory t = 0.01 * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" if not os.path.exists(place): print ( f\" { place } File not found!\" ) return if os.path.exists(name): print ( f\" { name } Image present!\" ) return segs1 = gettingFacets(place) segs2 = gettingFacets(place, 'false' ) if not segs1 and not segs2: print ( f\"Problem in the available file { place } \" ) return nr = int (GridsPerR * rmax) R, Z, taus, vel, taup, nz = gettingfield(place, zmin, zmax, rmax, nr) zminp, zmaxp, rminp, rmaxp = Z. min (), Z. max (), R. min (), R. max () # Plotting AxesLabel, TickLabel = 50 , 20 fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) # Draw domain boundaries ax.plot([ 0 , 0 ], [zmin, zmax], '-.' , color = 'grey' , linewidth = lw) ax.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Add fluid interfaces line_segments = LineCollection(segs2, linewidths = 4 , colors = 'green' , linestyle = 'solid' ) ax.add_collection(line_segments) line_segments = LineCollection(segs1, linewidths = 4 , colors = 'blue' , linestyle = 'solid' ) ax.add_collection(line_segments) # Plot scalar fields with colormaps cntrl1 = ax.imshow(taus, cmap = \"hot_r\" , interpolation = 'Bilinear' , origin = 'lower' , extent = [ - rminp, - rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # TODO : fixme the colorbar bounds for taup must be set manually based on the simulated case. cntrl2 = ax.imshow(taup, interpolation = 'Bilinear' , cmap = custom_cmap, origin = 'lower' , extent = [rminp, rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # Set plot properties ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.set_title( f'$t/ \\\\ tau_ \\\\ gamma$ = { t :4.3f} ' , fontsize = TickLabel) # Add colorbars l, b, w, h = ax.get_position().bounds # Left colorbar cb1 = fig.add_axes([l - 0.04 , b, 0.03 , h]) c1 = plt.colorbar(cntrl1, cax = cb1, orientation = 'vertical' ) c1.set_label( r' $ \\ log_ {10} \\ left ( \\| \\m athcal{D} \\|\\r ight ) $ ' , fontsize = TickLabel, labelpad = 5 ) c1.ax.tick_params(labelsize = TickLabel) c1.ax.yaxis.set_ticks_position( 'left' ) c1.ax.yaxis.set_label_position( 'left' ) c1.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.1f} ' )) # Right colorbar cb2 = fig.add_axes([l + w + 0.01 , b, 0.03 , h]) c2 = plt.colorbar(cntrl2, cax = cb2, orientation = 'vertical' ) c2.ax.tick_params(labelsize = TickLabel) c2.set_label( r' $ \\ log_ {10} \\ left ( \\t ext{tr} \\ left ( \\m athcal{A} \\r ight ) -1 \\r ight ) $ ' , fontsize = TickLabel) c2.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.2f} ' )) ax.axis( 'off' ) plt.savefig(name, bbox_inches = \"tight\" ) plt.close() def main(): Main function that parses command-line arguments and parallelizes processing of timesteps. # Set up command-line argument parsing parser = argparse.ArgumentParser(description = 'Process fluid dynamics simulation data and create visualizations' ) parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use (default: all available)' ) parser.add_argument( '--nGFS' , type = int , default = 550 , help = 'Number of restart files to process (default: 550)' ) parser.add_argument( '--ZMAX' , type = float , default = 4.0 , help = 'Maximum Z value (default: 4.0)' ) parser.add_argument( '--RMAX' , type = float , default = 2.0 , help = 'Maximum R value (default: 2.0)' ) parser.add_argument( '--ZMIN' , type = float , default =- 4.0 , help = 'Minimum Z value (default: -4.0)' ) parser.add_argument( '--caseToProcess' , type = str , default = '../simulationCases/dropImpact' , help = 'Case to process (default: ../simulationCases/dropImpact)' ) parser.add_argument( '--folderToSave' , type = str , default = 'dropImpact' , help = 'Folder to save output images (default: dropImpact)' ) args = parser.parse_args() # Extract arguments CPUStoUse = args.CPUs nGFS = args.nGFS ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN num_processes = CPUStoUse rmin, rmax, zmin, zmax = [ - RMAX, RMAX, ZMIN, ZMAX] GridsPerR = 128 # Grid resolution parameter lw = 2 # Line width for plot elements folder = args.folderToSave caseToProcess = args.caseToProcess # Create output directory if it doesn't exist if not os.path.isdir(folder): os.makedirs(folder) # Create a pool of worker processes for parallel processing with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, folder = folder, nGFS = nGFS, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw, caseToProcess = caseToProcess) # Map the process_func to all timesteps pool. map (process_func, range (nGFS)) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportmultiprocessingasmpfromfunctoolsimportpartialimportargparseimportmatplotlib.colorsasmcolorscustom_colors=[\"white\",\"#DA8A67\",\"#A0522D\",\"#400000\"]custom_cmap=mcolors.LinearSegmentedColormap.from_list(\"custom_hot\", custom_colors)# Configure matplotlib for publication-quality figures with LaTeX renderingmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingFacets(filename, includeCoat='true'):",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "exe=[\"./getFacet2D\", filename, includeCoat]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, zmax, rmax, nr):",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "exe=[\"./getData-elastic-scalar2D\", filename,str(zmin),str(0),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, D2temp, veltemp, taupTemp=[],[],[],[],[]forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))taupTemp.append(float(temp3[4]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)taup=np.asarray(taupTemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))taup.resize((nz, nr))returnR, Z, D2, vel, taup, nz# ----------------------------------------------------------------------------------------------------------------------defprocess_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess):",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "t=0.01*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"ifnotos.path.exists(place):print(f\"{place}File not found!\")returnifos.path.exists(name):print(f\"{name}Image present!\")returnsegs1=gettingFacets(place)segs2=gettingFacets(place,'false')ifnotsegs1andnotsegs2:print(f\"Problem in the available file{place}\")returnnr=int(GridsPerR*rmax)R, Z, taus, vel, taup, nz=gettingfield(place, zmin, zmax, rmax, nr)zminp, zmaxp, rminp, rmaxp=Z.min(), Z.max(), R.min(), R.max()# PlottingAxesLabel, TickLabel=50,20fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)# Draw domain boundariesax.plot([0,0], [zmin, zmax],'-.', color='grey', linewidth=lw)ax.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Add fluid interfacesline_segments=LineCollection(segs2, linewidths=4, colors='green', linestyle='solid')ax.add_collection(line_segments)line_segments=LineCollection(segs1, linewidths=4, colors='blue', linestyle='solid')ax.add_collection(line_segments)# Plot scalar fields with colormapscntrl1=ax.imshow(taus, cmap=\"hot_r\", interpolation='Bilinear', origin='lower',extent=[-rminp,-rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)#TODO: fixme the colorbar bounds for taup must be set manually based on the simulated case.cntrl2=ax.imshow(taup, interpolation='Bilinear', cmap=custom_cmap, origin='lower',extent=[rminp, rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)# Set plot propertiesax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.set_title(f'$t/\\\\tau_\\\\gamma$ ={t:4.3f}', fontsize=TickLabel)# Add colorbarsl, b, w, h=ax.get_position().bounds# Left colorbarcb1=fig.add_axes([l-0.04, b,0.03, h])c1=plt.colorbar(cntrl1, cax=cb1, orientation='vertical')c1.set_label(r'$\\log_{10}\\left(\\|\\mathcal{D}\\|\\right)$', fontsize=TickLabel, labelpad=5)c1.ax.tick_params(labelsize=TickLabel)c1.ax.yaxis.set_ticks_position('left')c1.ax.yaxis.set_label_position('left')c1.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))# Right colorbarcb2=fig.add_axes([l+w+0.01, b,0.03, h])c2=plt.colorbar(cntrl2, cax=cb2, orientation='vertical')c2.ax.tick_params(labelsize=TickLabel)c2.set_label(r'$\\log_{10}\\left(\\text{tr}\\left(\\mathcal{A}\\right)-1\\right)$', fontsize=TickLabel)c2.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.2f}'))ax.axis('off')plt.savefig(name, bbox_inches=\"tight\")plt.close()defmain():",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: # Set up...",
    "content": "# Set up command-line argument parsingparser=argparse.ArgumentParser(description='Process fluid dynamics simulation data and create visualizations')parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use (default: all available)')parser.add_argument('--nGFS',type=int, default=550,help='Number of restart files to process (default: 550)')parser.add_argument('--ZMAX',type=float, default=4.0,help='Maximum Z value (default: 4.0)')parser.add_argument('--RMAX',type=float, default=2.0,help='Maximum R value (default: 2.0)')parser.add_argument('--ZMIN',type=float, default=-4.0,help='Minimum Z value (default: -4.0)')parser.add_argument('--caseToProcess',type=str,default='../simulationCases/dropImpact',help='Case to process (default: ../simulationCases/dropImpact)')parser.add_argument('--folderToSave',type=str, default='dropImpact',help='Folder to save output images (default: dropImpact)')args=parser.parse_args()# Extract argumentsCPUStoUse=args.CPUsnGFS=args.nGFSZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMINnum_processes=CPUStoUsermin, rmax, zmin, zmax=[-RMAX, RMAX, ZMIN, ZMAX]GridsPerR=128# Grid resolution parameterlw=2# Line width for plot elementsfolder=args.folderToSavecaseToProcess=args.caseToProcess# Create output directory if it doesn't existifnotos.path.isdir(folder):os.makedirs(folder)# Create a pool of worker processes for parallel processingwithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep,folder=folder, nGFS=nGFS,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw, caseToProcess=caseToProcess)# Map the process_func to all timestepspool.map(process_func,range(nGFS))if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "postProcess/getFacet2D.c See raw file Getting Facets A utility for extracting interface facets from fluid simulation data. Description This program extracts and outputs the facets representing the interface between different phases in a multiphase flow simulation. The facets define the boundary between fluid phases, useful for geometric analysis and visualization of the interface morphology. Physics Background In multiphase fluid simulations, interfaces between different fluids are critical features that determine many physical phenomena like surface tension effects, droplet formation, and coalescence events. This utility identifies these interfaces by extracting facets from volume fraction data, allowing for quantitative analysis of interfacial dynamics.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: C/C++ Code",
    "content": "Usage ./getFacets input_file Author: Vatsal Sanjay vatsalsanjay@gmail.com Physics of Fluids Department University of Twente #include \"utils.h\" #include \"output.h\" #include \"fractions.h\" scalar f []; // Volume fraction field char filename [ 80 ]; Main Function Loads a simulation snapshot and extracts the interface facets. Input parameters: arguments[1] : Filename of the simulation snapshot to process Process: Restores the simulation state from the specified file Extracts interface facets from the volume fraction field Outputs facet data to standard error Return value: Returns 0 on successful completion Note: The facet extraction algorithm identifies where the volume fraction field crosses a threshold value (typically 0.5) between adjacent cells. int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); FILE * fp = ferr ; output_facets ( f , fp ); fflush ( fp ); fclose ( fp ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"fractions.h\"scalar f[];// Volume fraction fieldcharfilename[80];",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);restore(file=filename);FILE*fp=ferr;output_facets(f,fp);fflush(fp);fclose(fp);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "postProcess/getData-elastic-scalar2D.c See raw file Simulation Data Extraction and Processing This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoelastic fluid simulations with conformation tensor analysis. It computes important derived quantities including deformation rate tensor components, velocity magnitude, and conformation tensor trace. The program interpolates these quantities onto a regular grid and outputs the results for further analysis or visualization. Physics Background This code handles viscoelastic fluid simulation data where the fluid stress tensor includes both a viscous component (proportional to the deformation rate) and an elastic component (represented by the conformation tensor).",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: C/C++ Code",
    "content": "The trace of the conformation tensor provides a measure of polymer stretching in the fluid. #include \"utils.h\" #include \"output.h\" scalar f []; // Volume fraction field vector u []; // Velocity field scalar A11 [], A12 [], A22 []; // Conformation tensor components scalar conform_qq []; // Additional conformation tensor component char filename [ 80 ]; // Input file name int nx , ny , len ; // Grid dimensions and field count double xmin , ymin , xmax , ymax , Deltax , Deltay ; // Domain boundaries and grid spacing Derived Fields D2c: Log10 of squared deformation rate tensor weighted by volume fraction vel: Magnitude of velocity trA: Log10 of excess trace of conformation tensor scalar D2c [], vel [], trA []; scalar * list = NULL ; // List to store output fields Main Function Processes simulation data and computes derived quantities Arguments: arguments[1]: Input filename arguments[2-5]: Domain boundaries (xmin, ymin, xmax, ymax) arguments[6]: Number of grid points in y-direction (ny) Returns: 0 on successful execution int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); // Initialize list of fields to output list = list_add ( list , D2c ); list = list_add ( list , vel ); list = list_add ( list , trA ); Data Processing Workflow Restore simulation state from snapshot file Compute derived quantities at each grid point Interpolate fields onto regular grid Output data to file restore ( file = filename ); Field Computation For each cell, compute: - Components of the deformation rate tensor D - Squared magnitude of D weighted by volume fraction - Velocity magnitude - Excess trace of the conformation tensor foreach () { // Compute deformation rate tensor components double D11 = ( u . y [ 0 , 1 ] - u . y [ 0 , - 1 ]) / ( 2 * Delta ); double D22 = ( u . y [] / y ); double D33 = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ]) / ( 2 * Delta ); double D13 = 0.5 * (( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 , - 1 ]) / ( 2 * Delta )); double D2 = ( sq ( D11 ) + sq ( D22 ) + sq ( D33 ) + 2.0 * sq ( D13 )); D2c [] = f [] * D2 ; // Take log10 of D2c for better visualization if ( D2c [] > 0. ) { D2c [] = log ( D2c []) / log ( 10 ); } else { D2c [] = - 10 ; } // Compute velocity magnitude vel [] = sqrt ( sq ( u . x []) + sq ( u . y [])); // Compute excess trace of conformation tensor trA [] = ( A11 [] + A22 [] + conform_qq []) / 3.0 - 1.0 ; // Take log10 of trA for better visualization if ( trA [] > 0. ) { trA [] = log ( trA []) / log ( 10 ); } else { trA [] = - 10 ; } } Grid Interpolation and Output Calculate grid spacing based on domain size and ny Allocate memory for interpolated field values Interpolate field values onto regular grid Output grid coordinates and field values FILE * fp = ferr ; Deltay = ( double )(( ymax - ymin ) / ( ny )); nx = ( int )(( xmax - xmin ) / Deltay ); Deltax = ( double )(( xmax - xmin ) / ( nx )); len = list_len ( list ); // Allocate memory for field values double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); // Interpolate field values onto regular grid for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ) { field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } // Output grid coordinates and field values for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ) { fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } // Clean up fflush ( fp ); fclose ( fp ); matrix_free ( field ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"scalar f[];// Volume fraction fieldvector u[];// Velocity fieldscalar A11[],A12[],A22[];// Conformation tensor componentsscalar conform_qq[];// Additional conformation tensor componentcharfilename[80];// Input file nameintnx,ny,len;// Grid dimensions and field countdoublexmin,ymin,xmax,ymax,Deltax,Deltay;// Domain boundaries and grid spacing",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "scalar D2c[],vel[],trA[];scalar*list=NULL;// List to store output fields",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);// Initialize list of fields to outputlist=list_add(list,D2c);list=list_add(list,vel);list=list_add(list,trA);",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: foreach(){// Compute deformation...",
    "content": "foreach(){// Compute deformation rate tensor componentsdoubleD11=(u.y[0,1]-u.y[0,-1])/(2*Delta);doubleD22=(u.y[]/y);doubleD33=(u.x[1,0]-u.x[-1,0])/(2*Delta);doubleD13=0.5*((u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(2*Delta));doubleD2=(sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13));D2c[]=f[]*D2;// Take log10 of D2c for better visualizationif(D2c[]>0.){D2c[]=log(D2c[])/log(10);}else{D2c[]=-10;}// Compute velocity magnitudevel[]=sqrt(sq(u.x[])+sq(u.y[]));// Compute excess trace of conformation tensortrA[]=(A11[]+A22[]+conform_qq[])/3.0-1.0;// Take log10 of trA for better visualizationif(trA[]>0.){trA[]=log(trA[])/log(10);}else{trA[]=-10;}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "FILE*fp=ferr;Deltay=(double)((ymax-ymin)/(ny));nx=(int)((xmax-xmin)/Deltay);Deltax=(double)((xmax-xmin)/(nx));len=list_len(list);// Allocate memory for field valuesdouble**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));// Interpolate field values onto regular gridfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}// Output grid coordinates and field valuesfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}// Clean upfflush(fp);fclose(fp);matrix_free(field);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files eigen_decomposition.h This module provides algorithms for computing eigenvalues and eigenvectors of 3x3 symmetric matrices, which are commo... log-conform-viscoelastic-scalar-2D.h Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materia... log-conform-viscoelastic-scalar-3D.h Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materia... log-conform-viscoelastic.h The implementation follows the standard log-conformation approach: 1. Uses tensor mathematics for clean formulation 2... two-phaseVE.h This is a modified version of [two-phase.h](http://basilisk.fr/src/two-phase.h). It contains the implementation of Vi...",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "src-local/log-conform-viscoelastic-scalar-3D.h See raw file Log-Conformation Method for 3D Viscoelastic Fluids Overview Title : log-conform-viscoelastic-3D.h Version : 2.6 Description : Implementation of the log-conformation method for viscoelastic fluids in 3D Key Features Conformation tensor A exists across the domain and relaxes according to \u03bb Stress acts according to elastic modulus G 3D implementation extending log-conform-viscoelastic-scalar-2D.h Eigenvalue clamping for numerical stability Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Mar 16, 2025 Dependencies bcg.h: Bell-Collela-Glaz scheme for advection eigen_decomposition.h: For 3D eigenvalue computation navier-stokes/centered.h: For base flow solver References Fattal & Kupferman (2004, 2005): Original log-conformation method Comminal et al. (2015): Constitutive model functions Hao & Pan (2007): Split scheme implementation Version History v1.0 (Oct 19, 2024) Initial 3D implementation Scalar implementation approach v1.1 (Oct 20, 2024) Added negative eigenvalue detection Added error reporting system v2.0 (Oct 29, 2024) Major matrix algebra corrections for 3D Optimized tensor calculations Improved code structure and documentation v2.1 (Oct 29, 2024) Added initialization functions for tensor structures v2.2 (Nov 3, 2024) Refactored tensor operations Improved code maintainability Enhanced tensor manipulation consistency v2.3 (Nov 14, 2024) Added infinite Deborah number support v2.5 (Nov 23, 2024) Documentation improvements Added mathematical explanations v2.6 (Mar 16, 2025) Implemented eigenvalue clamping system Added minimum eigenvalue threshold (EIGENVALUE_MIN = 1e-8) Improved numerical stability handling Added diagnostic capabilities Fixed 3D velocity gradient calculation Implementation Notes The code extends the standard Basilisk log-conformation implementation Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling with polymeric stress Includes both 2D and 3D implementations Uses atomic operations for thread-safe diagnostics Future Work Axisymmetric Compatibility Currently not implemented Use log-conform-viscoelastic-scalar-2D.h for axi cases Or use log-conform-viscoelastic.h for better efficiency Metric Terms Improvements Enforce tensor compatibility using foreach_dimension Complete metric terms (cm, fm) implementation #if AXI #error \"axi compatibility is not there.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Introduction",
    "content": "To keep the code easy to read, we will not implement axi compatibility just yet.\" #endif The log-conformation method for some viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function. The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In the case...",
    "content": "In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models. Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This instability poses...",
    "content": "This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) . /* TODO : - Perhaps, instead of the Bell--Collela--Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to [http://basilisk.fr/src/navier-stokes/conserving.h](http://basilisk.fr/src/navier-stokes/conserving.h) */ #define EIGENVALUE_MIN 1e-8 220 #ifdef DEBUG_EIGENVALUES static int eigenvalue_corrections = 0 ; #endif #include \"bcg.h\" ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time /* conformation tensor */ // diagonal elements scalar A11 [], A22 [], A33 []; // off-diagonal elements scalar A12 [], A13 [], A23 []; /* stress tensor */ // diagonal elements scalar T11 [], T22 [], T33 []; // off-diagonal elements scalar T12 [], T13 [], T23 []; event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; /* initialize A and T */ for ( scalar s in { A11 , A22 , A33 }) { foreach () { s [] = 1. ; } } for ( scalar s in { T11 , T12 , T13 , T22 , T23 , T33 , A12 , A13 , A23 }) { foreach (){ s [] = 0. ; } } for ( scalar s in { A11 , A22 , A33 , T11 , T22 , T33 , A12 , A13 , A23 , T12 , T13 , T23 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } if ( s . boundary [ top ] != periodic_bc ) { s [ top ] = neumann ( 0 ); s [ bottom ] = neumann ( 0 ); } #if dimension == if ( s . boundary [ front ] != periodic_bc ) { s [ front ] = neumann ( 0 ); s [ back ] = neumann ( 0 ); } #endif } } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. #if dimension == typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } #endif /* Now this is the 3D implementation. */ #if dimension == #include \"eigen_decomposition.h\" typedef struct { double x , y , z ; } pseudo_v3d ; typedef struct { pseudo_v3d x , y , z ; } pseudo_t3d ; // Function to initialize pseudo_v3d static inline void init_pseudo_v3d ( pseudo_v3d * v , double value ) { v -> x = value ; v -> y = value ; v -> z = value ; } // Function to initialize pseudo_t3d static inline void init_pseudo_t3d ( pseudo_t3d * t , double value ) { init_pseudo_v3d (& t -> x , value ); init_pseudo_v3d (& t -> y , value ); init_pseudo_v3d (& t -> z , value ); } static void diagonalization_3D ( pseudo_v3d * Lambda , pseudo_t3d * R , pseudo_t3d * A ) { // Check if the matrix is already diagonal if ( sq ( A -> x . y ) + sq ( A -> x . z ) + sq ( A -> y . z ) < 1e-15 ) { R -> x . x = R -> y . y = R -> z . z = 1. ; R -> y . x = R -> x . y = R -> z . x = R -> x . z = R -> z . y = R -> y . z = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; Lambda -> z = A -> z . z ; return ; } // Compute eigenvalues using the eigen_decomposition function double matrix [ 3 ][ 3 ] = { { A -> x . x , A -> x . y , A -> x . z }, { A -> y . x , A -> y . y , A -> y . z }, { A -> z . x , A -> z . y , A -> z . z } }; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); // Store eigenvalues and eigenvectors Lambda -> x = eigenvalues [ 0 ]; Lambda -> y = eigenvalues [ 1 ]; Lambda -> z = eigenvalues [ 2 ]; R -> x . x = eigenvectors [ 0 ][ 0 ]; R -> x . y = eigenvectors [ 0 ][ 1 ]; R -> x . z = eigenvectors [ 0 ][ 2 ]; R -> y . x = eigenvectors [ 1 ][ 0 ]; R -> y . y = eigenvectors [ 1 ][ 1 ]; R -> y . z = eigenvectors [ 1 ][ 2 ]; R -> z . x = eigenvectors [ 2 ][ 0 ]; R -> z . y = eigenvectors [ 2 ][ 1 ]; R -> z . z = eigenvectors [ 2 ][ 2 ]; } #endif The stress tensor depends on previous instants and has to be integrated in time.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In the log-conformation...",
    "content": "In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) . We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ). In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] #if dimension == Advances the log-conformation tensor and updates the corresponding conformation and stress tensors.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "This event function performs three primary steps within the viscoelastic fluid simulation: - Diagonalizes the conformation tensor and computes its logarithm (\u03a8) while applying eigenvalue clamping to ensure numerical stability. - Advances \u03a8 in time by incorporating the upper convective term computed from the velocity gradient, which is used to update the log-conformation tensor. - Recovers the physical conformation tensor and stress tensor by exponentiating the diagonalized eigenvalues and integrating the relaxation term.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Note: Although the...",
    "content": "Note: Although the overall simulation targets 3D viscoelastic fluids, this implementation uses a 2D diagonalization routine. event tracer_advection ( i ++) { scalar Psi11 = A11 ; scalar Psi12 = A12 ; scalar Psi22 = A22 ; Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A = {{ A11 [], A12 []}, { A12 [], A22 []}}; The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); pseudo_t R ; init_pseudo_t (& R , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This prevents numerical...",
    "content": "This prevents numerical instabilities while maintaining physical meaning. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"WARNING: Negative eigenvalue detected at ( %g , %g ): [ %g , %g ] \\n \" , x , y , Lambda . x , Lambda . y ); #ifdef DEBUG_EIGENVALUES atomic_increment (& eigenvalue_corrections ); #endif Lambda . x = max ( Lambda . x , EIGENVALUE_MIN ); Lambda . y = max ( Lambda . y , EIGENVALUE_MIN ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) . Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); Psi22 [] = sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . x )* log ( Lambda . x ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The diagonalization will...",
    "content": "The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis. Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: R is the eigenvector matrix of the conformation tensor M is the velocity gradient tensor in the eigenvector basis The construction ensures B is symmetric and traceless pseudo_t B ; init_pseudo_t (& B , 0.0 ); double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; init_pseudo_t (& M , 0.0 ); foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi12 []; Psi12 [] += dt * ( 2. * B . x . y + OM * ( Psi22 [] - Psi11 [])); s *= - 1 ; Psi11 [] += dt * 2. * ( B . x . x + s * OM ); s *= - 1 ; Psi22 [] += dt * 2. * ( B . y . y + s * OM ); } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . advection ({ Psi11 , Psi12 , Psi22 }, uf , dt ); Convert back to Aij foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi11 [], Psi12 []}, { Psi12 [], Psi22 []}}, R ; init_pseudo_t (& R , 0.0 ); pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . A12 [] = A . x . y ; T12 [] = Gp []* A . x . y ; A11 [] = A . x . x ; T11 [] = Gp []*( A . x . x - 1. ); A22 [] = A . y . y ; T22 [] = Gp []*( A . y . y - 1. ); } } #elif dimension == Advances the log-conformation tensor and computes the corresponding conformation and stress tensors for 3D viscoelastic fluid simulations. This event function performs a two-step update for the viscoelastic fluid model using the log-conformation method.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In the first...",
    "content": "In the first part, it computes the logarithm of the conformation tensor \\(\\Psi\\) from A by: - Diagonalizing A to obtain eigenvalues ( \\(\\Lambda\\) ) and eigenvectors (R). - Clamping any negative eigenvalues to prevent numerical instabilities (using EIGENVALUE_MIN). - Evaluating \\(\\Psi = \\log(A)\\) and incorporating the upper convective contribution via the symmetric tensor B and the skew-symmetric tensor \\(\\Omega\\) . \\(\\Psi\\) is then advanced in time using central difference approximations for the velocity gradients, where degenerate eigenvalue cases are handled with simplified calculations. In the second part, the function converts the updated log-conformation tensor back to the conformation tensor A by exponentiating the eigenvalues and applies the relaxation factor derived from the relaxation time. Finally, it computes the polymeric stress tensor T from A.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Warnings are printed...",
    "content": "Warnings are printed if negative eigenvalues are detected, and a debug counter is incremented when debugging is enabled. event tracer_advection ( i ++) { Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term // start by declaring the scalar variables that will store the components of $\\Psi$ scalar Psi11 = A11 , Psi12 = A12 , Psi13 = A13 , Psi22 = A22 , Psi23 = A23 , Psi33 = A33 ; foreach () { pseudo_t3d A , R ; init_pseudo_t3d (& R , 0.0 ); pseudo_v3d Lambda ; init_pseudo_v3d (& Lambda , 0.0 ); A . x . x = A11 []; A . x . y = A12 []; A . x . z = A13 []; A . y . x = A12 []; A . y . y = A22 []; A . y . z = A23 []; A . z . x = A13 []; A . z . y = A23 []; A . z . z = A33 []; // Diagonalize the conformation tensor A to obtain the eigenvalues Lambda and eigenvectors R diagonalization_3D (& Lambda , & R , & A ); /* Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This prevents numerical...",
    "content": "This prevents numerical instabilities while maintaining physical meaning. */ if ( Lambda . x <= 0. || Lambda . y <= 0. || Lambda . z <= 0. ) { fprintf ( ferr , \"WARNING: Negative eigenvalue detected at ( %g , %g , %g ): [ %g , %g , %g ] \\n \" , x , y , z , Lambda . x , Lambda . y , Lambda . z ); #ifdef DEBUG_EIGENVALUES atomic_increment (& eigenvalue_corrections ); #endif Lambda . x = max ( Lambda . x , EIGENVALUE_MIN ); Lambda . y = max ( Lambda . y , EIGENVALUE_MIN ); Lambda . z = max ( Lambda . z , EIGENVALUE_MIN ); } // Compute Psi = log(A) = R * log(Lambda) * R^T Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ) + sq ( R . x . z )* log ( Lambda . z ); Psi22 [] = sq ( R . y . x )* log ( Lambda . x ) + sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . z )* log ( Lambda . z ); Psi33 [] = sq ( R . z . x )* log ( Lambda . x ) + sq ( R . z . y )* log ( Lambda . y ) + sq ( R . z . z )* log ( Lambda . z ); Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . x . y * R . y . y * log ( Lambda . y ) + R . x . z * R . y . z * log ( Lambda . z ); Psi13 [] = R . x . x * R . z . x * log ( Lambda . x ) + R . x . y * R . z . y * log ( Lambda . y ) + R . x . z * R . z . z * log ( Lambda . z ); Psi23 [] = R . y . x * R . z . x * log ( Lambda . x ) + R . y . y * R . z . y * log ( Lambda . y ) + R . y . z * R . z . z * log ( Lambda . z ); // Compute B and Omega tensors (3D version) pseudo_t3d B , M , Omega ; init_pseudo_t3d (& B , 0.0 ); init_pseudo_t3d (& M , 0.0 ); init_pseudo_t3d (& Omega , 0.0 ); // Check if any pair of eigenvalues are numerically equal (within a small tolerance) if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 || fabs ( Lambda . y - Lambda . z ) <= 1e-20 || fabs ( Lambda . z - Lambda . x ) <= 1e-20 ) { // In case of equal eigenvalues, the calculations for B and Omega simplify significantly // B is grad U and Omega is zero. // Compute off-diagonal elements of B using central differences // These represent the symmetric part of the velocity gradient tensor B . x . y = ( u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ] + u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ])/( 4. * Delta ); // (dv/dx + du/dy)/2 B . x . z = ( u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ] + u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ])/( 4. * Delta ); // (dw/dx + du/dz)/2 B . y . z = ( u . z [ 0 , 1 , 0 ] - u . z [ 0 ,- 1 , 0 ] + u . y [ 0 , 0 , 1 ] - u . y [ 0 , 0 ,- 1 ])/( 4. * Delta ); // (dw/dy + dv/dz)/2 // Compute diagonal elements of B // These represent the normal strain rates B . x . x = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ])/( 2. * Delta ); // du/dx B . y . y = ( u . y [ 0 , 1 , 0 ] - u . y [ 0 ,- 1 , 0 ])/( 2. * Delta ); // dv/dy B . z . z = ( u . z [ 0 , 0 , 1 ] - u . z [ 0 , 0 ,- 1 ])/( 2. * Delta ); // dw/dz // Set all components of Omega to zero // This is because Omega represents the antisymmetric part of the velocity gradient tensor, // which vanishes when eigenvalues are equal Omega . x . y = Omega . x . z = Omega . y . z = Omega . y . x = Omega . z . x = Omega . z . y = 0. ; } else { /* ### Compute the velocity gradient tensor components using central differences - These represent the spatial derivatives of each velocity component - These gradients form the velocity gradient tensor (nablaU): [ dudx dudy dudz ] [ dvdx dvdy dvdz ] [ dwdx dwdy dwdz ] */ // Derivatives of u (x-component of velocity) double dudx = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ])/( 2.0 * Delta ); // du/dx double dudy = ( u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // du/dy double dudz = ( u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // du/dz // Derivatives of v (y-component of velocity) double dvdx = ( u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ])/( 2.0 * Delta ); // dv/dx double dvdy = ( u . y [ 0 , 1 , 0 ] - u . y [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // dv/dy double dvdz = ( u . y [ 0 , 0 , 1 ] - u . y [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // dv/dz // Derivatives of w (z-component of velocity) double dwdx = ( u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ])/( 2.0 * Delta ); // dw/dx double dwdy = ( u . z [ 0 , 1 , 0 ] - u . z [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // dw/dy double dwdz = ( u . z [ 0 , 0 , 1 ] - u . z [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // dw/dz /* Calculate the M tensor through matrix multiplication: M = R * (nablaU)^T R^T.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This represents the...",
    "content": "This represents the velocity gradient tensor transformed to the eigenvector basis of the conformation tensor. * Steps: 1. Compute intermediate products (R * nablaU^T): - Store row-wise products in Rx_gradU_*, Ry_gradU_*, Rz_gradU_* - Each variable represents one row of the intermediate matrix 2.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Multiply by R^T...",
    "content": "Multiply by R^T to obtain the final M tensor: - M.i.j represents the (i,j) component of the transformed velocity gradient - This transformation expresses the velocity gradient in the eigenvector basis - The resulting M tensor is used to compute Omega (\u03a9) and B tensors, such that */ // First, compute intermediate products of R and (nablaU)^T double Rx_gradU_x = R . x . x * dudx + R . x . y * dvdx + R . x . z * dwdx ; double Rx_gradU_y = R . x . x * dudy + R . x . y * dvdy + R . x . z * dwdy ; double Rx_gradU_z = R . x . x * dudz + R . x . y * dvdz + R . x . z * dwdz ; double Ry_gradU_x = R . y . x * dudx + R . y . y * dvdx + R . y . z * dwdx ; double Ry_gradU_y = R . y . x * dudy + R . y . y * dvdy + R . y . z * dwdy ; double Ry_gradU_z = R . y . x * dudz + R . y . y * dvdz + R . y . z * dwdz ; double Rz_gradU_x = R . z . x * dudx + R . z . y * dvdx + R . z . z * dwdx ; double Rz_gradU_y = R . z . x * dudy + R . z . y * dvdy + R . z . z * dwdy ; double Rz_gradU_z = R . z . x * dudz + R . z . y * dvdz + R . z . z * dwdz ; // Now compute M components by multiplying the intermediate products with R^T M . x . x = R . x . x * Rx_gradU_x + R . x . y * Rx_gradU_y + R . x . z * Rx_gradU_z ; M . x . y = R . x . x * Ry_gradU_x + R . x . y * Ry_gradU_y + R . x . z * Ry_gradU_z ; M . x . z = R . x . x * Rz_gradU_x + R . x . y * Rz_gradU_y + R . x . z * Rz_gradU_z ; M . y . x = R . y . x * Rx_gradU_x + R . y . y * Rx_gradU_y + R . y . z * Rx_gradU_z ; M . y . y = R . y . x * Ry_gradU_x + R . y . y * Ry_gradU_y + R . y . z * Ry_gradU_z ; M . y . z = R . y . x * Rz_gradU_x + R . y . y * Rz_gradU_y + R . y . z * Rz_gradU_z ; M . z . x = R . z . x * Rx_gradU_x + R . z . y * Rx_gradU_y + R . z . z * Rx_gradU_z ; M . z . y = R . z . x * Ry_gradU_x + R . z . y * Ry_gradU_y + R . z . z * Ry_gradU_z ; M . z . z = R . z . x * Rz_gradU_x + R . z . y * Rz_gradU_y + R . z . z * Rz_gradU_z ; // Compute the off-diagonal elements of the Omega tensor in the eigenvector basis double omega_xy = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); double omega_xz = ( Lambda . z * M . x . z + Lambda . x * M . z . x )/( Lambda . z - Lambda . x ); double omega_yz = ( Lambda . z * M . y . z + Lambda . y * M . z . y )/( Lambda . z - Lambda . y ); // Calculate intermediate rotation combinations for each direction // x-direction rotation combinations double rot_x_xy_yz = ( R . x . x * omega_xy - R . x . z * omega_yz ); // xy rotation minus yz rotation, x components double rot_x_xy_xz = ( R . x . y * omega_xy + R . x . z * omega_xz ); // xy rotation plus xz rotation, x components double rot_x_xz_yz = ( R . x . x * omega_xz + R . x . y * omega_yz ); // xz rotation plus yz rotation, x components // y-direction rotation combinations double rot_y_xy_yz = ( R . y . x * omega_xy - R . y . z * omega_yz ); // xy rotation minus yz rotation, y components double rot_y_xy_xz = ( R . y . y * omega_xy + R . y . z * omega_xz ); // xy rotation plus xz rotation, y components double rot_y_xz_yz = ( R . y . x * omega_xz + R . y . y * omega_yz ); // xz rotation plus yz rotation, y components // z-direction rotation combinations double rot_z_xy_yz = ( R . z . x * omega_xy - R . z . z * omega_yz ); // xy rotation minus yz rotation, z components double rot_z_xy_xz = ( R . z . y * omega_xy + R . z . z * omega_xz ); // xy rotation plus xz rotation, z components double rot_z_xz_yz = ( R . z . x * omega_xz + R . z . y * omega_yz ); // xz rotation plus yz rotation, z components Calculate the components of the Omega tensor in the physical coordinate system The Omega tensor represents the rotational part of the velocity gradient tensor and is computed through the following steps: We already have: R: eigenvector matrix of the conformation tensor rot_*_*_*: pre-computed rotation combinations for each direction Mathematical background: Omega = R * Omega_eigen * R^T where Omega_eigen is the rotation tensor in eigenvector space The components are calculated using the rotation combinations: rot_i_jk_lm represents combined rotations in the i-direction Each component Omega_ij is a linear combination of these rotations // Compute x-row components of Omega Omega . x . x = R . x . y * rot_x_xy_yz // xy-yz rotation contribution - R . x . x * rot_x_xy_xz // xy-xz rotation contribution + R . x . z * rot_x_xz_yz ; // xz-yz rotation contribution Omega . x . y = R . y . y * rot_x_xy_yz // xy-yz rotation mapped to y-direction - R . y . x * rot_x_xy_xz // xy-xz rotation mapped to y-direction + R . y . z * rot_x_xz_yz ; // xz-yz rotation mapped to y-direction Omega . x . z = R . z . y * rot_x_xy_yz // xy-yz rotation mapped to z-direction - R . z . x * rot_x_xy_xz // xy-xz rotation mapped to z-direction + R . z . z * rot_x_xz_yz ; // xz-yz rotation mapped to z-direction // Compute y-row components using similar pattern Omega . y . x = R . x . y * rot_y_xy_yz - R . x . x * rot_y_xy_xz + R . x . z * rot_y_xz_yz ; Omega . y . y = R . y . y * rot_y_xy_yz - R . y . x * rot_y_xy_xz + R . y . z * rot_y_xz_yz ; Omega . y . z = R . z . y * rot_y_xy_yz - R . z . x * rot_y_xy_xz + R . z . z * rot_y_xz_yz ; // Compute z-row components using similar pattern Omega . z . x = R . x . y * rot_z_xy_yz - R . x . x * rot_z_xy_xz + R . x . z * rot_z_xz_yz ; Omega . z . y = R . y . y * rot_z_xy_yz - R . y . x * rot_z_xy_xz + R . y . z * rot_z_xz_yz ; Omega . z . z = R . z . y * rot_z_xy_yz - R . z . x * rot_z_xy_xz + R . z . z * rot_z_xz_yz ; Note: The resulting Omega tensor is skew-symmetric, meaning: - Omega_ij = -Omega_ji This property is automatically satisfied by the construction above and is essential for preserving the physical meaning of rotation // Extract diagonal components of M (velocity gradient tensor in eigenvector basis) double M_diag_x = M . x . x , M_diag_y = M . y . y , M_diag_z = M . z . z ; Compute B tensor: B = R * diag(M) * R^T - This transforms the diagonal velocity gradient tensor back to the original coordinate system - B is symmetric, so we only need to compute the upper triangle // Compute diagonal elements of B B . x . x = M_diag_x * sq ( R . x . x ) + M_diag_y * sq ( R . x . y ) + M_diag_z * sq ( R . x . z ); B . y . y = M_diag_x * sq ( R . y . x ) + M_diag_y * sq ( R . y . y ) + M_diag_z * sq ( R . y . z ); B . z . z = M_diag_x * sq ( R . z . x ) + M_diag_y * sq ( R . z . y ) + M_diag_z * sq ( R . z . z ); // Compute off-diagonal elements of B (upper triangle) B . x . y = M_diag_x * R . x . x * R . y . x + M_diag_y * R . x . y * R . y . y + M_diag_z * R . x . z * R . y . z ; B . x . z = M_diag_x * R . x . x * R . z . x + M_diag_y * R . x . y * R . z . y + M_diag_z * R . x . z * R . z . z ; B . y . z = M_diag_x * R . y . x * R . z . x + M_diag_y * R . y . y * R . z . y + M_diag_z * R . y . z * R . z . z ; // Fill in lower triangle using symmetry of B B . y . x = B . x . y ; B . z . x = B . x . z ; B . z . y = B . y . z ; } We now advance \\(\\Psi\\) in time, adding the upper convective contribution.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This step 1:...",
    "content": "This step 1: _t = 2 + (-) // save old values of Psi components double old_Psi11 = Psi11 []; double old_Psi22 = Psi22 []; double old_Psi33 = Psi33 []; double old_Psi12 = Psi12 []; double old_Psi13 = Psi13 []; double old_Psi23 = Psi23 []; // Psi11 Psi11 [] += dt * ( 2.0 * B . x . x + Omega . x . y * old_Psi12 - Omega . y . x * old_Psi12 + Omega . x . z * old_Psi13 - Omega . z . x * old_Psi13 ); // Psi22 Psi22 [] += dt * ( 2.0 * B . y . y - Omega . x . y * old_Psi12 + Omega . y . x * old_Psi12 + Omega . y . z * old_Psi23 - Omega . z . y * old_Psi23 ); // Psi33 Psi33 [] += dt * ( 2.0 * B . z . z - Omega . x . z * old_Psi13 + Omega . z . x * old_Psi13 - Omega . y . z * old_Psi23 + Omega . z . y * old_Psi23 ); // Psi12 Psi12 [] += dt * ( 2.0 * B . x . y + Omega . x . x * old_Psi12 - Omega . x . y * old_Psi11 + Omega . x . y * old_Psi22 - Omega . y . y * old_Psi12 + Omega . x . z * old_Psi23 - Omega . z . y * old_Psi13 ); // Psi13 Psi13 [] += dt * ( 2.0 * B . x . z + Omega . x . x * old_Psi13 - Omega . x . z * old_Psi11 + Omega . x . y * old_Psi23 - Omega . y . z * old_Psi12 + Omega . x . z * old_Psi33 - Omega . z . z * old_Psi13 ); // Psi23 Psi23 [] += dt * ( 2.0 * B . y . z + Omega . y . x * old_Psi13 - Omega . x . z * old_Psi12 + Omega . y . y * old_Psi23 - Omega . y . z * old_Psi22 + Omega . y . z * old_Psi33 - Omega . z . z * old_Psi23 ); } // Advection of Psi, which is the log-conformation tensor advection ({ Psi11 , Psi12 , Psi13 , Psi22 , Psi23 , Psi33 }, uf , dt ); Convert back to A and T We now convert the log-conformation tensor Psi back to the conformation tensor A and compute the stress tensor T.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This process involves...",
    "content": "This process involves diagonalization, exponentiation of eigenvalues, and application of the relaxation factor. foreach () { pseudo_t3d A , R ; init_pseudo_t3d (& R , 0.0 ); pseudo_v3d Lambda ; init_pseudo_v3d (& Lambda , 0.0 ); // Reconstruct the log-conformation tensor from its components A . x . x = Psi11 []; A . x . y = Psi12 []; A . x . z = Psi13 []; A . y . x = Psi12 []; A . y . y = Psi22 []; A . y . z = Psi23 []; A . z . x = Psi13 []; A . z . y = Psi23 []; A . z . z = Psi33 []; // Diagonalize A to obtain eigenvalues and eigenvectors diagonalization_3D (& Lambda , & R , & A ); // Exponentiate eigenvalues Lambda . x = exp ( Lambda . x ); Lambda . y = exp ( Lambda . y ); Lambda . z = exp ( Lambda . z ); // Reconstruct A using A = R * diag(Lambda) * R^T A . x . x = Lambda . x * sq ( R . x . x ) + Lambda . y * sq ( R . x . y ) + Lambda . z * sq ( R . x . z ); A . x . y = Lambda . x * R . x . x * R . y . x + Lambda . y * R . x . y * R . y . y + Lambda . z * R . x . z * R . y . z ; A . y . x = A . x . y ; A . x . z = Lambda . x * R . x . x * R . z . x + Lambda . y * R . x . y * R . z . y + Lambda . z * R . x . z * R . z . z ; A . z . x = A . x . z ; A . y . y = Lambda . x * sq ( R . y . x ) + Lambda . y * sq ( R . y . y ) + Lambda . z * sq ( R . y . z ); A . y . z = Lambda . x * R . y . x * R . z . x + Lambda . y * R . y . y * R . z . y + Lambda . z * R . y . z * R . z . z ; A . z . y = A . y . z ; A . z . z = Lambda . x * sq ( R . z . x ) + Lambda . y * sq ( R . z . y ) + Lambda . z * sq ( R . z . z ); // Apply relaxation using the relaxation time lambda double intFactor = lambda [] != 0. ? exp (- dt / lambda []) : 0. ; A . x . y *= intFactor ; A . y . x = A . x . y ; A . x . z *= intFactor ; A . z . x = A . x . z ; A . y . z *= intFactor ; A . z . y = A . y . z ; foreach_dimension () A . x . x = 1. + ( A . x . x - 1. )* intFactor ; Get Aij from A.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: These commands might...",
    "content": "These commands might look repetitive. But, I do this so that in the future, generalization to tensor only form is easier. // diagonal terms: A11 [] = A . x . x ; A22 [] = A . y . y ; A33 [] = A . z . z ; // off-diagonal terms: A12 [] = A . x . y ; A13 [] = A . x . z ; A23 [] = A . y . z ; // Compute the stress tensor T using the polymer modulus Gp T11 [] = Gp []*( A . x . x - 1. ); T22 [] = Gp []*( A . y . y - 1. ); T33 [] = Gp []*( A . z . z - 1. ); T12 [] = Gp []* A . x . y ; T13 [] = Gp []* A . x . z ; T23 [] = Gp []* A . y . z ; } } #endif Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{T}\\) is defined at cell centers, while the corresponding force (acceleration) is defined at cell faces. For each component of the momentum equation, we need to compute the divergence of the corresponding row of the stress tensor.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "For example, for the x-component in 3D: \\[ (\\nabla \\cdot \\mathbf{T})_x = \\partial_x T_{xx} + \\partial_y T_{xy} + \\partial_z T_{xz} \\] The normal stress gradient (e.g. \\(\\partial_x T_{xx}\\) ) is computed directly from cell-centered values.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The shear stress...",
    "content": "The shear stress gradients (e.g. \\(\\partial_y T_{xy}\\) ) are computed using vertex-averaged values to avoid checkerboard instabilities. event acceleration ( i ++) { face vector av = a ; #if dimension == // 2D implementation foreach_face ( x ) { if ( fm . x [] > 1e-20 ) { // y-gradient of T12 (shear stress) double shearX = ( T12 [ 0 , 1 ]* cm [ 0 , 1 ] + T12 [- 1 , 1 ]* cm [- 1 , 1 ] - T12 [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; // x-gradient of T11 (normal stress) double gradX_T11 = cm []* T11 [] - cm [- 1 ]* T11 [- 1 ]; av . x [] += ( shearX + gradX_T11 )* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ) { if ( fm . y [] > 1e-20 ) { // x-gradient of T12 (shear stress) double shearY = ( T12 [ 1 , 0 ]* cm [ 1 , 0 ] + T12 [ 1 ,- 1 ]* cm [ 1 ,- 1 ] - T12 [- 1 , 0 ]* cm [- 1 , 0 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; // y-gradient of T22 (normal stress) double gradY_T22 = cm []* T22 [] - cm [ 0 ,- 1 ]* T22 [ 0 ,- 1 ]; av . y [] += ( shearY + gradY_T22 )* alpha . y []/( sq ( fm . y [])* Delta ); } } #elif dimension == // 3D implementation foreach_face ( x ) { if ( fm . x [] > 1e-20 ) { // y-gradient of T12 double shearY = ( T12 [ 0 , 1 , 0 ]* cm [ 0 , 1 , 0 ] + T12 [- 1 , 1 , 0 ]* cm [- 1 , 1 , 0 ] - T12 [ 0 ,- 1 , 0 ]* cm [ 0 ,- 1 , 0 ] - T12 [- 1 ,- 1 , 0 ]* cm [- 1 ,- 1 , 0 ])/ 4. ; // z-gradient of T13 double shearZ = ( T13 [ 0 , 0 , 1 ]* cm [ 0 , 0 , 1 ] + T13 [- 1 , 0 , 1 ]* cm [- 1 , 0 , 1 ] - T13 [ 0 , 0 ,- 1 ]* cm [ 0 , 0 ,- 1 ] - T13 [- 1 , 0 ,- 1 ]* cm [- 1 , 0 ,- 1 ])/ 4. ; // x-gradient of T11 double gradX_T11 = cm []* T11 [] - cm [- 1 , 0 , 0 ]* T11 [- 1 , 0 , 0 ]; av . x [] += ( shearY + shearZ + gradX_T11 )* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ) { if ( fm . y [] > 1e-20 ) { // x-gradient of T12 double shearX = ( T12 [ 1 , 0 , 0 ]* cm [ 1 , 0 , 0 ] + T12 [ 1 ,- 1 , 0 ]* cm [ 1 ,- 1 , 0 ] - T12 [- 1 , 0 , 0 ]* cm [- 1 , 0 , 0 ] - T12 [- 1 ,- 1 , 0 ]* cm [- 1 ,- 1 , 0 ])/ 4. ; // z-gradient of T23 double shearZ = ( T23 [ 0 , 0 , 1 ]* cm [ 0 , 0 , 1 ] + T23 [ 0 ,- 1 , 1 ]* cm [ 0 ,- 1 , 1 ] - T23 [ 0 , 0 ,- 1 ]* cm [ 0 , 0 ,- 1 ] - T23 [ 0 ,- 1 ,- 1 ]* cm [ 0 ,- 1 ,- 1 ])/ 4. ; // y-gradient of T22 double gradY_T22 = cm []* T22 [] - cm [ 0 ,- 1 , 0 ]* T22 [ 0 ,- 1 , 0 ]; av . y [] += ( shearX + shearZ + gradY_T22 )* alpha . y []/( sq ( fm . y [])* Delta ); } } foreach_face ( z ) { if ( fm . z [] > 1e-20 ) { // x-gradient of T13 double shearX = ( T13 [ 1 , 0 , 0 ]* cm [ 1 , 0 , 0 ] + T13 [ 1 , 0 ,- 1 ]* cm [ 1 , 0 ,- 1 ] - T13 [- 1 , 0 , 0 ]* cm [- 1 , 0 , 0 ] - T13 [- 1 , 0 ,- 1 ]* cm [- 1 , 0 ,- 1 ])/ 4. ; // y-gradient of T23 double shearY = ( T23 [ 0 , 1 , 0 ]* cm [ 0 , 1 , 0 ] + T23 [ 0 , 1 ,- 1 ]* cm [ 0 , 1 ,- 1 ] - T23 [ 0 ,- 1 , 0 ]* cm [ 0 ,- 1 , 0 ] - T23 [ 0 ,- 1 ,- 1 ]* cm [ 0 ,- 1 ,- 1 ])/ 4. ; // z-gradient of T33 double gradZ_T33 = cm []* T33 [] - cm [ 0 , 0 ,- 1 ]* T33 [ 0 , 0 ,- 1 ]; av . z [] += ( shearX + shearY + gradZ_T33 )* alpha . z []/( sq ( fm . z [])* Delta ); } } #endif }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if AXI#error \"axi compatibility is not there. To keep the code easy to read, we will not implement axi compatibility just yet.\"#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: /*TODO:- Perhaps, instead...",
    "content": "/*TODO:- Perhaps, instead of the Bell--Collela--Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to [http://basilisk.fr/src/navier-stokes/conserving.h](http://basilisk.fr/src/navier-stokes/conserving.h)*/#define EIGENVALUE_MIN1e-8220#ifdef DEBUG_EIGENVALUESstaticinteigenvalue_corrections=0;#endif#include\"bcg.h\"(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation time/*conformation tensor */// diagonal elementsscalar A11[],A22[],A33[];// off-diagonal elementsscalar A12[],A13[],A23[];/*stress tensor */// diagonal elementsscalar T11[],T22[],T33[];// off-diagonal elementsscalar T12[],T13[],T23[];event defaults(i=0){if(is_constant(a.x))a=new face vector;/*initialize A and T*/for(scalar s in{A11,A22,A33}){foreach(){s[]=1.;}}for(scalar s in{T11,T12,T13,T22,T23,T33,A12,A13,A23}){foreach(){s[]=0.;}}for(scalar s in{A11,A22,A33,T11,T22,T33,A12,A13,A23,T12,T13,T23}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}if(s.boundary[top]!=periodic_bc){s[top]=neumann(0);s[bottom]=neumann(0);}#if dimension ==if(s.boundary[front]!=periodic_bc){s[front]=neumann(0);s[back]=neumann(0);}#endif}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if dimension ==typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}#endif/*Now this is the 3D implementation.*/#if dimension ==#include\"eigen_decomposition.h\"typedefstruct{doublex,y,z;}pseudo_v3d;typedefstruct{pseudo_v3d x,y,z;}pseudo_t3d;// Function to initialize pseudo_v3dstaticinlinevoidinit_pseudo_v3d(pseudo_v3d*v,doublevalue){v->x=value;v->y=value;v->z=value;}// Function to initialize pseudo_t3dstaticinlinevoidinit_pseudo_t3d(pseudo_t3d*t,doublevalue){init_pseudo_v3d(&t->x,value);init_pseudo_v3d(&t->y,value);init_pseudo_v3d(&t->z,value);}staticvoiddiagonalization_3D(pseudo_v3d*Lambda,pseudo_t3d*R,pseudo_t3d*A){// Check if the matrix is already diagonalif(sq(A->x.y)+sq(A->x.z)+sq(A->y.z)<1e-15){R->x.x=R->y.y=R->z.z=1.;R->y.x=R->x.y=R->z.x=R->x.z=R->z.y=R->y.z=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;Lambda->z=A->z.z;return;}// Compute eigenvalues using the eigen_decomposition functiondoublematrix[3][3]={{A->x.x,A->x.y,A->x.z},{A->y.x,A->y.y,A->y.z},{A->z.x,A->z.y,A->z.z}};doubleeigenvectors[3][3];doubleeigenvalues[3];compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);// Store eigenvalues and eigenvectorsLambda->x=eigenvalues[0];Lambda->y=eigenvalues[1];Lambda->z=eigenvalues[2];R->x.x=eigenvectors[0][0];R->x.y=eigenvectors[0][1];R->x.z=eigenvectors[0][2];R->y.x=eigenvectors[1][0];R->y.y=eigenvectors[1][1];R->y.z=eigenvectors[1][2];R->z.x=eigenvectors[2][0];R->z.y=eigenvectors[2][1];R->z.z=eigenvectors[2][2];}#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event tracer_advection(i++){scalar Psi11=A11;scalar Psi12=A12;scalar Psi22=A22;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);pseudo_t R;init_pseudo_t(&R,0.0);diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.This prevents numerical instabilities while maintaining physical meaning.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"WARNING: Negative eigenvalue detected at (%g,%g): [%g,%g]\\n\",x,y,Lambda.x,Lambda.y);#ifdef DEBUG_EIGENVALUESatomic_increment(&eigenvalue_corrections);#endifLambda.x=max(Lambda.x,EIGENVALUE_MIN);Lambda.y=max(Lambda.y,EIGENVALUE_MIN);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);Psi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);Psi22[]=sq(R.y.y)*log(Lambda.y)+sq(R.y.x)*log(Lambda.x);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "pseudo_t B;init_pseudo_t(&B,0.0);doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;init_pseudo_t(&M,0.0);foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubles=-Psi12[];Psi12[]+=dt*(2.*B.x.y+OM*(Psi22[]-Psi11[]));s*=-1;Psi11[]+=dt*2.*(B.x.x+s*OM);s*=-1;Psi22[]+=dt*2.*(B.y.y+s*OM);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A={{Psi11[],Psi12[]},{Psi12[],Psi22[]}},R;init_pseudo_t(&R,0.0);pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);A.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A12[]=A.x.y;T12[]=Gp[]*A.x.y;A11[]=A.x.x;T11[]=Gp[]*(A.x.x-1.);A22[]=A.y.y;T22[]=Gp[]*(A.y.y-1.);}}#elif dimension ==",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: // start by...",
    "content": "// start by declaring the scalar variables that will store the components of $\\Psi$scalar Psi11=A11,Psi12=A12,Psi13=A13,Psi22=A22,Psi23=A23,Psi33=A33;foreach(){pseudo_t3d A,R;init_pseudo_t3d(&R,0.0);pseudo_v3d Lambda;init_pseudo_v3d(&Lambda,0.0);A.x.x=A11[];A.x.y=A12[];A.x.z=A13[];A.y.x=A12[];A.y.y=A22[];A.y.z=A23[];A.z.x=A13[];A.z.y=A23[];A.z.z=A33[];// Diagonalize the conformation tensor A to obtain the eigenvalues Lambda and eigenvectors Rdiagonalization_3D(&Lambda,&R,&A);/*Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.This prevents numerical instabilities while maintaining physical meaning.*/if(Lambda.x<=0.||Lambda.y<=0.||Lambda.z<=0.){fprintf(ferr,\"WARNING: Negative eigenvalue detected at (%g,%g,%g): [%g,%g,%g]\\n\",x,y,z,Lambda.x,Lambda.y,Lambda.z);#ifdef DEBUG_EIGENVALUESatomic_increment(&eigenvalue_corrections);#endifLambda.x=max(Lambda.x,EIGENVALUE_MIN);Lambda.y=max(Lambda.y,EIGENVALUE_MIN);Lambda.z=max(Lambda.z,EIGENVALUE_MIN);}// Compute Psi = log(A) = R * log(Lambda) * R^TPsi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y)+sq(R.x.z)*log(Lambda.z);Psi22[]=sq(R.y.x)*log(Lambda.x)+sq(R.y.y)*log(Lambda.y)+sq(R.y.z)*log(Lambda.z);Psi33[]=sq(R.z.x)*log(Lambda.x)+sq(R.z.y)*log(Lambda.y)+sq(R.z.z)*log(Lambda.z);Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.x.y*R.y.y*log(Lambda.y)+R.x.z*R.y.z*log(Lambda.z);Psi13[]=R.x.x*R.z.x*log(Lambda.x)+R.x.y*R.z.y*log(Lambda.y)+R.x.z*R.z.z*log(Lambda.z);Psi23[]=R.y.x*R.z.x*log(Lambda.x)+R.y.y*R.z.y*log(Lambda.y)+R.y.z*R.z.z*log(Lambda.z);// Compute B and Omega tensors (3D version)pseudo_t3d B,M,Omega;init_pseudo_t3d(&B,0.0);init_pseudo_t3d(&M,0.0);init_pseudo_t3d(&Omega,0.0);// Check if any pair of eigenvalues are numerically equal (within a small tolerance)if(fabs(Lambda.x-Lambda.y)<=1e-20||fabs(Lambda.y-Lambda.z)<=1e-20||fabs(Lambda.z-Lambda.x)<=1e-20){// In case of equal eigenvalues, the calculations for B and Omega simplify significantly// B is grad U and Omega is zero.// Compute off-diagonal elements of B using central differences// These represent the symmetric part of the velocity gradient tensorB.x.y=(u.y[1,0,0]-u.y[-1,0,0]+u.x[0,1,0]-u.x[0,-1,0])/(4.*Delta);// (dv/dx + du/dy)/2B.x.z=(u.z[1,0,0]-u.z[-1,0,0]+u.x[0,0,1]-u.x[0,0,-1])/(4.*Delta);// (dw/dx + du/dz)/2B.y.z=(u.z[0,1,0]-u.z[0,-1,0]+u.y[0,0,1]-u.y[0,0,-1])/(4.*Delta);// (dw/dy + dv/dz)/2// Compute diagonal elements of B// These represent the normal strain ratesB.x.x=(u.x[1,0,0]-u.x[-1,0,0])/(2.*Delta);// du/dxB.y.y=(u.y[0,1,0]-u.y[0,-1,0])/(2.*Delta);// dv/dyB.z.z=(u.z[0,0,1]-u.z[0,0,-1])/(2.*Delta);// dw/dz// Set all components of Omega to zero// This is because Omega represents the antisymmetric part of the velocity gradient tensor,// which vanishes when eigenvalues are equalOmega.x.y=Omega.x.z=Omega.y.z=Omega.y.x=Omega.z.x=Omega.z.y=0.;}else{/*###Compute the velocity gradient tensor components using central differences- These represent the spatial derivatives of each velocity component- These gradients form the velocity gradient tensor (nablaU):[ dudx  dudy  dudz ][ dvdx  dvdy  dvdz ][ dwdx  dwdy  dwdz ]*/// Derivatives of u (x-component of velocity)doubledudx=(u.x[1,0,0]-u.x[-1,0,0])/(2.0*Delta);// du/dxdoubledudy=(u.x[0,1,0]-u.x[0,-1,0])/(2.0*Delta);// du/dydoubledudz=(u.x[0,0,1]-u.x[0,0,-1])/(2.0*Delta);// du/dz// Derivatives of v (y-component of velocity)doubledvdx=(u.y[1,0,0]-u.y[-1,0,0])/(2.0*Delta);// dv/dxdoubledvdy=(u.y[0,1,0]-u.y[0,-1,0])/(2.0*Delta);// dv/dydoubledvdz=(u.y[0,0,1]-u.y[0,0,-1])/(2.0*Delta);// dv/dz// Derivatives of w (z-component of velocity)doubledwdx=(u.z[1,0,0]-u.z[-1,0,0])/(2.0*Delta);// dw/dxdoubledwdy=(u.z[0,1,0]-u.z[0,-1,0])/(2.0*Delta);// dw/dydoubledwdz=(u.z[0,0,1]-u.z[0,0,-1])/(2.0*Delta);// dw/dz/*Calculate the M tensor through matrix multiplication: M = R * (nablaU)^T R^T.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: This represents the...",
    "content": "This represents the velocity gradient tensor transformed to the eigenvector basis of the conformation tensor.* Steps:1. Compute intermediate products (R * nablaU^T):- Store row-wise products in Rx_gradU_*, Ry_gradU_*, Rz_gradU_*- Each variable represents one row of the intermediate matrix2.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Multiply by R^T...",
    "content": "Multiply by R^T to obtain the final M tensor:- M.i.j represents the (i,j) component of the transformed velocity gradient- This transformation expresses the velocity gradient in the eigenvector basis- The resulting M tensor is used to compute Omega (\u03a9) and B tensors, such that*/// First, compute intermediate products of R and (nablaU)^TdoubleRx_gradU_x=R.x.x*dudx+R.x.y*dvdx+R.x.z*dwdx;doubleRx_gradU_y=R.x.x*dudy+R.x.y*dvdy+R.x.z*dwdy;doubleRx_gradU_z=R.x.x*dudz+R.x.y*dvdz+R.x.z*dwdz;doubleRy_gradU_x=R.y.x*dudx+R.y.y*dvdx+R.y.z*dwdx;doubleRy_gradU_y=R.y.x*dudy+R.y.y*dvdy+R.y.z*dwdy;doubleRy_gradU_z=R.y.x*dudz+R.y.y*dvdz+R.y.z*dwdz;doubleRz_gradU_x=R.z.x*dudx+R.z.y*dvdx+R.z.z*dwdx;doubleRz_gradU_y=R.z.x*dudy+R.z.y*dvdy+R.z.z*dwdy;doubleRz_gradU_z=R.z.x*dudz+R.z.y*dvdz+R.z.z*dwdz;// Now compute M components by multiplying the intermediate products with R^TM.x.x=R.x.x*Rx_gradU_x+R.x.y*Rx_gradU_y+R.x.z*Rx_gradU_z;M.x.y=R.x.x*Ry_gradU_x+R.x.y*Ry_gradU_y+R.x.z*Ry_gradU_z;M.x.z=R.x.x*Rz_gradU_x+R.x.y*Rz_gradU_y+R.x.z*Rz_gradU_z;M.y.x=R.y.x*Rx_gradU_x+R.y.y*Rx_gradU_y+R.y.z*Rx_gradU_z;M.y.y=R.y.x*Ry_gradU_x+R.y.y*Ry_gradU_y+R.y.z*Ry_gradU_z;M.y.z=R.y.x*Rz_gradU_x+R.y.y*Rz_gradU_y+R.y.z*Rz_gradU_z;M.z.x=R.z.x*Rx_gradU_x+R.z.y*Rx_gradU_y+R.z.z*Rx_gradU_z;M.z.y=R.z.x*Ry_gradU_x+R.z.y*Ry_gradU_y+R.z.z*Ry_gradU_z;M.z.z=R.z.x*Rz_gradU_x+R.z.y*Rz_gradU_y+R.z.z*Rz_gradU_z;// Compute the off-diagonal elements of the Omega tensor in the eigenvector basisdoubleomega_xy=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);doubleomega_xz=(Lambda.z*M.x.z+Lambda.x*M.z.x)/(Lambda.z-Lambda.x);doubleomega_yz=(Lambda.z*M.y.z+Lambda.y*M.z.y)/(Lambda.z-Lambda.y);// Calculate intermediate rotation combinations for each direction// x-direction rotation combinationsdoublerot_x_xy_yz=(R.x.x*omega_xy-R.x.z*omega_yz);// xy rotation minus yz rotation, x componentsdoublerot_x_xy_xz=(R.x.y*omega_xy+R.x.z*omega_xz);// xy rotation plus xz rotation, x componentsdoublerot_x_xz_yz=(R.x.x*omega_xz+R.x.y*omega_yz);// xz rotation plus yz rotation, x components// y-direction rotation combinationsdoublerot_y_xy_yz=(R.y.x*omega_xy-R.y.z*omega_yz);// xy rotation minus yz rotation, y componentsdoublerot_y_xy_xz=(R.y.y*omega_xy+R.y.z*omega_xz);// xy rotation plus xz rotation, y componentsdoublerot_y_xz_yz=(R.y.x*omega_xz+R.y.y*omega_yz);// xz rotation plus yz rotation, y components// z-direction rotation combinationsdoublerot_z_xy_yz=(R.z.x*omega_xy-R.z.z*omega_yz);// xy rotation minus yz rotation, z componentsdoublerot_z_xy_xz=(R.z.y*omega_xy+R.z.z*omega_xz);// xy rotation plus xz rotation, z componentsdoublerot_z_xz_yz=(R.z.x*omega_xz+R.z.y*omega_yz);// xz rotation plus yz rotation, z components",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: // Compute x-row...",
    "content": "// Compute x-row components of OmegaOmega.x.x=R.x.y*rot_x_xy_yz// xy-yz rotation contribution-R.x.x*rot_x_xy_xz// xy-xz rotation contribution+R.x.z*rot_x_xz_yz;// xz-yz rotation contributionOmega.x.y=R.y.y*rot_x_xy_yz// xy-yz rotation mapped to y-direction-R.y.x*rot_x_xy_xz// xy-xz rotation mapped to y-direction+R.y.z*rot_x_xz_yz;// xz-yz rotation mapped to y-directionOmega.x.z=R.z.y*rot_x_xy_yz// xy-yz rotation mapped to z-direction-R.z.x*rot_x_xy_xz// xy-xz rotation mapped to z-direction+R.z.z*rot_x_xz_yz;// xz-yz rotation mapped to z-direction// Compute y-row components using similar patternOmega.y.x=R.x.y*rot_y_xy_yz-R.x.x*rot_y_xy_xz+R.x.z*rot_y_xz_yz;Omega.y.y=R.y.y*rot_y_xy_yz-R.y.x*rot_y_xy_xz+R.y.z*rot_y_xz_yz;Omega.y.z=R.z.y*rot_y_xy_yz-R.z.x*rot_y_xy_xz+R.z.z*rot_y_xz_yz;// Compute z-row components using similar patternOmega.z.x=R.x.y*rot_z_xy_yz-R.x.x*rot_z_xy_xz+R.x.z*rot_z_xz_yz;Omega.z.y=R.y.y*rot_z_xy_yz-R.y.x*rot_z_xy_xz+R.y.z*rot_z_xz_yz;Omega.z.z=R.z.y*rot_z_xy_yz-R.z.x*rot_z_xy_xz+R.z.z*rot_z_xz_yz;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "// Extract diagonal components of M (velocity gradient tensor in eigenvector basis)doubleM_diag_x=M.x.x,M_diag_y=M.y.y,M_diag_z=M.z.z;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: // Compute diagonal...",
    "content": "// Compute diagonal elements of BB.x.x=M_diag_x*sq(R.x.x)+M_diag_y*sq(R.x.y)+M_diag_z*sq(R.x.z);B.y.y=M_diag_x*sq(R.y.x)+M_diag_y*sq(R.y.y)+M_diag_z*sq(R.y.z);B.z.z=M_diag_x*sq(R.z.x)+M_diag_y*sq(R.z.y)+M_diag_z*sq(R.z.z);// Compute off-diagonal elements of B (upper triangle)B.x.y=M_diag_x*R.x.x*R.y.x+M_diag_y*R.x.y*R.y.y+M_diag_z*R.x.z*R.y.z;B.x.z=M_diag_x*R.x.x*R.z.x+M_diag_y*R.x.y*R.z.y+M_diag_z*R.x.z*R.z.z;B.y.z=M_diag_x*R.y.x*R.z.x+M_diag_y*R.y.y*R.z.y+M_diag_z*R.y.z*R.z.z;// Fill in lower triangle using symmetry of BB.y.x=B.x.y;B.z.x=B.x.z;B.z.y=B.y.z;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: // save old...",
    "content": "// save old values of Psi componentsdoubleold_Psi11=Psi11[];doubleold_Psi22=Psi22[];doubleold_Psi33=Psi33[];doubleold_Psi12=Psi12[];doubleold_Psi13=Psi13[];doubleold_Psi23=Psi23[];// Psi11Psi11[]+=dt*(2.0*B.x.x+Omega.x.y*old_Psi12-Omega.y.x*old_Psi12+Omega.x.z*old_Psi13-Omega.z.x*old_Psi13);// Psi22Psi22[]+=dt*(2.0*B.y.y-Omega.x.y*old_Psi12+Omega.y.x*old_Psi12+Omega.y.z*old_Psi23-Omega.z.y*old_Psi23);// Psi33Psi33[]+=dt*(2.0*B.z.z-Omega.x.z*old_Psi13+Omega.z.x*old_Psi13-Omega.y.z*old_Psi23+Omega.z.y*old_Psi23);// Psi12Psi12[]+=dt*(2.0*B.x.y+Omega.x.x*old_Psi12-Omega.x.y*old_Psi11+Omega.x.y*old_Psi22-Omega.y.y*old_Psi12+Omega.x.z*old_Psi23-Omega.z.y*old_Psi13);// Psi13Psi13[]+=dt*(2.0*B.x.z+Omega.x.x*old_Psi13-Omega.x.z*old_Psi11+Omega.x.y*old_Psi23-Omega.y.z*old_Psi12+Omega.x.z*old_Psi33-Omega.z.z*old_Psi13);// Psi23Psi23[]+=dt*(2.0*B.y.z+Omega.y.x*old_Psi13-Omega.x.z*old_Psi12+Omega.y.y*old_Psi23-Omega.y.z*old_Psi22+Omega.y.z*old_Psi33-Omega.z.z*old_Psi23);}// Advection of Psi, which is the log-conformation tensoradvection({Psi11,Psi12,Psi13,Psi22,Psi23,Psi33},uf,dt);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "foreach(){pseudo_t3d A,R;init_pseudo_t3d(&R,0.0);pseudo_v3d Lambda;init_pseudo_v3d(&Lambda,0.0);// Reconstruct the log-conformation tensor from its componentsA.x.x=Psi11[];A.x.y=Psi12[];A.x.z=Psi13[];A.y.x=Psi12[];A.y.y=Psi22[];A.y.z=Psi23[];A.z.x=Psi13[];A.z.y=Psi23[];A.z.z=Psi33[];// Diagonalize A to obtain eigenvalues and eigenvectorsdiagonalization_3D(&Lambda,&R,&A);// Exponentiate eigenvaluesLambda.x=exp(Lambda.x);Lambda.y=exp(Lambda.y);Lambda.z=exp(Lambda.z);// Reconstruct A using A = R * diag(Lambda) * R^TA.x.x=Lambda.x*sq(R.x.x)+Lambda.y*sq(R.x.y)+Lambda.z*sq(R.x.z);A.x.y=Lambda.x*R.x.x*R.y.x+Lambda.y*R.x.y*R.y.y+Lambda.z*R.x.z*R.y.z;A.y.x=A.x.y;A.x.z=Lambda.x*R.x.x*R.z.x+Lambda.y*R.x.y*R.z.y+Lambda.z*R.x.z*R.z.z;A.z.x=A.x.z;A.y.y=Lambda.x*sq(R.y.x)+Lambda.y*sq(R.y.y)+Lambda.z*sq(R.y.z);A.y.z=Lambda.x*R.y.x*R.z.x+Lambda.y*R.y.y*R.z.y+Lambda.z*R.y.z*R.z.z;A.z.y=A.y.z;A.z.z=Lambda.x*sq(R.z.x)+Lambda.y*sq(R.z.y)+Lambda.z*sq(R.z.z);// Apply relaxation using the relaxation time lambdadoubleintFactor=lambda[]!=0.?exp(-dt/lambda[]):0.;A.x.y*=intFactor;A.y.x=A.x.y;A.x.z*=intFactor;A.z.x=A.x.z;A.y.z*=intFactor;A.z.y=A.y.z;foreach_dimension()A.x.x=1.+(A.x.x-1.)*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "// diagonal terms:A11[]=A.x.x;A22[]=A.y.y;A33[]=A.z.z;// off-diagonal terms:A12[]=A.x.y;A13[]=A.x.z;A23[]=A.y.z;// Compute the stress tensor T using the polymer modulus GpT11[]=Gp[]*(A.x.x-1.);T22[]=Gp[]*(A.y.y-1.);T33[]=Gp[]*(A.z.z-1.);T12[]=Gp[]*A.x.y;T13[]=Gp[]*A.x.z;T23[]=Gp[]*A.y.z;}}#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event acceleration(i++){face vector...",
    "content": "event acceleration(i++){face vector av=a;#if dimension ==// 2D implementationforeach_face(x){if(fm.x[]>1e-20){// y-gradient of T12 (shear stress)doubleshearX=(T12[0,1]*cm[0,1]+T12[-1,1]*cm[-1,1]-T12[0,-1]*cm[0,-1]-T12[-1,-1]*cm[-1,-1])/4.;// x-gradient of T11 (normal stress)doublegradX_T11=cm[]*T11[]-cm[-1]*T11[-1];av.x[]+=(shearX+gradX_T11)*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){// x-gradient of T12 (shear stress)doubleshearY=(T12[1,0]*cm[1,0]+T12[1,-1]*cm[1,-1]-T12[-1,0]*cm[-1,0]-T12[-1,-1]*cm[-1,-1])/4.;// y-gradient of T22 (normal stress)doublegradY_T22=cm[]*T22[]-cm[0,-1]*T22[0,-1];av.y[]+=(shearY+gradY_T22)*alpha.y[]/(sq(fm.y[])*Delta);}}#elif dimension ==// 3D implementationforeach_face(x){if(fm.x[]>1e-20){// y-gradient of T12doubleshearY=(T12[0,1,0]*cm[0,1,0]+T12[-1,1,0]*cm[-1,1,0]-T12[0,-1,0]*cm[0,-1,0]-T12[-1,-1,0]*cm[-1,-1,0])/4.;// z-gradient of T13doubleshearZ=(T13[0,0,1]*cm[0,0,1]+T13[-1,0,1]*cm[-1,0,1]-T13[0,0,-1]*cm[0,0,-1]-T13[-1,0,-1]*cm[-1,0,-1])/4.;// x-gradient of T11doublegradX_T11=cm[]*T11[]-cm[-1,0,0]*T11[-1,0,0];av.x[]+=(shearY+shearZ+gradX_T11)*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){// x-gradient of T12doubleshearX=(T12[1,0,0]*cm[1,0,0]+T12[1,-1,0]*cm[1,-1,0]-T12[-1,0,0]*cm[-1,0,0]-T12[-1,-1,0]*cm[-1,-1,0])/4.;// z-gradient of T23doubleshearZ=(T23[0,0,1]*cm[0,0,1]+T23[0,-1,1]*cm[0,-1,1]-T23[0,0,-1]*cm[0,0,-1]-T23[0,-1,-1]*cm[0,-1,-1])/4.;// y-gradient of T22doublegradY_T22=cm[]*T22[]-cm[0,-1,0]*T22[0,-1,0];av.y[]+=(shearX+shearZ+gradY_T22)*alpha.y[]/(sq(fm.y[])*Delta);}}foreach_face(z){if(fm.z[]>1e-20){// x-gradient of T13doubleshearX=(T13[1,0,0]*cm[1,0,0]+T13[1,0,-1]*cm[1,0,-1]-T13[-1,0,0]*cm[-1,0,0]-T13[-1,0,-1]*cm[-1,0,-1])/4.;// y-gradient of T23doubleshearY=(T23[0,1,0]*cm[0,1,0]+T23[0,1,-1]*cm[0,1,-1]-T23[0,-1,0]*cm[0,-1,0]-T23[0,-1,-1]*cm[0,-1,-1])/4.;// z-gradient of T33doublegradZ_T33=cm[]*T33[]-cm[0,0,-1]*T33[0,0,-1];av.z[]+=(shearX+shearY+gradZ_T33)*alpha.z[]/(sq(fm.z[])*Delta);}}#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "src-local/eigen_decomposition.h See raw file Matrix Eigenvalue Solver This module provides algorithms for computing eigenvalues and eigenvectors of 3x3 symmetric matrices, which are commonly encountered in computational fluid dynamics, solid mechanics, and other physics-based simulations. Mathematical Background The implementation uses the Householder transformation to reduce a symmetric matrix to tridiagonal form, followed by the QL algorithm with implicit shifts to compute the eigenvalues and eigenvectors. For a 3x3 symmetric matrix, these methods are particularly efficient and numerically stable, providing accurate results even for matrices with closely spaced eigenvalues. Tridiagonalize a 3x3 Symmetric Matrix Reduces a 3x3 symmetric matrix to tridiagonal form using the Householder method, which applies a series of orthogonal transformations to eliminate elements below the subdiagonal.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Parameters: matrix[in]: Input 3x3 symmetric matrix to be tridiagonalized eigenvectors[out]: Orthogonal matrix of Householder vectors diagonal[out]: Diagonal elements of the resulting tridiagonal matrix subdiagonal[out]: Subdiagonal elements of the tridiagonal matrix Implementation Notes: The original matrix is preserved The eigenvectors matrix is initialized to identity and then transformed The algorithm exploits the symmetry of the input matrix #define SQUARE ( x ) (( x )*( x )) 36 static void tridiagonalize_symmetric_3x3 ( double matrix [ 3 ][ 3 ], double eigenvectors [ 3 ][ 3 ], double diagonal [ 3 ], double subdiagonal [ 2 ]) { const int size = 3 ; double householder_vector [ size ], temp_vector [ size ]; double omega , scale , sigma , tau ; // Initialize eigenvectors to the identity matrix for ( int i = 0 ; i < size ; i ++) { eigenvectors [ i ][ i ] = 1.0 ; for ( int j = 0 ; j < i ; j ++) eigenvectors [ i ][ j ] = eigenvectors [ j ][ i ] = 0.0 ; } // Compute the first Householder reflection scale = SQUARE ( matrix [ 0 ][ 1 ]) + SQUARE ( matrix [ 0 ][ 2 ]); sigma = ( matrix [ 0 ][ 1 ] > 0 ) ? - sqrt ( scale ) : sqrt ( scale ); subdiagonal [ 0 ] = sigma ; tau = sigma * matrix [ 0 ][ 1 ]; householder_vector [ 1 ] = matrix [ 0 ][ 1 ] - sigma ; householder_vector [ 2 ] = matrix [ 0 ][ 2 ]; omega = scale - tau ; if ( omega > 0.0 ) { omega = 1.0 / omega ; sigma = 0.0 ; for ( int i = 1 ; i < size ; i ++) { tau = matrix [ 1 ][ i ] * householder_vector [ 1 ] + matrix [ i ][ 2 ] * householder_vector [ 2 ]; temp_vector [ i ] = omega * tau ; sigma += householder_vector [ i ] * tau ; } sigma *= 0.5 * SQUARE ( omega ); for ( int i = 1 ; i < size ; i ++) temp_vector [ i ] -= sigma * householder_vector [ i ]; diagonal [ 0 ] = matrix [ 0 ][ 0 ]; diagonal [ 1 ] = matrix [ 1 ][ 1 ] - 2.0 * temp_vector [ 1 ] * householder_vector [ 1 ]; diagonal [ 2 ] = matrix [ 2 ][ 2 ] - 2.0 * temp_vector [ 2 ] * householder_vector [ 2 ]; for ( int j = 1 ; j < size ; j ++) { tau = omega * householder_vector [ j ]; for ( int i = 1 ; i < size ; i ++) eigenvectors [ i ][ j ] -= tau * householder_vector [ i ]; } subdiagonal [ 1 ] = matrix [ 1 ][ 2 ] - temp_vector [ 1 ] * householder_vector [ 2 ] - householder_vector [ 1 ] * temp_vector [ 2 ]; } else { for ( int i = 0 ; i < size ; i ++) diagonal [ i ] = matrix [ i ][ i ]; subdiagonal [ 1 ] = matrix [ 1 ][ 2 ]; } } ### Compute Eigenvalues and Eigenvectors of a 3x3 Symmetric Matrix Calculates the complete eigensystem (eigenvalues and eigenvectors) of a 3x3 symmetric matrix using the QL algorithm with implicit shifts, after first reducing the matrix to tridiagonal form.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Parameters: matrix[in]: Input...",
    "content": "Parameters: matrix[in]: Input 3x3 symmetric matrix whose eigensystem will be computed eigenvectors[out]: Matrix whose columns are the eigenvectors eigenvalues[out]: Array containing the eigenvalues Return Value: 0: Computation successful -1: Algorithm failed to converge within the maximum number of iterations Algorithm Details: First checks if the matrix is already diagonal If not, tridiagonalizes the matrix using Householder transformations Applies the QL algorithm with implicit shifts to compute eigenvalues Maximum of 30 iterations are allowed for convergence Numerical tolerance of 1e-15 is used for detecting diagonal matrices Usage Example: double matrix [ 3 ][ 3 ] = {{ 1.0 , 0.5 , 0.3 }, { 0.5 , 2.0 , 0.1 }, { 0.3 , 0.1 , 3.0 }}; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; int result = compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); if ( result == 0 ) { // Computation successful } static int compute_eigensystem_symmetric_3x3 ( double matrix [ 3 ][ 3 ], double eigenvectors [ 3 ][ 3 ], double eigenvalues [ 3 ]) { const int size = 3 ; const int max_iterations = 30 ; double subdiagonal [ 3 ]; double g , r , p , f , b , s , c , t ; int iteration_count ; int m ; // Check for diagonal matrix with unit entries if ( SQUARE ( matrix [ 0 ][ 1 ]) < 1e-15 && SQUARE ( matrix [ 0 ][ 2 ]) < 1e-15 && SQUARE ( matrix [ 1 ][ 2 ]) < 1e-15 ) { for ( int i = 0 ; i < size ; i ++) { for ( int j = 0 ; j < size ; j ++) { eigenvectors [ i ][ j ] = ( i == j ) ? 1.0 : 0.0 ; } eigenvalues [ i ] = matrix [ i ][ i ]; } return 0 ; } tridiagonalize_symmetric_3x3 ( matrix , eigenvectors , eigenvalues , subdiagonal ); for ( int l = 0 ; l < size - 1 ; l ++) { iteration_count = 0 ; while ( 1 ) { for ( m = l ; m <= size - 2 ; m ++) { g = fabs ( eigenvalues [ m ]) + fabs ( eigenvalues [ m + 1 ]); if ( fabs ( subdiagonal [ m ]) + g == g ) break ; } if ( m == l ) break ; if ( iteration_count ++ >= max_iterations ) return - 1 ; g = ( eigenvalues [ l + 1 ] - eigenvalues [ l ]) / ( 2.0 * subdiagonal [ l ]); r = sqrt ( SQUARE ( g ) + 1.0 ); g = eigenvalues [ m ] - eigenvalues [ l ] + subdiagonal [ l ] / ( g + ( g > 0 ? fabs ( r ) : - fabs ( r ))); s = c = 1.0 ; p = 0.0 ; for ( int i = m - 1 ; i >= l ; i --) { f = s * subdiagonal [ i ]; b = c * subdiagonal [ i ]; if ( fabs ( f ) > fabs ( g )) { c = g / f ; r = sqrt ( SQUARE ( c ) + 1.0 ); subdiagonal [ i + 1 ] = f * r ; c *= ( s = 1.0 / r ); } else { s = f / g ; r = sqrt ( SQUARE ( s ) + 1.0 ); subdiagonal [ i + 1 ] = g * r ; s *= ( c = 1.0 / r ); } g = eigenvalues [ i + 1 ] - p ; r = ( eigenvalues [ i ] - g ) * s + 2.0 * c * b ; p = s * r ; eigenvalues [ i + 1 ] = g + p ; g = c * r - b ; for ( int k = 0 ; k < size ; k ++) { t = eigenvectors [ k ][ i + 1 ]; eigenvectors [ k ][ i + 1 ] = s * eigenvectors [ k ][ i ] + c * t ; eigenvectors [ k ][ i ] = c * eigenvectors [ k ][ i ] - s * t ; } } eigenvalues [ l ] -= p ; subdiagonal [ l ] = g ; subdiagonal [ m ] = 0.0 ; } } return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "#define SQUARE(x)((x)*(x))36staticvoidtridiagonalize_symmetric_3x3(doublematrix[3][3],doubleeigenvectors[3][3],doublediagonal[3],doublesubdiagonal[2]){constintsize=3;doublehouseholder_vector[size],temp_vector[size];doubleomega,scale,sigma,tau;// Initialize eigenvectors to the identity matrixfor(inti=0;i<size;i++){eigenvectors[i][i]=1.0;for(intj=0;j<i;j++)eigenvectors[i][j]=eigenvectors[j][i]=0.0;}// Compute the first Householder reflectionscale=SQUARE(matrix[0][1])+SQUARE(matrix[0][2]);sigma=(matrix[0][1]>0)?-sqrt(scale):sqrt(scale);subdiagonal[0]=sigma;tau=sigma*matrix[0][1];householder_vector[1]=matrix[0][1]-sigma;householder_vector[2]=matrix[0][2];omega=scale-tau;if(omega>0.0){omega=1.0/omega;sigma=0.0;for(inti=1;i<size;i++){tau=matrix[1][i]*householder_vector[1]+matrix[i][2]*householder_vector[2];temp_vector[i]=omega*tau;sigma+=householder_vector[i]*tau;}sigma*=0.5*SQUARE(omega);for(inti=1;i<size;i++)temp_vector[i]-=sigma*householder_vector[i];diagonal[0]=matrix[0][0];diagonal[1]=matrix[1][1]-2.0*temp_vector[1]*householder_vector[1];diagonal[2]=matrix[2][2]-2.0*temp_vector[2]*householder_vector[2];for(intj=1;j<size;j++){tau=omega*householder_vector[j];for(inti=1;i<size;i++)eigenvectors[i][j]-=tau*householder_vector[i];}subdiagonal[1]=matrix[1][2]-temp_vector[1]*householder_vector[2]-householder_vector[1]*temp_vector[2];}else{for(inti=0;i<size;i++)diagonal[i]=matrix[i][i];subdiagonal[1]=matrix[1][2];}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doublematrix[3][3]={{1.0,0.5,0.3},{0.5,2.0,0.1},{0.3,0.1,3.0}};doubleeigenvectors[3][3];doubleeigenvalues[3];intresult=compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);if(result==0){// Computation successful}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "staticintcompute_eigensystem_symmetric_3x3(doublematrix[3][3],doubleeigenvectors[3][3],doubleeigenvalues[3]){constintsize=3;constintmax_iterations=30;doublesubdiagonal[3];doubleg,r,p,f,b,s,c,t;intiteration_count;intm;// Check for diagonal matrix with unit entriesif(SQUARE(matrix[0][1])<1e-15&&SQUARE(matrix[0][2])<1e-15&&SQUARE(matrix[1][2])<1e-15){for(inti=0;i<size;i++){for(intj=0;j<size;j++){eigenvectors[i][j]=(i==j)?1.0:0.0;}eigenvalues[i]=matrix[i][i];}return0;}tridiagonalize_symmetric_3x3(matrix,eigenvectors,eigenvalues,subdiagonal);for(intl=0;l<size-1;l++){iteration_count=0;while(1){for(m=l;m<=size-2;m++){g=fabs(eigenvalues[m])+fabs(eigenvalues[m+1]);if(fabs(subdiagonal[m])+g==g)break;}if(m==l)break;if(iteration_count++>=max_iterations)return-1;g=(eigenvalues[l+1]-eigenvalues[l])/(2.0*subdiagonal[l]);r=sqrt(SQUARE(g)+1.0);g=eigenvalues[m]-eigenvalues[l]+subdiagonal[l]/(g+(g>0?fabs(r):-fabs(r)));s=c=1.0;p=0.0;for(inti=m-1;i>=l;i--){f=s*subdiagonal[i];b=c*subdiagonal[i];if(fabs(f)>fabs(g)){c=g/f;r=sqrt(SQUARE(c)+1.0);subdiagonal[i+1]=f*r;c*=(s=1.0/r);}else{s=f/g;r=sqrt(SQUARE(s)+1.0);subdiagonal[i+1]=g*r;s*=(c=1.0/r);}g=eigenvalues[i+1]-p;r=(eigenvalues[i]-g)*s+2.0*c*b;p=s*r;eigenvalues[i+1]=g+p;g=c*r-b;for(intk=0;k<size;k++){t=eigenvectors[k][i+1];eigenvectors[k][i+1]=s*eigenvectors[k][i]+c*t;eigenvectors[k][i]=c*eigenvectors[k][i]-s*t;}}eigenvalues[l]-=p;subdiagonal[l]=g;subdiagonal[m]=0.0;}}return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "src-local/log-conform-viscoelastic.h See raw file Log-Conformation Method with Tensor Implementation Overview Title : log-conform-viscoelastic.h Version : 10.5 Description : Tensor-based implementation of the log-conformation method for viscoelastic fluids Key Features Conformation tensor A exists across domain and relaxes according to \u03bb Stress acts according to elastic modulus G Uses native tensor data structures for better code organization Supports both 2D and axisymmetric configurations Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Nov 23, 2024 Implementation Notes Based on http://basilisk.fr/src/log-conform.h with key improvements: Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling bug where [\u03c3_p] = 0 & [\u03c3_s] = \u03b3\u03ba Ensures [\u03c3_s+\u03c3_p] = \u03b3\u03ba for correct interface behavior Important Limitations 3D Compatibility Currently limited to 2D and axisymmetric cases only 3D support is blocked by Basilisk core limitations: Boundary conditions for symmetric tensors are not implemented in Basilisk core See basilisk/src/grid/cartesian-common.h lines 230-251 Comment in source: \u201cfixme: boundary conditions don\u2019t work!\u201d Alternative for 3D For 3D simulations, use log-conform-viscoelastic-scalar-3D.h Scalar version uses individual components instead of tensors Provides full 3D functionality without boundary condition limitations Technical Notes Variable Naming conform_p , conform_qq : Represent the Conformation tensor Tensor implementation provides more natural mathematical representation Axisymmetric components handled separately when needed Mathematical Framework The implementation follows the standard log-conformation approach: 1.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Uses tensor mathematics...",
    "content": "Uses tensor mathematics for clean formulation 2. Handles both planar and axisymmetric geometries 3. Provides natural extension to various constitutive models Note: In this code, conform_p, conform_qq are in fact the Conformation tensor. The log-conformation method for viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function. The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In the case...",
    "content": "In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models. Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This instability poses...",
    "content": "This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) . TODO: - Perhaps, instead of the Bell\u2013Collela\u2013Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to http://basilisk.fr/src/navier-stokes/conserving.h #include \"bcg.h\" #if dimension == #error \"This implementation does not support 3D due to missing tensor boundary conditions in Basilisk (see cartesian-common.h line ~246).",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: JavaScript",
    "content": "Use log-conform-viscoelastic-scalar-3D.h for 3D simulations.\" #endif ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time symmetric tensor conform_p [], tau_p []; #if AXI scalar conform_qq [], tau_qq []; #endif event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; foreach () { foreach_dimension (){ tau_p . x . x [] = 0. ; conform_p . x . x [] = 1. ; } tau_p . x . y [] = 0. ; conform_p . x . y [] = 0. ; #if AXI tau_qq [] = 0 ; conform_qq [] = 1. ; #endif } for ( scalar s in { tau_p }) { s . v . x . i = - 1 ; // just a scalar, not the component of a vector foreach_dimension (){ if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } } for ( scalar s in { conform_p }) { s . v . x . i = - 1 ; // just a scalar, not the component of a vector foreach_dimension (){ if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } } #if AXI scalar s1 = tau_p . x . y ; s1 [ bottom ] = dirichlet ( 0. ); #endif #if AXI scalar s2 = conform_p . x . y ; s2 [ bottom ] = dirichlet ( 0. ); #endif } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } The stress tensor depends on previous instants and has to be integrated in time. In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We use a...",
    "content": "We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ). In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] event tracer_advection ( i ++) { tensor Psi = conform_p ; #if AXI scalar Psiqq = conform_qq ; #endif Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A ; A . x . y = conform_p . x . y []; foreach_dimension () A . x . x = conform_p . x . x []; In the axisymmetric case, \\(\\Psi_{\\theta \\theta} = \\log A_{\\theta \\theta}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Therefore \\(\\Psi_{\\theta \\theta}...",
    "content": "Therefore \\(\\Psi_{\\theta \\theta} = \\log [ ( 1 + \\text{fa} \\tau_{p_{\\theta \\theta}})]\\) . #if AXI double Aqq = conform_qq []; Psiqq [] = log ( Aqq ); #endif The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; pseudo_t R ; diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue. Please report this bug by opening an issue on the GitHub repository. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"Negative eigenvalue detected: Lambda.x = %g , Lambda.y = %g\\n \" , Lambda . x , Lambda . y ); fprintf ( ferr , \"x = %g , y = %g\\n \" , x , y ); exit ( 1 ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "Psi . x . y [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); foreach_dimension () Psi . x . x [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) . The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Transform omega back...",
    "content": "Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: - R is the eigenvector matrix of the conformation tensor - M is the velocity gradient tensor in the eigenvector basis - The construction ensures B is symmetric and traceless pseudo_t B ; double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi . x . y []; Psi . x . y [] += dt *( 2. * B . x . y + OM *( Psi . y . y [] - Psi . x . x [])); foreach_dimension () { s *= - 1 ; Psi . x . x [] += dt * 2. *( B . x . x + s * OM ); } In the axisymmetric case, the governing equation for \\(\\Psi_{\\theta \\theta}\\) only involves that component, \\[ \\Psi_{\\theta \\theta}|_t - 2 L_{\\theta \\theta} = \\frac{\\mathbf{f}_r(e^{-\\Psi_{\\theta \\theta}})}{\\lambda} \\] with \\(L_{\\theta \\theta} = u_y/y\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Therefore step (a)...",
    "content": "Therefore step (a) for \\(\\Psi_{\\theta \\theta}\\) is #if AXI Psiqq [] += dt * 2. * u . y []/ max ( y , 1e-20 ); #endif } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . #if AXI advection ({ Psi . x . x , Psi . x . y , Psi . y . y , Psiqq }, uf , dt ); #else advection ({ Psi . x . x , Psi . x . y , Psi . y . y }, uf , dt ); #endif Convert back to _p foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi . x . x [], Psi . x . y []}, { Psi . y . x [], Psi . y . y []}}, R ; pseudo_v Lambda ; diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; #if AXI double Aqq = exp ( Psiqq []); #endif We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); #if AXI Aqq = ( 1. - intFactor ) + intFactor * exp ( Psiqq []); #endif A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . conform_p . x . y [] = A . x . y ; tau_p . x . y [] = Gp []* A . x . y ; #if AXI conform_qq [] = Aqq ; tau_qq [] = Gp []*( Aqq - 1. ); #endif foreach_dimension (){ conform_p . x . x [] = A . x . x ; tau_p . x . x [] = Gp []*( A . x . x - 1. ); } } } Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{\\tau}_p\\) is defined at cell centers while the corresponding force (acceleration) will be defined at cell faces. Two terms contribute to each component of the momentum equation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "For example the \\(x\\) -component in Cartesian coordinates has the following terms: \\(\\partial_x \\mathbf{\\tau}_{p_{xx}} + \\partial_y \\mathbf{\\tau}_{p_{xy}}\\) . The first term is easy to compute since it can be calculated directly from center values of cells sharing the face. The other one is harder. It will be computed from vertex values. The vertex values are obtained by averaging centered values.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Note that as a result of the vertex averaging cells [] and [-1,0] are not involved in the computation of shear. event acceleration ( i ++) { face vector av = a ; foreach_face () if ( fm . x [] > 1e-20 ) { double shear = ( tau_p . x . y [ 0 , 1 ]* cm [ 0 , 1 ] + tau_p . x . y [- 1 , 1 ]* cm [- 1 , 1 ] - tau_p . x . y [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - tau_p . x . y [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . x [] += ( shear + cm []* tau_p . x . x [] - cm [- 1 ]* tau_p . x . x [- 1 ])* alpha . x []/( sq ( fm . x [])* Delta ); } #if AXI foreach_face ( y ) if ( y > 0. ) av . y [] -= ( tau_qq [] + tau_qq [ 0 ,- 1 ])* alpha . y []/ sq ( y )/ 2. ; #endif }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: C/C++ Code",
    "content": "#include\"bcg.h\"#if dimension ==#error \"This implementation does not support 3D due to missing tensor boundary conditions in Basilisk (see cartesian-common.h line ~246).",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: Context",
    "content": "Use log-conform-viscoelastic-scalar-3D.h for 3D simulations.\"#endif(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation timesymmetric tensor conform_p[],tau_p[];#if AXIscalar conform_qq[],tau_qq[];#endifevent defaults(i=0){if(is_constant(a.x))a=new face vector;foreach(){foreach_dimension(){tau_p.x.x[]=0.;conform_p.x.x[]=1.;}tau_p.x.y[]=0.;conform_p.x.y[]=0.;#if AXItau_qq[]=0;conform_qq[]=1.;#endif}for(scalar s in{tau_p}){s.v.x.i=-1;// just a scalar, not the component of a vectorforeach_dimension(){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}}for(scalar s in{conform_p}){s.v.x.i=-1;// just a scalar, not the component of a vectorforeach_dimension(){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}}#if AXIscalar s1=tau_p.x.y;s1[bottom]=dirichlet(0.);#endif#if AXIscalar s2=conform_p.x.y;s2[bottom]=dirichlet(0.);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event tracer_advection(i++){tensor Psi=conform_p;#if AXIscalar Psiqq=conform_qq;#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A;A.x.y=conform_p.x.y[];foreach_dimension()A.x.x=conform_p.x.x[];",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if AXIdoubleAqq=conform_qq[];Psiqq[]=log(Aqq);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_v Lambda;pseudo_t R;diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue.Please report this bug by opening an issue on the GitHub repository.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"Negative eigenvalue detected: Lambda.x =%g, Lambda.y =%g\\n\",Lambda.x,Lambda.y);fprintf(ferr,\"x =%g, y =%g\\n\",x,y);exit(1);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "Psi.x.y[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);foreach_dimension()Psi.x.x[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "pseudo_t B;doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubles=-Psi.x.y[];Psi.x.y[]+=dt*(2.*B.x.y+OM*(Psi.y.y[]-Psi.x.x[]));foreach_dimension(){s*=-1;Psi.x.x[]+=dt*2.*(B.x.x+s*OM);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if AXIadvection({Psi.x.x,Psi.x.y,Psi.y.y,Psiqq},uf,dt);#elseadvection({Psi.x.x,Psi.x.y,Psi.y.y},uf,dt);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A={{Psi.x.x[],Psi.x.y[]},{Psi.y.x[],Psi.y.y[]}},R;pseudo_v Lambda;diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;#if AXIdoubleAqq=exp(Psiqq[]);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);#if AXIAqq=(1.-intFactor)+intFactor*exp(Psiqq[]);#endifA.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "conform_p.x.y[]=A.x.y;tau_p.x.y[]=Gp[]*A.x.y;#if AXIconform_qq[]=Aqq;tau_qq[]=Gp[]*(Aqq-1.);#endifforeach_dimension(){conform_p.x.x[]=A.x.x;tau_p.x.x[]=Gp[]*(A.x.x-1.);}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event acceleration(i++){face vector av=a;foreach_face()if(fm.x[]>1e-20){doubleshear=(tau_p.x.y[0,1]*cm[0,1]+tau_p.x.y[-1,1]*cm[-1,1]-tau_p.x.y[0,-1]*cm[0,-1]-tau_p.x.y[-1,-1]*cm[-1,-1])/4.;av.x[]+=(shear+cm[]*tau_p.x.x[]-cm[-1]*tau_p.x.x[-1])*alpha.x[]/(sq(fm.x[])*Delta);}#if AXIforeach_face(y)if(y>0.)av.y[]-=(tau_qq[]+tau_qq[0,-1])*alpha.y[]/sq(y)/2.;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "src-local/log-conform-viscoelastic-scalar-2D.h See raw file Log-Conformation Method for 2D Viscoelastic Fluids Overview Title : log-conform-viscoelastic-scalar-2D.h Version : 2.5 Description : 2D and axisymmetric scalar implementation of viscoelastic fluid dynamics using the log-conformation method Key Features Conformation tensor A exists across domain and relaxes according to \u03bb Stress acts according to elastic modulus G Supports both 2D and axisymmetric configurations Scalar implementation approach for better performance Compatible with log-conform-viscoelastic.h Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Nov 23, 2024 Implementation Notes Based on http://basilisk.fr/src/log-conform.h with key improvements: Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling bug where [\u03c3_p] = 0 & [\u03c3_s] = \u03b3\u03ba Ensures [\u03c3_s+\u03c3_p] = \u03b3\u03ba for correct interface behavior Version History v1.0 (Oct 18, 2024) Initial implementation with 2D+axi support Scalar-based implementation for efficiency v2.0 (Nov 3, 2024) Major documentation improvements Made code an axisymmetric mirror of log-conform-viscoelastic-scalar-3D.h Added negative eigenvalue detection with location reporting Added initialization functions for pseudo_v and pseudo_t v2.1 (Nov 14, 2024) Added support for infinite Deborah number cases v2.5 (Nov 23, 2024) Enhanced documentation clarity and completeness Future Work Tensor Formulation Convert to consistent tensor formulation for: Improved readability and maintainability Better computational efficiency Reduced potential for bugs Prerequisites for axi compatibility in 3D version Related issues: https://github.com/comphy-lab/Viscoelastic3D/issues/11 https://github.com/comphy-lab/Viscoelastic3D/issues/5 Code Improvements Enforce tensor usage throughout codebase Implement foreach_dimension compatibility The log-conformation method for viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Therefore these materials...",
    "content": "Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers. Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The conformation tensor...",
    "content": "The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time. In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Parameters The primary...",
    "content": "Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features. This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: TODO: - Perhaps,...",
    "content": "TODO: - Perhaps, instead of the Bell\u2013Collela\u2013Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to http://basilisk.fr/src/navier-stokes/conserving.h #include \"bcg.h\" ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time scalar A11 [], A12 [], A22 []; // conformation tensor scalar T11 [], T12 [], T22 []; // stress tensor #if AXI scalar AThTh [], T_ThTh []; #endif event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; /* initialize A and T */ for ( scalar s in { A11 , A22 }) { foreach () { s [] = 1. ; } } for ( scalar s in { T11 , T12 , T22 , A12 }) { foreach (){ s [] = 0. ; } } #if AXI foreach (){ T_ThTh [] = 0 ; AThTh [] = 1. ; } #endif for ( scalar s in { T11 , T12 , T22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } for ( scalar s in { A11 , A12 , A22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } #if AXI T12 [ bottom ] = dirichlet ( 0. ); A12 [ bottom ] = dirichlet ( 0. ); #endif } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } The stress tensor depends on previous instants and has to be integrated in time. In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We use a...",
    "content": "We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ).",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In an Oldroyd-B...",
    "content": "In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] event tracer_advection ( i ++) { scalar Psi11 = A11 ; scalar Psi12 = A12 ; scalar Psi22 = A22 ; #if AXI scalar Psiqq = AThTh ; #endif Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A ; A . x . x = A11 []; A . y . y = A22 []; A . x . y = A12 []; #if AXI double Aqq = AThTh []; Psiqq [] = log ( Aqq ); #endif The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); pseudo_t R ; init_pseudo_t (& R , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues -- this should never happen.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: If it does,...",
    "content": "If it does, print the location and value of the offending eigenvalue. Please report this bug by opening an issue on the GitHub repository. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"Negative eigenvalue detected: Lambda.x = %g , Lambda.y = %g\\n \" , Lambda . x , Lambda . y ); fprintf ( ferr , \"x = %g , y = %g\\n \" , x , y ); exit ( 1 ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) . Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); Psi22 [] = sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . x )* log ( Lambda . x ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The diagonalization will...",
    "content": "The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis. Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: R is the eigenvector matrix of the conformation tensor M is the velocity gradient tensor in the eigenvector basis The construction ensures B is symmetric and traceless pseudo_t B ; init_pseudo_t (& B , 0.0 ); double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; init_pseudo_t (& M , 0.0 ); foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi12 []; Psi12 [] += dt * ( 2. * B . x . y + OM * ( Psi22 [] - Psi11 [])); s *= - 1 ; Psi11 [] += dt * 2. * ( B . x . x + s * OM ); s *= - 1 ; Psi22 [] += dt * 2. * ( B . y . y + s * OM ); In the axisymmetric case, the governing equation for \\(\\Psi_{\\theta \\theta}\\) only involves that component, \\[ \\Psi_{\\theta \\theta}|_t - 2 L_{\\theta \\theta} = \\frac{\\mathbf{f}_r(e^{-\\Psi_{\\theta \\theta}})}{\\lambda} \\] with \\(L_{\\theta \\theta} = u_y/y\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Therefore step (a)...",
    "content": "Therefore step (a) for \\(\\Psi_{\\theta \\theta}\\) is #if AXI Psiqq [] += dt * 2. * u . y []/ max ( y , 1e-20 ); #endif } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . #if AXI advection ({ Psi11 , Psi12 , Psi22 , Psiqq }, uf , dt ); #else advection ({ Psi11 , Psi12 , Psi22 }, uf , dt ); #endif Convert back to Aij foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi11 [], Psi12 []}, { Psi12 [], Psi22 []}}, R ; init_pseudo_t (& R , 0.0 ); pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; #if AXI double Aqq = exp ( Psiqq []); #endif We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); #if AXI Aqq = ( 1. - intFactor ) + intFactor * exp ( Psiqq []); #endif A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . A12 [] = A . x . y ; T12 [] = Gp []* A . x . y ; #if AXI AThTh [] = Aqq ; T_ThTh [] = Gp []*( Aqq - 1. ); #endif A11 [] = A . x . x ; T11 [] = Gp []*( A . x . x - 1. ); A22 [] = A . y . y ; T22 [] = Gp []*( A . y . y - 1. ); } } Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{\\tau}_p\\) is defined at cell centers while the corresponding force (acceleration) will be defined at cell faces. Two terms contribute to each component of the momentum equation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "For example the \\(x\\) -component in Cartesian coordinates has the following terms: \\(\\partial_x \\mathbf{\\tau}_{p_{xx}} + \\partial_y \\mathbf{\\tau}_{p_{xy}}\\) . The first term is easy to compute since it can be calculated directly from center values of cells sharing the face. The other one is harder. It will be computed from vertex values. The vertex values are obtained by averaging centered values.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Note that as a result of the vertex averaging cells [] and [-1,0] are not involved in the computation of shear. event acceleration ( i ++) { face vector av = a ; foreach_face ( x ){ if ( fm . x [] > 1e-20 ) { double shearX = ( T12 [ 0 , 1 ]* cm [ 0 , 1 ] + T12 [- 1 , 1 ]* cm [- 1 , 1 ] - T12 [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . x [] += ( shearX + cm []* T11 [] - cm [- 1 ]* T11 [- 1 ])* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ){ if ( fm . y [] > 1e-20 ) { double shearY = ( T12 [ 1 , 0 ]* cm [ 1 , 0 ] + T12 [ 1 ,- 1 ]* cm [ 1 ,- 1 ] - T12 [- 1 , 0 ]* cm [- 1 , 0 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . y [] += ( shearY + cm []* T22 [] - cm [ 0 ,- 1 ]* T22 [ 0 ,- 1 ])* alpha . y []/( sq ( fm . y [])* Delta ); } } #if AXI foreach_face ( y ) if ( y > 1e-20 ) av . y [] -= ( T_ThTh [] + T_ThTh [ 0 ,- 1 ])* alpha . y []/ sq ( y )/ 2. ; #endif }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: C/C++ Code",
    "content": "#include\"bcg.h\"(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation timescalar A11[],A12[],A22[];// conformation tensorscalar T11[],T12[],T22[];// stress tensor#if AXIscalar AThTh[],T_ThTh[];#endifevent defaults(i=0){if(is_constant(a.x))a=new face vector;/*initialize A and T*/for(scalar s in{A11,A22}){foreach(){s[]=1.;}}for(scalar s in{T11,T12,T22,A12}){foreach(){s[]=0.;}}#if AXIforeach(){T_ThTh[]=0;AThTh[]=1.;}#endiffor(scalar s in{T11,T12,T22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}for(scalar s in{A11,A12,A22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}#if AXIT12[bottom]=dirichlet(0.);A12[bottom]=dirichlet(0.);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event tracer_advection(i++){scalar Psi11=A11;scalar Psi12=A12;scalar Psi22=A22;#if AXIscalar Psiqq=AThTh;#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A;A.x.x=A11[];A.y.y=A22[];A.x.y=A12[];#if AXIdoubleAqq=AThTh[];Psiqq[]=log(Aqq);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);pseudo_t R;init_pseudo_t(&R,0.0);diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue.Please report this bug by opening an issue on the GitHub repository.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"Negative eigenvalue detected: Lambda.x =%g, Lambda.y =%g\\n\",Lambda.x,Lambda.y);fprintf(ferr,\"x =%g, y =%g\\n\",x,y);exit(1);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);Psi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);Psi22[]=sq(R.y.y)*log(Lambda.y)+sq(R.y.x)*log(Lambda.x);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "pseudo_t B;init_pseudo_t(&B,0.0);doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;init_pseudo_t(&M,0.0);foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubles=-Psi12[];Psi12[]+=dt*(2.*B.x.y+OM*(Psi22[]-Psi11[]));s*=-1;Psi11[]+=dt*2.*(B.x.x+s*OM);s*=-1;Psi22[]+=dt*2.*(B.y.y+s*OM);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if AXIadvection({Psi11,Psi12,Psi22,Psiqq},uf,dt);#elseadvection({Psi11,Psi12,Psi22},uf,dt);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A={{Psi11[],Psi12[]},{Psi12[],Psi22[]}},R;init_pseudo_t(&R,0.0);pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;#if AXIdoubleAqq=exp(Psiqq[]);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);#if AXIAqq=(1.-intFactor)+intFactor*exp(Psiqq[]);#endifA.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A12[]=A.x.y;T12[]=Gp[]*A.x.y;#if AXIAThTh[]=Aqq;T_ThTh[]=Gp[]*(Aqq-1.);#endifA11[]=A.x.x;T11[]=Gp[]*(A.x.x-1.);A22[]=A.y.y;T22[]=Gp[]*(A.y.y-1.);}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event acceleration(i++){face vector...",
    "content": "event acceleration(i++){face vector av=a;foreach_face(x){if(fm.x[]>1e-20){doubleshearX=(T12[0,1]*cm[0,1]+T12[-1,1]*cm[-1,1]-T12[0,-1]*cm[0,-1]-T12[-1,-1]*cm[-1,-1])/4.;av.x[]+=(shearX+cm[]*T11[]-cm[-1]*T11[-1])*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){doubleshearY=(T12[1,0]*cm[1,0]+T12[1,-1]*cm[1,-1]-T12[-1,0]*cm[-1,0]-T12[-1,-1]*cm[-1,-1])/4.;av.y[]+=(shearY+cm[]*T22[]-cm[0,-1]*T22[0,-1])*alpha.y[]/(sq(fm.y[])*Delta);}}#if AXIforeach_face(y)if(y>1e-20)av.y[]-=(T_ThTh[]+T_ThTh[0,-1])*alpha.y[]/sq(y)/2.;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "src-local/two-phaseVE.h See raw file Modification by Vatsal Sanjay Version 2.0, Oct 17, 2024 Changelog Oct 17, 2024: added support for VE simulations. Brief history v1.0 is the vanilla Basilisk code for two-phase flows: http://basilisk.fr/src/two-phase.h + http://basilisk.fr/src/two-phase-generic.h v2.0 is the modification for viscoelastic fluids using the log-conformation method. Two-phase interfacial flows This is a modified version of two-phase.h . It contains the implementation of Viscoplastic Fluid (Bingham Fluid). This file helps setup simulations for flows of two fluids separated by an interface (i.e. immiscible fluids). It is typically used in combination with a Navier\u2013Stokes solver . The interface between the fluids is tracked with a Volume-Of-Fluid method. The volume fraction in fluid 1 is \\(f=1\\) and \\(f=0\\) in fluid 2.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: C/C++ Code",
    "content": "The densities and dynamic viscosities for fluid 1 and 2 are rho1 , mu1 , rho2 , mu2 , respectively. #include \"vof.h\" scalar f [], * interfaces = { f }; double rho1 = 1. , mu1 = 0. , rho2 = 1. , mu2 = 0. ; double G1 = 0. , G2 = 0. ; // elastic moduli double lambda1 = 0. , lambda2 = 0. ; // relaxation times double TOLelastic = 1e-2 ; // tolerance for elastic modulus #TOFIX: this must always be a very small number. Auxilliary fields are necessary to define the (variable) specific volume \\(\\alpha=1/\\rho\\) as well as the cell-centered density. face vector alphav []; scalar rhov []; scalar Gpd []; scalar lambdapd []; event defaults ( i = 0 ) { alpha = alphav ; rho = rhov ; Gp = Gpd ; lambda = lambdapd ; If the viscosity is non-zero, we need to allocate the face-centered viscosity field. mu = new face vector ; } The density and viscosity are defined using arithmetic averages by default.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Definitions - Python Function",
    "content": "The user can overload these definitions to use other types of averages (i.e. harmonic). #ifndef rho # define rho ( f ) ( clamp ( f , 0. , 1. )*( rho1 - rho2 ) + rho2 ) 62 #endif #ifndef mu // for Arithmetic mean, use this # define mu ( f ) ( clamp ( f , 0. , 1. )*( mu1 - mu2 ) + mu2 ) 66 #endif We have the option of using some \u201csmearing\u201d of the density/viscosity jump. #ifdef FILTERED scalar sf []; #else # define sf f 76 #endif event tracer_advection ( i ++) { When using smearing of the density jump, we initialise sf with the vertex-average of f . #ifndef sf #if dimension <= foreach () sf [] = ( 4. * f [] + 2. *( f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 1 , 0 ] + f [- 1 , 0 ]) + f [- 1 ,- 1 ] + f [ 1 ,- 1 ] + f [ 1 , 1 ] + f [- 1 , 1 ])/ 16. ; #else // dimension == foreach () sf [] = ( 8. * f [] + 4. *( f [- 1 ] + f [ 1 ] + f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 0 , 0 , 1 ] + f [ 0 , 0 ,- 1 ]) + 2. *( f [- 1 , 1 ] + f [- 1 , 0 , 1 ] + f [- 1 , 0 ,- 1 ] + f [- 1 ,- 1 ] + f [ 0 , 1 , 1 ] + f [ 0 , 1 ,- 1 ] + f [ 0 ,- 1 , 1 ] + f [ 0 ,- 1 ,- 1 ] + f [ 1 , 1 ] + f [ 1 , 0 , 1 ] + f [ 1 ,- 1 ] + f [ 1 , 0 ,- 1 ]) + f [ 1 ,- 1 , 1 ] + f [- 1 , 1 , 1 ] + f [- 1 , 1 ,- 1 ] + f [ 1 , 1 , 1 ] + f [ 1 , 1 ,- 1 ] + f [- 1 ,- 1 ,- 1 ] + f [ 1 ,- 1 ,- 1 ] + f [- 1 ,- 1 , 1 ])/ 64. ; #endif #endif #if TREE sf . prolongation = refine_bilinear ; sf . dirty = true ; // boundary conditions need to be updated #endif } event properties ( i ++) { foreach_face () { double ff = ( sf [] + sf [- 1 ])/ 2. ; alphav . x [] = fm . x []/ rho ( ff ); face vector muv = mu ; muv . x [] = fm . x []* mu ( ff ); } foreach (){ rhov [] = cm []* rho ( sf []); Gpd [] = 0. ; lambdapd [] = 0. ; if ( clamp ( sf [], 0. , 1. ) > TOLelastic ){ Gpd [] += G1 * clamp ( sf [], 0. , 1. ); lambdapd [] += lambda1 * clamp ( sf [], 0. , 1. ); } if ( clamp (( 1 - sf []), 0. , 1. ) > TOLelastic ){ Gpd [] += G2 * clamp (( 1 - sf []), 0. , 1. ); lambdapd [] += lambda2 * clamp (( 1 - sf []), 0. , 1. ); } } #if TREE sf . prolongation = fraction_refine ; sf . dirty = true ; // boundary conditions need to be updated #endif }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#include\"vof.h\"scalar f[],*interfaces={f};doublerho1=1.,mu1=0.,rho2=1.,mu2=0.;doubleG1=0.,G2=0.;// elastic modulidoublelambda1=0.,lambda2=0.;// relaxation timesdoubleTOLelastic=1e-2;// tolerance for elastic modulus #TOFIX: this must always be a very small number.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "face vector alphav[];scalar rhov[];scalar Gpd[];scalar lambdapd[];event defaults(i=0){alpha=alphav;rho=rhov;Gp=Gpd;lambda=lambdapd;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Function: rho",
    "content": "#ifndef rho# define rho(f)(clamp(f,0.,1.)*(rho1-rho2)+rho2)62#endif#ifndef mu// for Arithmetic mean, use this# define mu(f)(clamp(f,0.,1.)*(mu1-mu2)+mu2)66#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Function: FILTEREDscalar",
    "content": "#ifdef FILTEREDscalar sf[];#else# define sf f76#endifevent tracer_advection(i++){",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Function: sf",
    "content": "#ifndef sf#if dimension <=foreach()sf[]=(4.*f[]+2.*(f[0,1]+f[0,-1]+f[1,0]+f[-1,0])+f[-1,-1]+f[1,-1]+f[1,1]+f[-1,1])/16.;#else// dimension ==foreach()sf[]=(8.*f[]+4.*(f[-1]+f[1]+f[0,1]+f[0,-1]+f[0,0,1]+f[0,0,-1])+2.*(f[-1,1]+f[-1,0,1]+f[-1,0,-1]+f[-1,-1]+f[0,1,1]+f[0,1,-1]+f[0,-1,1]+f[0,-1,-1]+f[1,1]+f[1,0,1]+f[1,-1]+f[1,0,-1])+f[1,-1,1]+f[-1,1,1]+f[-1,1,-1]+f[1,1,1]+f[1,1,-1]+f[-1,-1,-1]+f[1,-1,-1]+f[-1,-1,1])/64.;#endif#endif#if TREEsf.prolongation=refine_bilinear;sf.dirty=true;// boundary conditions need to be updated#endif}event properties(i++){foreach_face(){doubleff=(sf[]+sf[-1])/2.;alphav.x[]=fm.x[]/rho(ff);face vector muv=mu;muv.x[]=fm.x[]*mu(ff);}foreach(){rhov[]=cm[]*rho(sf[]);Gpd[]=0.;lambdapd[]=0.;if(clamp(sf[],0.,1.)>TOLelastic){Gpd[]+=G1*clamp(sf[],0.,1.);lambdapd[]+=lambda1*clamp(sf[],0.,1.);}if(clamp((1-sf[]),0.,1.)>TOLelastic){Gpd[]+=G2*clamp((1-sf[]),0.,1.);lambdapd[]+=lambda2*clamp((1-sf[]),0.,1.);}}#if TREEsf.prolongation=fraction_refine;sf.dirty=true;// boundary conditions need to be updated#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # tested on MacOS only.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue. # modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk # Check if --hard flag is passed HARD_RESET = \\f alse if [[ \" \\$ 1\" == \"--hard\" ]]; then HARD_RESET = \\t rue fi # Function to install basilisk install_basilisk() { darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make } # Remove project config always rm -rf .project_config # Check if basilisk needs to be installed if [[ \" \\$ HARD_RESET\" == true ]] || [[ ! -d \"basilisk\" ]]; then echo \"Installing basilisk...\" rm -rf basilisk install_basilisk else echo \"Using existing basilisk installation...\" cd basilisk/src fi # Setup environment variables echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config # Check if qcc is working properly echo \"\\nChecking qcc installation...\" if ! qcc --version > /dev/null 2 >& 1 ; then echo \"\\033[0;31mError: qcc is not working properly.\\033[0m\" echo \"Please ensure you have Xcode Command Line Tools installed.\" echo \"You can install them by running: xcode-select --install\" echo \"For more details, visit: http://basilisk.fr/src/INSTALL\" exit 1 else echo \"\\033[0;32mqcc is properly installed.\\033[0m\" qcc --version fi",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: #!/bin/zsh# tested on...",
    "content": "#!/bin/zsh# tested on MacOS only.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue.# modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basilisk# Check if --hard flag is passedHARD_RESET=\\falseif[[\"\\$1\"==\"--hard\"]];thenHARD_RESET=\\truefi# Function to install basiliskinstall_basilisk(){darcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake}# Remove project config alwaysrm-rf.project_config# Check if basilisk needs to be installedif[[\"\\$HARD_RESET\"==true]]||[[!-d\"basilisk\"]];thenecho\"Installing basilisk...\"rm-rfbasiliskinstall_basiliskelseecho\"Using existing basilisk installation...\"cdbasilisk/srcfi# Setup environment variablesecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config# Check if qcc is working properlyecho\"\\nChecking qcc installation...\"if!qcc--version>/dev/null2>&1;thenecho\"\\033[0;31mError: qcc is not working properly.\\033[0m\"echo\"Please ensure you have Xcode Command Line Tools installed.\"echo\"You can install them by running: xcode-select --install\"echo\"For more details, visit: http://basilisk.fr/src/INSTALL\"exit1elseecho\"\\033[0;32mqcc is properly installed.\\033[0m\"qcc--versionfi",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Viscoelastic Worthington Jets...",
    "content": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles This repository contains the simulation code and analysis for studying the dynamics of viscoelastic Worthington jets and droplets produced by bursting bubbles. The code uses the ElastoFlow framework to simulate bubble cavity collapse in viscoelastic media, examining how elastic modulus and relaxation time affect jet and droplet formation. The article can be found at: Overview The project investigates how viscoelasticity influences bubble bursting dynamics by exploring the three-dimensional phase space of solvent Ohnesorge number, elastocapillary number, and Deborah number using volume of fluid-based finite volume simulations. The results demonstrate that polymer addition significantly influences the overall dynamics through the interplay of viscous and elastic effects.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Repository Structure basilisk/src/...",
    "content": "Repository Structure basilisk/src/ - # Core Basilisk CFD library (reference only, do not modify) src-local/ - # Custom viscoelastic solvers and tensor utilities log-conform-viscoelastic-scalar-3D.h - # 3D log-conformation (scalar) log-conform-viscoelastic-scalar-2D.h - # 2D/axi log-conformation (scalar) log-conform-viscoelastic.h - # 2D/axi log-conformation (tensor) two-phaseVE.h - # Two-phase viscoelastic extension eigen_decomposition.h - # 3x3 symmetric eigenvalue solver simulationCases/ - # Example/test cases and post-processing scripts burstingBubbleVE.c - # Bursting bubble simulation postProcess/ - # Project-specific post-processing tools and utilities getData-elastic-scalar2D.c - # Data extraction utility getFacet2D.c - # Facet extraction utility VideoAxi.py - # Python visualization script Installation and Setup To ensure you have the necessary tools and a fresh Basilisk installation, use the provided script: ./reset_install_requirements.sh Function This script checks for Basilisk installation and compiles it if not present.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: OS Compatibility Designed...",
    "content": "OS Compatibility Designed for macOS. If you encounter issues on Linux, consider opening a GitHub issue. Dependencies Basilisk C is fetched and built automatically. Xcode Command Line Tools (macOS) or equivalent compiler toolchain (Linux) are required. Environment Setup After running the script, a .project_config file is created, setting BASILISK and PATH automatically.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "If you have previously installed Basilisk or changed dependencies, re-run the script with --hard : ./reset_install_requirements.sh --hard Running the Code Recommended Method: Using Makefile The easiest way to compile and run the code is using the Makefile approach: Navigate to the testCases directory: cd testCases Compile and run using make: CFLAGS = -DDISPLAY=-1 make burstingBubbleVE.tst Alternative Method: Direct Compilation You can compile the code directly using qcc in two ways: Using include paths (recommended): qcc -O2 -Wall -disable-dimensions -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm Without include paths: qcc -O2 -Wall -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm Note : If using method 2, you must first manually copy the src-local folder to your running directory.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Local Execution MacOS:...",
    "content": "Local Execution MacOS: # First source the configuration source .project_config # Compile using include paths (recommended) qcc -O2 -Wall -disable-dimensions -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm # Or compile without include paths (requires manually copying src-local folder) qcc -O2 -Wall -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm # Run the executable, only supports serial execution ./burstingBubbleVE Linux: # First source the configuration source .project_config # Compile using include paths (recommended) qcc -O2 -Wall -disable-dimensions -fopenmp -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm # Or compile without include paths (requires manually copying src-local folder) qcc -O2 -Wall -disable-dimensions -fopenmp burstingBubbleVE.c -o burstingBubbleVE -lm # Set the number of OpenMP threads export OMP_NUM_THREADS = 4 # Run the executable ./burstingBubbleVE HPC Cluster Execution (e.g., Snellius) For cluster environments, it is strongly recommended to manually copy the src-local folder to your working directory to ensure reliable compilation across different cluster configurations: First, copy the required files: cp -r /path/to/original/src-local .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Compile the code...",
    "content": "Compile the code for MPI: CC99 = 'mpicc -std=c99' qcc -Wall -O2 -D_MPI = 1 -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm Create a SLURM job script (e.g., run_simulation.sh ): #!/bin/bash #SBATCH --nodes=1 #SBATCH --ntasks=32 #SBATCH --time=1:00:00 #SBATCH --partition=genoa #SBATCH --mail-type=ALL #SBATCH --mail-user=v.sanjay@utwente.nl srun --mpi = pmi2 -n 32 --gres = cpu:32 --mem-per-cpu = 1750mb burstingBubbleVE Submit the job: sbatch run_simulation.sh Additional Running Scripts The z_extras/running directory contains supplementary materials and post-processing tools used in the analysis. This includes C-based data extraction utilities, Python visualization scripts, and analysis notebooks. These tools were used to process simulation outputs and generate figures for the study. For detailed documentation of these tools, see the README in the z_extras directory.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Reset Install Requirements...",
    "content": "Reset Install Requirements Script The reset_install_requirements.sh script is designed to reset the installation requirements for the project. This can be useful when you want to ensure that all dependencies are fresh and up-to-date. Purpose The script re-installs all required packages as specified in the requirements file, ensuring that the project\u2019s dependencies are up-to-date and consistent. Usage To run the script, use the following command in your terminal: bash reset_install_requirements.sh Make sure to have the necessary permissions to execute the script. Citation If you use this code in your research, please cite: Paper @article { Dixit_Oratis_Zinelis_Lohse_Sanjay_2025 , title ={Viscoelastic Worthington jets and droplets produced by bursting bubbles}, volume ={1010}, journal ={J. Fluid Mech.}, author ={Dixit, A.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "K. and Oratis, A. and Zinelis, K. and Lohse, D. and Sanjay, V.}, year ={2025}, pages ={A2}, DOI ={10.1017/jfm.2025.237}} Software @software{vatsal_sanjay_2024_14210635, author = {Vatsal Sanjay}, title = {{comphy-lab/Viscoelastic3D: \ud83c\udf0a v2.5: ElastoFlow - Complete 2D/3D Viscoelastic Framework}}, month = nov, year = 2024, publisher = {Zenodo}, version = {v2.5}, doi = {10.5281/zenodo.14210635}, url = {https://doi.org/10.5281/zenodo.14210635} } Features Simulation of bubble cavity collapse in viscoelastic media Analysis of Worthington jet formation and droplet ejection Investigation of polymer effects through: Elastic modulus (elastocapillary number) Relaxation time (Deborah number) Viscous effects (Ohnesorge number) Dependencies The code utilizes: - Basilisk C ( basilliskpopinet ) - Volume of Fluid (VoF) method for interface tracking - Adaptive Mesh Refinement (AMR) with quadtree grids Key Results The simulations reveal: 1.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: JavaScript",
    "content": "Three distinct flow regimes: - Jets forming droplets - Jets without droplet formation - Absence of jet formation 2. Impact of viscoelasticity on: - Capillary wave propagation - Jet elongation and retraction - Droplet formation and size Additional Resources The z_extras directory contains supplementary materials and post-processing tools used in the analysis. This includes C-based data extraction utilities, Python visualization scripts, and analysis notebooks. These tools were used to process simulation outputs and generate figures for the study. For detailed documentation of these tools, see the README in the z_extras directory. Authors Ayush K.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Dixit (University of...",
    "content": "Dixit (University of Twente), a.k.dixit@utwente.nl Alexandros Oratis (University of Twente, now TU Delft), a.t.oratis@tudelft.nl Konstantinos Zinelis (Imperial College London, now MIT), zinelis@mit.edu Detlef Lohse (University of Twente & Max Planck Institute), d.lohse@utwente.nl Vatsal Sanjay (University of Twente), vatsalsanjay@gmail.com License This project is licensed under standard academic terms. Please cite the paper and software if you use this code in your research. Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/VideoAxi.py postProcess/getData-elastic-scalar2D.c postProcess/getFacet2D.c simulationCases simulationCases/Makefile simulationCases/burstingBubbleVE.c simulationCases/runCodesInParallel.sh src-local src-local/eigen_decomposition.h src-local/log-conform-viscoelastic-scalar-2D.h src-local/log-conform-viscoelastic-scalar-3D.h src-local/log-conform-viscoelastic.h src-local/two-phaseVE.h",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "qcc-O2-Wall-disable-dimensions-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "qcc-O2-Wall-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# First source the configurationsource.project_config# Compile using include paths (recommended)qcc-O2-Wall-disable-dimensions-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm# Or compile without include paths (requires manually copying src-local folder)qcc-O2-Wall-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm# Run the executable, only supports serial execution./burstingBubbleVE",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# First source the configurationsource.project_config# Compile using include paths (recommended)qcc-O2-Wall-disable-dimensions-fopenmp-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm# Or compile without include paths (requires manually copying src-local folder)qcc-O2-Wall-disable-dimensions-fopenmpburstingBubbleVE.c-oburstingBubbleVE-lm# Set the number of OpenMP threadsexportOMP_NUM_THREADS=4# Run the executable./burstingBubbleVE",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "CC99='mpicc -std=c99'qcc-Wall-O2-D_MPI=1-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#!/bin/bash#SBATCH --nodes=1#SBATCH --ntasks=32#SBATCH --time=1:00:00#SBATCH --partition=genoa#SBATCH --mail-type=ALL#SBATCH --mail-user=v.sanjay@utwente.nlsrun--mpi=pmi2-n32--gres=cpu:32--mem-per-cpu=1750mb burstingBubbleVE",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "@article{Dixit_Oratis_Zinelis_Lohse_Sanjay_2025,title={Viscoelastic Worthington jets and droplets produced by bursting bubbles},volume={1010},journal={J. Fluid Mech.},author={Dixit, A. K. and Oratis, A. and Zinelis, K. and Lohse, D. and Sanjay, V.},year={2025},pages={A2},DOI={10.1017/jfm.2025.237}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "@software{vatsal_sanjay_2024_14210635,author       = {Vatsal Sanjay},title        = {{comphy-lab/Viscoelastic3D: \ud83c\udf0a v2.5: ElastoFlow -Complete 2D/3D Viscoelastic Framework}},month        = nov,year         = 2024,publisher    = {Zenodo},version      = {v2.5},doi          = {10.5281/zenodo.14210635},url          = {https://doi.org/10.5281/zenodo.14210635}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "simulationCases/burstingBubbleVE.c See raw file Bursting Bubbles in Viscoelastic Media Simulation This simulation models the dynamics of bursting bubbles in viscoelastic media using the Basilisk framework. It particularly focuses on the formation of Worthington jets and droplets that emerge during the bursting process. Physics Overview The simulation implements a two-phase flow model with viscoelastic properties, utilizing the log-conformation approach for numerical stability. This approach preserves the positive-definiteness of the conformation tensor, which is crucial for stable simulations of viscoelastic fluids at high Deborah numbers. For theoretical details, see: V.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Sanjay, Zenodo, DOI:...",
    "content": "Sanjay, Zenodo, DOI: 10.5281/zenodo.14210635 (2024) Usage ./program maxLevel De Ec Oh Bond tmax Where: - maxLevel : Maximum refinement level for adaptive mesh - De : Deborah number (ratio of relaxation time to flow time) - Ec : Elasto-capillary number (ratio of elastic to surface tension forces) - Oh : Ohnesorge number (ratio of viscous to inertial-capillary forces) - Bond : Bond number (ratio of gravitational to surface tension forces) - tmax : Maximum simulation time @file burstingBubbleVE.c @author Vatsal Sanjay and Ayush Dixit @version 1.0 @date Nov 23, 2024 - Work used in the paper: DOI: 10.1017/jfm.2025.237 #include \"axi.h\" #include \"navier-stokes/centered.h\" // Uncomment to use the scalar version of the viscoelastic code // #define _SCALAR #if !_SCALAR #include \"log-conform-viscoelastic.h\" #else #include \"log-conform-viscoelastic-scalar-2D.h\" #endif Simulation Parameters FILTERED : Enable density and viscosity jump smoothing tsnap : Time interval between snapshots (default: 1e-2) fErr : Error tolerance for volume fraction (1e-3) KErr : Error tolerance for curvature calculation (1e-6) VelErr : Error tolerance for velocity field (1e-3) AErr : Error tolerance for conformation tensor (1e-3) Ldomain : Domain size in characteristic lengths (8) #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #if !_MPI #include \"distance.h\" #endif #define tsnap ( 1e-2 ) // 0.001 only for some cases. // Error tolerances #define fErr ( 1e-3 ) // Error tolerance in f1 VOF #define KErr ( 1e-6 ) // Error tolerance in VoF curvature calculated using height function method #define VelErr ( 1e-3 ) // Error tolerances in velocity - Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define AErr ( 1e-3 ) // Error tolerances in conformation inside the liquid // Domain size #define Ldomain 8 79 // Boundary conditions - outflow on the right boundary u . n [ right ] = neumann ( 0. ); p [ right ] = dirichlet ( 0. ); int MAXlevel ; // Physical parameters: // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // De -> Deborah number // Ec -> Elasto-capillary number double Oh , Oha , De , Ec , Bond , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; Main Function Initializes the simulation parameters and sets up the domain.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Uses command line...",
    "content": "Uses command line arguments to set simulation parameters Sets up the physical domain with appropriate dimensions Configures fluid properties for both phases Creates necessary directories for output int main ( int argc , char const * argv []) { dtmax = 1e-5 ; // BEWARE of this for stability issues. L0 = Ldomain ; origin (- L0 / 2. , 0. ); // Values taken from the terminal. Here we use some representative values. // In production run, you can pass it from the command line. MAXlevel = 10 ; // atoi(argv[1]); De = 0.1 ; // atof(argv[2]); // Use 1e30 to simulate the De \u2192 \u221e limit Ec = 0.01 ; // atof(argv[3]); Oh = 1e-2 ; // atof(argv[4]); Bond = 1e-3 ; // atof(argv[5]); tmax = 1e0 ; // atof(argv[6]); // Ensure that all the variables were transferred properly from the terminal or job script. // if (argc < 7){ // fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Need %d more...",
    "content": "Need %d more arguments\\n\", 7-argc); // return 1; // } init_grid ( 1 << 5 ); // Create a folder named intermediate where all the simulation snapshots are stored. char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "See writingFiles event. sprintf ( dumpFile , \"restart\" ); Physical Properties Configuration Sets up the material properties for both phases: - rho1 , rho2 : Density of liquid and gas phases - mu1 , mu2 : Dynamic viscosity of liquid and gas phases - lambda1 , lambda2 : Relaxation times - G1 , G2 : Elastic moduli Dimensionless parameters: - Oh : Ohnesorge number for liquid phase - Oha : Ohnesorge number for gas phase (= 2e-2 * Oh) - De : Deborah number - Ec : Elasto-capillary number - Bond : Bond number rho1 = 1. , rho2 = 1e-3 ; Oha = 2e-2 * Oh ; mu1 = Oh , mu2 = Oha ; lambda1 = De ; lambda2 = 0. ; G1 = Ec ; G2 = 0. ; f . sigma = 1.0 ; TOLERANCE = 1e-4 ; CFL = 1e-1 ; run (); } Initialization Event Sets up the initial conditions for the simulation. The function attempts to restore from a dump file first.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: If that fails:...",
    "content": "If that fails: - For MPI runs: Ends with an error - For non-MPI runs: Tries to load an initial shape from a data file, creates a distance field, and initializes the volume fraction event init ( t = 0 ) { #if _MPI // This is for supercomputers without OpenMP support if (! restore ( file = dumpFile )) { fprintf ( ferr , \"Cannot restored from a dump file! \\n \" ); } #else // Note that distance.h is incompatible with OpenMPI.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: So, the below...",
    "content": "So, the below code should not be used with MPI if (! restore ( file = dumpFile )) { char filename [ 60 ]; sprintf ( filename , \"Bo %5.4f .dat\" , Bond ); FILE * fp = fopen ( filename , \"rb\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); // Try in folder one level up sprintf ( filename , \"../Bo %5.4f .dat\" , Bond ); fp = fopen ( filename , \"rb\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); return 1 ; } } coord * InitialShape ; InitialShape = input_xy ( fp ); fclose ( fp ); scalar d []; distance ( d , InitialShape ); while ( adapt_wavelet (( scalar *){ f , d }, ( double []){ 1e-8 , 1e-8 }, MAXlevel ). nf ); // The distance function is defined at the center of each cell, we have // to calculate the value of this function at each vertex. vertex scalar phi []; foreach_vertex () { phi [] = -( d [] + d [- 1 ] + d [ 0 ,- 1 ] + d [- 1 ,- 1 ])/ 4. ; } // We can now initialize the volume fraction of the domain. fractions ( phi , f ); } // return 1; #endif } Adaptive Mesh Refinement Refines the mesh based on gradients of key fields: - Volume fraction - Velocity components - Conformation tensor components - Curvature The refinement criteria are set by the error tolerance parameters defined at the beginning of the file.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This adaptive approach...",
    "content": "This adaptive approach allows for high resolution in regions of interest while maintaining computational efficiency. event adapt ( i ++) { scalar KAPPA []; curvature ( f , KAPPA ); #if !_SCALAR adapt_wavelet (( scalar *){ f , u . x , u . y , conform_p . x . x , conform_p . y . y , conform_p . y . x , conform_qq , KAPPA }, ( double []){ fErr , VelErr , VelErr , AErr , AErr , AErr , AErr , KErr }, MAXlevel , MAXlevel - 6 ); #else adapt_wavelet (( scalar *){ f , u . x , u . y , A11 , A22 , A12 , AThTh , KAPPA }, ( double []){ fErr , VelErr , VelErr , AErr , AErr , AErr , AErr , KErr }, MAXlevel , MAXlevel - 6 ); #endif } Output Management Creates periodic snapshots of the simulation state. - Dumps restart files for simulation recovery - Saves intermediate snapshots at regular intervals defined by tsnap event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Simulation Termination Writes a final summary of the simulation parameters when the simulation ends. event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , De %2.1e , Ec %2.1e , Oh %2.1e , Oha %2.1e , Bo %4.3f\\n \" , MAXlevel , De , Ec , Oh , Oha , Bond ); } Simulation Logging Records key simulation data at each timestep: - Iteration number - Timestep size - Current simulation time - Kinetic energy Also performs safety checks: - Monitors kinetic energy for stability - Terminates simulation if energy becomes too high or too low - Creates log files for post-processing analysis event logWriting ( i ++) { // Calculate kinetic energy double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 2 * pi * y )*( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y [])))* sq ( Delta ); } if ( pid () == 0 ) { static FILE * fp ; if ( i == 0 ) { fprintf ( ferr , \"Level %d , De %2.1e , Ec %2.1e , Oh %2.1e , Oha %2.1e , Bo %4.3f\\n \" , MAXlevel , De , Ec , Oh , Oha , Bond ); fprintf ( ferr , \"De Ec Oh i dt t ke \\n \" ); fp = fopen ( \"log\" , \"w\" ); fprintf ( fp , \"Level %d , De %2.1e , Ec %2.1e , Oh %2.1e , Oha %2.1e , Bo %4.3f\\n \" , MAXlevel , De , Ec , Oh , Oha , Bond ); fprintf ( fp , \"i dt t ke \\n \" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } else { fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); assert ( ke > - 1e-10 ); // Check for energy blowup (numerical instability) if ( ke > 1e2 && i > 1e1 ) { if ( pid () == 0 ) { fprintf ( ferr , \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \"The kinetic energy blew up. Stopping simulation \\n \" ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } assert ( ke < 1e2 ); // Check for energy dissipation below threshold if ( ke < 1e-6 && i > 1e1 ) { if ( pid () == 0 ) { fprintf ( ferr , \"kinetic energy too small now! Stopping! \\n \" ); dump ( file = dumpFile ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \"kinetic energy too small now! Stopping! \\n \" ); fclose ( fp ); return 1 ; } } } }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"axi.h\"#include\"navier-stokes/centered.h\"// Uncomment to use the scalar version of the viscoelastic code// #define _SCALAR#if !_SCALAR#include\"log-conform-viscoelastic.h\"#else#include\"log-conform-viscoelastic-scalar-2D.h\"#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: C/C++ Code",
    "content": "#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#if !_MPI#include\"distance.h\"#endif#define tsnap(1e-2)// 0.001 only for some cases.// Error tolerances#define fErr(1e-3)// Error tolerance in f1 VOF#define KErr(1e-6)// Error tolerance in VoF curvature calculated using height function method#define VelErr(1e-3)// Error tolerances in velocity - Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J#define AErr(1e-3)// Error tolerances in conformation inside the liquid// Domain size#define Ldomain879// Boundary conditions - outflow on the right boundaryu.n[right]=neumann(0.);p[right]=dirichlet(0.);intMAXlevel;// Physical parameters:// Oh -> Solvent Ohnesorge number// Oha -> air Ohnesorge number// De -> Deborah number// Ec -> Elasto-capillary numberdoubleOh,Oha,De,Ec,Bond,tmax;charnameOut[80],dumpFile[80];",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: intmain(intargc,charconst*argv[]){dtmax=1e-5;// BEWARE of...",
    "content": "intmain(intargc,charconst*argv[]){dtmax=1e-5;// BEWARE of this for stability issues.L0=Ldomain;origin(-L0/2.,0.);// Values taken from the terminal.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Here we use...",
    "content": "Here we use some representative values.// In production run, you can pass it from the command line.MAXlevel=10;// atoi(argv[1]);De=0.1;// atof(argv[2]); // Use 1e30 to simulate the De \u2192 \u221e limitEc=0.01;// atof(argv[3]);Oh=1e-2;// atof(argv[4]);Bond=1e-3;// atof(argv[5]);tmax=1e0;// atof(argv[6]);// Ensure that all the variables were transferred properly from the terminal or job script.// if (argc < 7){//   fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Need %d more...",
    "content": "Need %d more arguments\\n\", 7-argc);//   return 1;// }init_grid(1<<5);// Create a folder named intermediate where all the simulation snapshots are stored.charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file. See writingFiles event.sprintf(dumpFile,\"restart\");",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "rho1=1.,rho2=1e-3;Oha=2e-2*Oh;mu1=Oh,mu2=Oha;lambda1=De;lambda2=0.;G1=Ec;G2=0.;f.sigma=1.0;TOLERANCE=1e-4;CFL=1e-1;run();}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event init(t=0){#if _MPI//...",
    "content": "event init(t=0){#if _MPI// This is for supercomputers without OpenMP supportif(!restore(file=dumpFile)){fprintf(ferr,\"Cannot restored from a dump file!\\n\");}#else// Note that distance.h is incompatible with OpenMPI.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: So, the below...",
    "content": "So, the below code should not be used with MPIif(!restore(file=dumpFile)){charfilename[60];sprintf(filename,\"Bo%5.4f.dat\",Bond);FILE*fp=fopen(filename,\"rb\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);// Try in folder one level upsprintf(filename,\"../Bo%5.4f.dat\",Bond);fp=fopen(filename,\"rb\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);return1;}}coord*InitialShape;InitialShape=input_xy(fp);fclose(fp);scalar d[];distance(d,InitialShape);while(adapt_wavelet((scalar*){f,d},(double[]){1e-8,1e-8},MAXlevel).nf);// The distance function is defined at the center of each cell, we have// to calculate the value of this function at each vertex.vertex scalar phi[];foreach_vertex(){phi[]=-(d[]+d[-1]+d[0,-1]+d[-1,-1])/4.;}// We can now initialize the volume fraction of the domain.fractions(phi,f);}// return 1;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);#if !_SCALARadapt_wavelet((scalar*){f,u.x,u.y,conform_p.x.x,conform_p.y.y,conform_p.y.x,conform_qq,KAPPA},(double[]){fErr,VelErr,VelErr,AErr,AErr,AErr,AErr,KErr},MAXlevel,MAXlevel-6);#elseadapt_wavelet((scalar*){f,u.x,u.y,A11,A22,A12,AThTh,KAPPA},(double[]){fErr,VelErr,VelErr,AErr,AErr,AErr,AErr,KErr},MAXlevel,MAXlevel-6);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, De%2.1e, Ec%2.1e, Oh%2.1e, Oha%2.1e, Bo%4.3f\\n\",MAXlevel,De,Ec,Oh,Oha,Bond);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event logWriting(i++){// Calculate...",
    "content": "event logWriting(i++){// Calculate kinetic energydoubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])))*sq(Delta);}if(pid()==0){staticFILE*fp;if(i==0){fprintf(ferr,\"Level%d, De%2.1e, Ec%2.1e, Oh%2.1e, Oha%2.1e, Bo%4.3f\\n\",MAXlevel,De,Ec,Oh,Oha,Bond);fprintf(ferr,\"De Ec Oh i dt t ke\\n\");fp=fopen(\"log\",\"w\");fprintf(fp,\"Level%d, De%2.1e, Ec%2.1e, Oh%2.1e, Oha%2.1e, Bo%4.3f\\n\",MAXlevel,De,Ec,Oh,Oha,Bond);fprintf(fp,\"i dt t ke\\n\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}else{fp=fopen(\"log\",\"a\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);assert(ke>-1e-10);// Check for energy blowup (numerical instability)if(ke>1e2&&i>1e1){if(pid()==0){fprintf(ferr,\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Stopping simulation\\n\");fp=fopen(\"log\",\"a\");fprintf(fp,\"The kinetic...",
    "content": "Stopping simulation\\n\");fp=fopen(\"log\",\"a\");fprintf(fp,\"The kinetic energy blew up. Stopping simulation\\n\");fclose(fp);dump(file=dumpFile);return1;}}assert(ke<1e2);// Check for energy dissipation below thresholdif(ke<1e-6&&i>1e1){if(pid()==0){fprintf(ferr,\"kinetic energy too small now! Stopping!\\n\");dump(file=dumpFile);fp=fopen(\"log\",\"a\");fprintf(fp,\"kinetic energy too small now! Stopping!\\n\");fclose(fp);return1;}}}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases burstingBubbleVE.c This simulation models the dynamics of bursting bubbles in viscoelastic media using the Basilisk framework. It partic... Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje... runCodesInParallel.sh if [ \\$ -lt 1 ]; then echo 'Usage: \\$0 [numberofprocesses]' exit 1 fi file=\\$1 NP=\\${2:-4} use 4 as default if not p...",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)CFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-localinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/runCodesInParallel.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles",
    "content": "simulationCases/runCodesInParallel.sh See raw file runCodesInParallel.sh #!/bin/bash # check that CLI inputs are there. 1 is compulsory. if 2 is not there, use 4 (default) if [ \\$ # -lt 1 ] ; then echo \"Usage: \\$ 0 <filename> [number_of_processes]\" exit 1 fi file = \\$ 1 NP = \\$ {2:-4} # use 4 as default if not provided mkdir -p \\$ file CC99 = 'mpicc -std=c99' qcc -Wall -O2 -D_MPI = 1 -I\\$PWD /src-local -I\\$PWD /../src-local -disable-dimensions \\$ file.c -o \\$ file/\\$file -lm chmod +x \\$ file/\\$file # Ensure executable has proper permissions cd \\$ file mpirun --allow-run-as-root -np \\$ NP ./\\$file",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/runCodesInParallel.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCodesInParallel.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#!/bin/bash# check that CLI inputs are there. 1 is compulsory. if 2 is not there, use 4 (default)if[\\$#-lt1];thenecho\"Usage:\\$0 <filename> [number_of_processes]\"exit1fifile=\\$1NP=\\${2:-4}# use 4 as default if not providedmkdir-p\\$fileCC99='mpicc -std=c99'qcc-Wall-O2-D_MPI=1-I\\$PWD/src-local-I\\$PWD/../src-local-disable-dimensions\\$file.c-o\\$file/\\$file-lmchmod+x\\$file/\\$file# Ensure executable has proper permissionscd\\$filempirun--allow-run-as-root-np\\$NP ./\\$file",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/runCodesInParallel.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData-elastic-scalar2D.c This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoela... getFacet2D.c A utility for extracting interface facets from fluid simulation data. VideoAxi.py Viscoelastic Visualization Tool =========================================== This script processes and visualizes flui...",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/VideoAxi.py See raw file #!/usr/bin/env python3 # -*- coding: utf-8 -*- Viscoelastic Visualization Tool This script processes and visualizes fluid dynamics simulation data, particularly focused on droplet impact and deformable soft matter like liquid drops, sheets, and bubbles. It extracts interface positions and scalar field data from simulation files and creates visualizations showing physical quantities like strain rates and stresses. The script is designed to process multiple simulation snapshots in parallel, extracting data using external executables and generating visualizations with proper colormaps, scales, and mathematical labels.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Features: - Extracts...",
    "content": "Features: - Extracts fluid interfaces and scalar fields from simulation files - Generates visualizations with proper colormaps and mathematical labels - Processes multiple timesteps in parallel using multiprocessing - Configurable via command-line arguments for different simulation cases - Creates publication-quality figures with LaTeX-rendered mathematical expressions Usage: python fluid_vis.py [options] Command-line Arguments: \u2013CPUs Number of CPUs to use for parallel processing (default: all available) \u2013nGFS Number of restart files to process (default: 550) \u2013ZMAX Maximum Z coordinate for visualization (default: 4.0) \u2013RMAX Maximum R coordinate for visualization (default: 2.0) \u2013ZMIN Minimum Z coordinate for visualization (default: -4.0) \u2013caseToProcess Path to simulation case directory (default: \u2018../simulationCases/dropImpact\u2019) \u2013folderToSave Directory to save visualization images (default: \u2018dropImpact\u2019) Dependencies: External executables: getFacet2D, getData-elastic-scalar2D Python libraries: numpy, matplotlib, subprocess, multiprocessing Author: Vatsal Sanjay Email: vatsalsanjay@gmail.com Affiliation: Physics of Fluids Last updated: Jul 24, 2024 import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import multiprocessing as mp from functools import partial import argparse import matplotlib.colors as mcolors custom_colors = [ \"white\" , \"#DA8A67\" , \"#A0522D\" , \"#400000\" ] custom_cmap = mcolors.LinearSegmentedColormap.from_list( \"custom_hot\" , custom_colors) # Configure matplotlib for publication-quality figures with LaTeX rendering matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingFacets(filename, includeCoat = 'true' ): Extract interface positions (facets) from simulation files.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file includeCoat (str, optional): Whether to include coating layer. Defaults to \u2018true\u2019. Returns: list: List of line segments defining fluid interfaces exe = [ \"./getFacet2D\" , filename, includeCoat] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) skip = True return segs def gettingfield(filename, zmin, zmax, rmax, nr): Extract scalar field data from simulation files.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate rmax (float): Maximum R coordinate nr (int): Number of grid points in R direction Returns: tuple: (R, Z, D2, vel, taup, nz) arrays of coordinates and field values exe = [ \"./getData-elastic-scalar2D\" , filename, str (zmin), str ( 0 ), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, D2temp, veltemp, taupTemp = [],[],[],[],[] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) taupTemp.append( float (temp3[ 4 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) taup = np.asarray(taupTemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) taup.resize((nz, nr)) return R, Z, D2, vel, taup, nz # ---------------------------------------------------------------------------------------------------------------------- def process_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess): Process a single timestep from simulation data and generate visualization.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Args: ti (int):...",
    "content": "Args: ti (int): Timestep index folder (str): Directory to save output images nGFS (int): Total number of timesteps GridsPerR (int): Grid points per unit length in R direction rmin (float): Minimum R coordinate rmax (float): Maximum R coordinate zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate lw (float): Line width for plot elements caseToProcess (str): Path to simulation case directory t = 0.01 * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" if not os.path.exists(place): print ( f\" { place } File not found!\" ) return if os.path.exists(name): print ( f\" { name } Image present!\" ) return segs1 = gettingFacets(place) segs2 = gettingFacets(place, 'false' ) if not segs1 and not segs2: print ( f\"Problem in the available file { place } \" ) return nr = int (GridsPerR * rmax) R, Z, taus, vel, taup, nz = gettingfield(place, zmin, zmax, rmax, nr) zminp, zmaxp, rminp, rmaxp = Z. min (), Z. max (), R. min (), R. max () # Plotting AxesLabel, TickLabel = 50 , 20 fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) # Draw domain boundaries ax.plot([ 0 , 0 ], [zmin, zmax], '-.' , color = 'grey' , linewidth = lw) ax.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Add fluid interfaces line_segments = LineCollection(segs2, linewidths = 4 , colors = 'green' , linestyle = 'solid' ) ax.add_collection(line_segments) line_segments = LineCollection(segs1, linewidths = 4 , colors = 'blue' , linestyle = 'solid' ) ax.add_collection(line_segments) # Plot scalar fields with colormaps cntrl1 = ax.imshow(taus, cmap = \"hot_r\" , interpolation = 'Bilinear' , origin = 'lower' , extent = [ - rminp, - rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # TODO : fixme the colorbar bounds for taup must be set manually based on the simulated case. cntrl2 = ax.imshow(taup, interpolation = 'Bilinear' , cmap = custom_cmap, origin = 'lower' , extent = [rminp, rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # Set plot properties ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.set_title( f'$t/ \\\\ tau_ \\\\ gamma$ = { t :4.3f} ' , fontsize = TickLabel) # Add colorbars l, b, w, h = ax.get_position().bounds # Left colorbar cb1 = fig.add_axes([l - 0.04 , b, 0.03 , h]) c1 = plt.colorbar(cntrl1, cax = cb1, orientation = 'vertical' ) c1.set_label( r' $ \\ log_ {10} \\ left ( \\| \\m athcal{D} \\|\\r ight ) $ ' , fontsize = TickLabel, labelpad = 5 ) c1.ax.tick_params(labelsize = TickLabel) c1.ax.yaxis.set_ticks_position( 'left' ) c1.ax.yaxis.set_label_position( 'left' ) c1.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.1f} ' )) # Right colorbar cb2 = fig.add_axes([l + w + 0.01 , b, 0.03 , h]) c2 = plt.colorbar(cntrl2, cax = cb2, orientation = 'vertical' ) c2.ax.tick_params(labelsize = TickLabel) c2.set_label( r' $ \\ log_ {10} \\ left ( \\t ext{tr} \\ left ( \\m athcal{A} \\r ight ) -1 \\r ight ) $ ' , fontsize = TickLabel) c2.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.2f} ' )) ax.axis( 'off' ) plt.savefig(name, bbox_inches = \"tight\" ) plt.close() def main(): Main function that parses command-line arguments and parallelizes processing of timesteps. # Set up command-line argument parsing parser = argparse.ArgumentParser(description = 'Process fluid dynamics simulation data and create visualizations' ) parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use (default: all available)' ) parser.add_argument( '--nGFS' , type = int , default = 550 , help = 'Number of restart files to process (default: 550)' ) parser.add_argument( '--ZMAX' , type = float , default = 4.0 , help = 'Maximum Z value (default: 4.0)' ) parser.add_argument( '--RMAX' , type = float , default = 2.0 , help = 'Maximum R value (default: 2.0)' ) parser.add_argument( '--ZMIN' , type = float , default =- 4.0 , help = 'Minimum Z value (default: -4.0)' ) parser.add_argument( '--caseToProcess' , type = str , default = '../simulationCases/dropImpact' , help = 'Case to process (default: ../simulationCases/dropImpact)' ) parser.add_argument( '--folderToSave' , type = str , default = 'dropImpact' , help = 'Folder to save output images (default: dropImpact)' ) args = parser.parse_args() # Extract arguments CPUStoUse = args.CPUs nGFS = args.nGFS ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN num_processes = CPUStoUse rmin, rmax, zmin, zmax = [ - RMAX, RMAX, ZMIN, ZMAX] GridsPerR = 128 # Grid resolution parameter lw = 2 # Line width for plot elements folder = args.folderToSave caseToProcess = args.caseToProcess # Create output directory if it doesn't exist if not os.path.isdir(folder): os.makedirs(folder) # Create a pool of worker processes for parallel processing with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, folder = folder, nGFS = nGFS, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw, caseToProcess = caseToProcess) # Map the process_func to all timesteps pool. map (process_func, range (nGFS)) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportmultiprocessingasmpfromfunctoolsimportpartialimportargparseimportmatplotlib.colorsasmcolorscustom_colors=[\"white\",\"#DA8A67\",\"#A0522D\",\"#400000\"]custom_cmap=mcolors.LinearSegmentedColormap.from_list(\"custom_hot\", custom_colors)# Configure matplotlib for publication-quality figures with LaTeX renderingmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingFacets(filename, includeCoat='true'):",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "exe=[\"./getFacet2D\", filename, includeCoat]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, zmax, rmax, nr):",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "exe=[\"./getData-elastic-scalar2D\", filename,str(zmin),str(0),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, D2temp, veltemp, taupTemp=[],[],[],[],[]forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))taupTemp.append(float(temp3[4]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)taup=np.asarray(taupTemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))taup.resize((nz, nr))returnR, Z, D2, vel, taup, nz# ----------------------------------------------------------------------------------------------------------------------defprocess_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess):",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "t=0.01*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"ifnotos.path.exists(place):print(f\"{place}File not found!\")returnifos.path.exists(name):print(f\"{name}Image present!\")returnsegs1=gettingFacets(place)segs2=gettingFacets(place,'false')ifnotsegs1andnotsegs2:print(f\"Problem in the available file{place}\")returnnr=int(GridsPerR*rmax)R, Z, taus, vel, taup, nz=gettingfield(place, zmin, zmax, rmax, nr)zminp, zmaxp, rminp, rmaxp=Z.min(), Z.max(), R.min(), R.max()# PlottingAxesLabel, TickLabel=50,20fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)# Draw domain boundariesax.plot([0,0], [zmin, zmax],'-.', color='grey', linewidth=lw)ax.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Add fluid interfacesline_segments=LineCollection(segs2, linewidths=4, colors='green', linestyle='solid')ax.add_collection(line_segments)line_segments=LineCollection(segs1, linewidths=4, colors='blue', linestyle='solid')ax.add_collection(line_segments)# Plot scalar fields with colormapscntrl1=ax.imshow(taus, cmap=\"hot_r\", interpolation='Bilinear', origin='lower',extent=[-rminp,-rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)#TODO: fixme the colorbar bounds for taup must be set manually based on the simulated case.cntrl2=ax.imshow(taup, interpolation='Bilinear', cmap=custom_cmap, origin='lower',extent=[rminp, rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)# Set plot propertiesax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.set_title(f'$t/\\\\tau_\\\\gamma$ ={t:4.3f}', fontsize=TickLabel)# Add colorbarsl, b, w, h=ax.get_position().bounds# Left colorbarcb1=fig.add_axes([l-0.04, b,0.03, h])c1=plt.colorbar(cntrl1, cax=cb1, orientation='vertical')c1.set_label(r'$\\log_{10}\\left(\\|\\mathcal{D}\\|\\right)$', fontsize=TickLabel, labelpad=5)c1.ax.tick_params(labelsize=TickLabel)c1.ax.yaxis.set_ticks_position('left')c1.ax.yaxis.set_label_position('left')c1.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))# Right colorbarcb2=fig.add_axes([l+w+0.01, b,0.03, h])c2=plt.colorbar(cntrl2, cax=cb2, orientation='vertical')c2.ax.tick_params(labelsize=TickLabel)c2.set_label(r'$\\log_{10}\\left(\\text{tr}\\left(\\mathcal{A}\\right)-1\\right)$', fontsize=TickLabel)c2.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.2f}'))ax.axis('off')plt.savefig(name, bbox_inches=\"tight\")plt.close()defmain():",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: # Set up...",
    "content": "# Set up command-line argument parsingparser=argparse.ArgumentParser(description='Process fluid dynamics simulation data and create visualizations')parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use (default: all available)')parser.add_argument('--nGFS',type=int, default=550,help='Number of restart files to process (default: 550)')parser.add_argument('--ZMAX',type=float, default=4.0,help='Maximum Z value (default: 4.0)')parser.add_argument('--RMAX',type=float, default=2.0,help='Maximum R value (default: 2.0)')parser.add_argument('--ZMIN',type=float, default=-4.0,help='Minimum Z value (default: -4.0)')parser.add_argument('--caseToProcess',type=str,default='../simulationCases/dropImpact',help='Case to process (default: ../simulationCases/dropImpact)')parser.add_argument('--folderToSave',type=str, default='dropImpact',help='Folder to save output images (default: dropImpact)')args=parser.parse_args()# Extract argumentsCPUStoUse=args.CPUsnGFS=args.nGFSZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMINnum_processes=CPUStoUsermin, rmax, zmin, zmax=[-RMAX, RMAX, ZMIN, ZMAX]GridsPerR=128# Grid resolution parameterlw=2# Line width for plot elementsfolder=args.folderToSavecaseToProcess=args.caseToProcess# Create output directory if it doesn't existifnotos.path.isdir(folder):os.makedirs(folder)# Create a pool of worker processes for parallel processingwithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep,folder=folder, nGFS=nGFS,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw, caseToProcess=caseToProcess)# Map the process_func to all timestepspool.map(process_func,range(nGFS))if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/getFacet2D.c See raw file Getting Facets A utility for extracting interface facets from fluid simulation data. Description This program extracts and outputs the facets representing the interface between different phases in a multiphase flow simulation. The facets define the boundary between fluid phases, useful for geometric analysis and visualization of the interface morphology. Physics Background In multiphase fluid simulations, interfaces between different fluids are critical features that determine many physical phenomena like surface tension effects, droplet formation, and coalescence events. This utility identifies these interfaces by extracting facets from volume fraction data, allowing for quantitative analysis of interfacial dynamics.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "Usage ./getFacets input_file Author: Vatsal Sanjay vatsalsanjay@gmail.com Physics of Fluids Department University of Twente #include \"utils.h\" #include \"output.h\" #include \"fractions.h\" scalar f []; // Volume fraction field char filename [ 80 ]; Main Function Loads a simulation snapshot and extracts the interface facets. Input parameters: arguments[1] : Filename of the simulation snapshot to process Process: Restores the simulation state from the specified file Extracts interface facets from the volume fraction field Outputs facet data to standard error Return value: Returns 0 on successful completion Note: The facet extraction algorithm identifies where the volume fraction field crosses a threshold value (typically 0.5) between adjacent cells. int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); FILE * fp = ferr ; output_facets ( f , fp ); fflush ( fp ); fclose ( fp ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"fractions.h\"scalar f[];// Volume fraction fieldcharfilename[80];",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);restore(file=filename);FILE*fp=ferr;output_facets(f,fp);fflush(fp);fclose(fp);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/getData-elastic-scalar2D.c See raw file Simulation Data Extraction and Processing This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoelastic fluid simulations with conformation tensor analysis. It computes important derived quantities including deformation rate tensor components, velocity magnitude, and conformation tensor trace. The program interpolates these quantities onto a regular grid and outputs the results for further analysis or visualization. Physics Background This code handles viscoelastic fluid simulation data where the fluid stress tensor includes both a viscous component (proportional to the deformation rate) and an elastic component (represented by the conformation tensor).",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "The trace of the conformation tensor provides a measure of polymer stretching in the fluid. #include \"utils.h\" #include \"output.h\" scalar f []; // Volume fraction field vector u []; // Velocity field scalar A11 [], A12 [], A22 []; // Conformation tensor components scalar conform_qq []; // Additional conformation tensor component char filename [ 80 ]; // Input file name int nx , ny , len ; // Grid dimensions and field count double xmin , ymin , xmax , ymax , Deltax , Deltay ; // Domain boundaries and grid spacing Derived Fields D2c: Log10 of squared deformation rate tensor weighted by volume fraction vel: Magnitude of velocity trA: Log10 of excess trace of conformation tensor scalar D2c [], vel [], trA []; scalar * list = NULL ; // List to store output fields Main Function Processes simulation data and computes derived quantities Arguments: arguments[1]: Input filename arguments[2-5]: Domain boundaries (xmin, ymin, xmax, ymax) arguments[6]: Number of grid points in y-direction (ny) Returns: 0 on successful execution int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); // Initialize list of fields to output list = list_add ( list , D2c ); list = list_add ( list , vel ); list = list_add ( list , trA ); Data Processing Workflow Restore simulation state from snapshot file Compute derived quantities at each grid point Interpolate fields onto regular grid Output data to file restore ( file = filename ); Field Computation For each cell, compute: - Components of the deformation rate tensor D - Squared magnitude of D weighted by volume fraction - Velocity magnitude - Excess trace of the conformation tensor foreach () { // Compute deformation rate tensor components double D11 = ( u . y [ 0 , 1 ] - u . y [ 0 , - 1 ]) / ( 2 * Delta ); double D22 = ( u . y [] / y ); double D33 = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ]) / ( 2 * Delta ); double D13 = 0.5 * (( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 , - 1 ]) / ( 2 * Delta )); double D2 = ( sq ( D11 ) + sq ( D22 ) + sq ( D33 ) + 2.0 * sq ( D13 )); D2c [] = f [] * D2 ; // Take log10 of D2c for better visualization if ( D2c [] > 0. ) { D2c [] = log ( D2c []) / log ( 10 ); } else { D2c [] = - 10 ; } // Compute velocity magnitude vel [] = sqrt ( sq ( u . x []) + sq ( u . y [])); // Compute excess trace of conformation tensor trA [] = ( A11 [] + A22 [] + conform_qq []) / 3.0 - 1.0 ; // Take log10 of trA for better visualization if ( trA [] > 0. ) { trA [] = log ( trA []) / log ( 10 ); } else { trA [] = - 10 ; } } Grid Interpolation and Output Calculate grid spacing based on domain size and ny Allocate memory for interpolated field values Interpolate field values onto regular grid Output grid coordinates and field values FILE * fp = ferr ; Deltay = ( double )(( ymax - ymin ) / ( ny )); nx = ( int )(( xmax - xmin ) / Deltay ); Deltax = ( double )(( xmax - xmin ) / ( nx )); len = list_len ( list ); // Allocate memory for field values double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); // Interpolate field values onto regular grid for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ) { field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } // Output grid coordinates and field values for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ) { fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } // Clean up fflush ( fp ); fclose ( fp ); matrix_free ( field ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"scalar f[];// Volume fraction fieldvector u[];// Velocity fieldscalar A11[],A12[],A22[];// Conformation tensor componentsscalar conform_qq[];// Additional conformation tensor componentcharfilename[80];// Input file nameintnx,ny,len;// Grid dimensions and field countdoublexmin,ymin,xmax,ymax,Deltax,Deltay;// Domain boundaries and grid spacing",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "scalar D2c[],vel[],trA[];scalar*list=NULL;// List to store output fields",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);// Initialize list of fields to outputlist=list_add(list,D2c);list=list_add(list,vel);list=list_add(list,trA);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: foreach(){// Compute deformation...",
    "content": "foreach(){// Compute deformation rate tensor componentsdoubleD11=(u.y[0,1]-u.y[0,-1])/(2*Delta);doubleD22=(u.y[]/y);doubleD33=(u.x[1,0]-u.x[-1,0])/(2*Delta);doubleD13=0.5*((u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(2*Delta));doubleD2=(sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13));D2c[]=f[]*D2;// Take log10 of D2c for better visualizationif(D2c[]>0.){D2c[]=log(D2c[])/log(10);}else{D2c[]=-10;}// Compute velocity magnitudevel[]=sqrt(sq(u.x[])+sq(u.y[]));// Compute excess trace of conformation tensortrA[]=(A11[]+A22[]+conform_qq[])/3.0-1.0;// Take log10 of trA for better visualizationif(trA[]>0.){trA[]=log(trA[])/log(10);}else{trA[]=-10;}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "FILE*fp=ferr;Deltay=(double)((ymax-ymin)/(ny));nx=(int)((xmax-xmin)/Deltay);Deltax=(double)((xmax-xmin)/(nx));len=list_len(list);// Allocate memory for field valuesdouble**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));// Interpolate field values onto regular gridfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}// Output grid coordinates and field valuesfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}// Clean upfflush(fp);fclose(fp);matrix_free(field);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files eigen_decomposition.h This module provides algorithms for computing eigenvalues and eigenvectors of 3x3 symmetric matrices, which are commo... log-conform-viscoelastic-scalar-2D.h Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materia... log-conform-viscoelastic-scalar-3D.h Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materia... log-conform-viscoelastic.h The implementation follows the standard log-conformation approach: 1. Uses tensor mathematics for clean formulation 2... two-phaseVE.h This is a modified version of [two-phase.h](http://basilisk.fr/src/two-phase.h). It contains the implementation of Vi...",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "src-local/log-conform-viscoelastic-scalar-3D.h See raw file Log-Conformation Method for 3D Viscoelastic Fluids Overview Title : log-conform-viscoelastic-3D.h Version : 2.6 Description : Implementation of the log-conformation method for viscoelastic fluids in 3D Key Features Conformation tensor A exists across the domain and relaxes according to \u03bb Stress acts according to elastic modulus G 3D implementation extending log-conform-viscoelastic-scalar-2D.h Eigenvalue clamping for numerical stability Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Mar 16, 2025 Dependencies bcg.h: Bell-Collela-Glaz scheme for advection eigen_decomposition.h: For 3D eigenvalue computation navier-stokes/centered.h: For base flow solver References Fattal & Kupferman (2004, 2005): Original log-conformation method Comminal et al. (2015): Constitutive model functions Hao & Pan (2007): Split scheme implementation Version History v1.0 (Oct 19, 2024) Initial 3D implementation Scalar implementation approach v1.1 (Oct 20, 2024) Added negative eigenvalue detection Added error reporting system v2.0 (Oct 29, 2024) Major matrix algebra corrections for 3D Optimized tensor calculations Improved code structure and documentation v2.1 (Oct 29, 2024) Added initialization functions for tensor structures v2.2 (Nov 3, 2024) Refactored tensor operations Improved code maintainability Enhanced tensor manipulation consistency v2.3 (Nov 14, 2024) Added infinite Deborah number support v2.5 (Nov 23, 2024) Documentation improvements Added mathematical explanations v2.6 (Mar 16, 2025) Implemented eigenvalue clamping system Added minimum eigenvalue threshold (EIGENVALUE_MIN = 1e-8) Improved numerical stability handling Added diagnostic capabilities Fixed 3D velocity gradient calculation Implementation Notes The code extends the standard Basilisk log-conformation implementation Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling with polymeric stress Includes both 2D and 3D implementations Uses atomic operations for thread-safe diagnostics Future Work Axisymmetric Compatibility Currently not implemented Use log-conform-viscoelastic-scalar-2D.h for axi cases Or use log-conform-viscoelastic.h for better efficiency Metric Terms Improvements Enforce tensor compatibility using foreach_dimension Complete metric terms (cm, fm) implementation #if AXI #error \"axi compatibility is not there.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Introduction",
    "content": "To keep the code easy to read, we will not implement axi compatibility just yet.\" #endif The log-conformation method for some viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Function Definition",
    "content": "Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function. The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In the case...",
    "content": "In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models. Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This instability poses...",
    "content": "This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) . /* TODO : - Perhaps, instead of the Bell--Collela--Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to [http://basilisk.fr/src/navier-stokes/conserving.h](http://basilisk.fr/src/navier-stokes/conserving.h) */ #define EIGENVALUE_MIN 1e-8 220 #ifdef DEBUG_EIGENVALUES static int eigenvalue_corrections = 0 ; #endif #include \"bcg.h\" ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time /* conformation tensor */ // diagonal elements scalar A11 [], A22 [], A33 []; // off-diagonal elements scalar A12 [], A13 [], A23 []; /* stress tensor */ // diagonal elements scalar T11 [], T22 [], T33 []; // off-diagonal elements scalar T12 [], T13 [], T23 []; event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; /* initialize A and T */ for ( scalar s in { A11 , A22 , A33 }) { foreach () { s [] = 1. ; } } for ( scalar s in { T11 , T12 , T13 , T22 , T23 , T33 , A12 , A13 , A23 }) { foreach (){ s [] = 0. ; } } for ( scalar s in { A11 , A22 , A33 , T11 , T22 , T33 , A12 , A13 , A23 , T12 , T13 , T23 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } if ( s . boundary [ top ] != periodic_bc ) { s [ top ] = neumann ( 0 ); s [ bottom ] = neumann ( 0 ); } #if dimension == if ( s . boundary [ front ] != periodic_bc ) { s [ front ] = neumann ( 0 ); s [ back ] = neumann ( 0 ); } #endif } } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. #if dimension == typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } #endif /* Now this is the 3D implementation. */ #if dimension == #include \"eigen_decomposition.h\" typedef struct { double x , y , z ; } pseudo_v3d ; typedef struct { pseudo_v3d x , y , z ; } pseudo_t3d ; // Function to initialize pseudo_v3d static inline void init_pseudo_v3d ( pseudo_v3d * v , double value ) { v -> x = value ; v -> y = value ; v -> z = value ; } // Function to initialize pseudo_t3d static inline void init_pseudo_t3d ( pseudo_t3d * t , double value ) { init_pseudo_v3d (& t -> x , value ); init_pseudo_v3d (& t -> y , value ); init_pseudo_v3d (& t -> z , value ); } static void diagonalization_3D ( pseudo_v3d * Lambda , pseudo_t3d * R , pseudo_t3d * A ) { // Check if the matrix is already diagonal if ( sq ( A -> x . y ) + sq ( A -> x . z ) + sq ( A -> y . z ) < 1e-15 ) { R -> x . x = R -> y . y = R -> z . z = 1. ; R -> y . x = R -> x . y = R -> z . x = R -> x . z = R -> z . y = R -> y . z = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; Lambda -> z = A -> z . z ; return ; } // Compute eigenvalues using the eigen_decomposition function double matrix [ 3 ][ 3 ] = { { A -> x . x , A -> x . y , A -> x . z }, { A -> y . x , A -> y . y , A -> y . z }, { A -> z . x , A -> z . y , A -> z . z } }; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); // Store eigenvalues and eigenvectors Lambda -> x = eigenvalues [ 0 ]; Lambda -> y = eigenvalues [ 1 ]; Lambda -> z = eigenvalues [ 2 ]; R -> x . x = eigenvectors [ 0 ][ 0 ]; R -> x . y = eigenvectors [ 0 ][ 1 ]; R -> x . z = eigenvectors [ 0 ][ 2 ]; R -> y . x = eigenvectors [ 1 ][ 0 ]; R -> y . y = eigenvectors [ 1 ][ 1 ]; R -> y . z = eigenvectors [ 1 ][ 2 ]; R -> z . x = eigenvectors [ 2 ][ 0 ]; R -> z . y = eigenvectors [ 2 ][ 1 ]; R -> z . z = eigenvectors [ 2 ][ 2 ]; } #endif The stress tensor depends on previous instants and has to be integrated in time.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In the log-conformation...",
    "content": "In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) . We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ). In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] #if dimension == Advances the log-conformation tensor and updates the corresponding conformation and stress tensors.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Function Definition",
    "content": "This event function performs three primary steps within the viscoelastic fluid simulation: - Diagonalizes the conformation tensor and computes its logarithm (\u03a8) while applying eigenvalue clamping to ensure numerical stability. - Advances \u03a8 in time by incorporating the upper convective term computed from the velocity gradient, which is used to update the log-conformation tensor. - Recovers the physical conformation tensor and stress tensor by exponentiating the diagonalized eigenvalues and integrating the relaxation term.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Note: Although the...",
    "content": "Note: Although the overall simulation targets 3D viscoelastic fluids, this implementation uses a 2D diagonalization routine. event tracer_advection ( i ++) { scalar Psi11 = A11 ; scalar Psi12 = A12 ; scalar Psi22 = A22 ; Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A = {{ A11 [], A12 []}, { A12 [], A22 []}}; The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); pseudo_t R ; init_pseudo_t (& R , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This prevents numerical...",
    "content": "This prevents numerical instabilities while maintaining physical meaning. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"WARNING: Negative eigenvalue detected at ( %g , %g ): [ %g , %g ] \\n \" , x , y , Lambda . x , Lambda . y ); #ifdef DEBUG_EIGENVALUES atomic_increment (& eigenvalue_corrections ); #endif Lambda . x = max ( Lambda . x , EIGENVALUE_MIN ); Lambda . y = max ( Lambda . y , EIGENVALUE_MIN ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) . Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); Psi22 [] = sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . x )* log ( Lambda . x ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The diagonalization will...",
    "content": "The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis. Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: R is the eigenvector matrix of the conformation tensor M is the velocity gradient tensor in the eigenvector basis The construction ensures B is symmetric and traceless pseudo_t B ; init_pseudo_t (& B , 0.0 ); double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; init_pseudo_t (& M , 0.0 ); foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi12 []; Psi12 [] += dt * ( 2. * B . x . y + OM * ( Psi22 [] - Psi11 [])); s *= - 1 ; Psi11 [] += dt * 2. * ( B . x . x + s * OM ); s *= - 1 ; Psi22 [] += dt * 2. * ( B . y . y + s * OM ); } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . advection ({ Psi11 , Psi12 , Psi22 }, uf , dt ); Convert back to Aij foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi11 [], Psi12 []}, { Psi12 [], Psi22 []}}, R ; init_pseudo_t (& R , 0.0 ); pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . A12 [] = A . x . y ; T12 [] = Gp []* A . x . y ; A11 [] = A . x . x ; T11 [] = Gp []*( A . x . x - 1. ); A22 [] = A . y . y ; T22 [] = Gp []*( A . y . y - 1. ); } } #elif dimension == Advances the log-conformation tensor and computes the corresponding conformation and stress tensors for 3D viscoelastic fluid simulations. This event function performs a two-step update for the viscoelastic fluid model using the log-conformation method.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In the first...",
    "content": "In the first part, it computes the logarithm of the conformation tensor \\(\\Psi\\) from A by: - Diagonalizing A to obtain eigenvalues ( \\(\\Lambda\\) ) and eigenvectors (R). - Clamping any negative eigenvalues to prevent numerical instabilities (using EIGENVALUE_MIN). - Evaluating \\(\\Psi = \\log(A)\\) and incorporating the upper convective contribution via the symmetric tensor B and the skew-symmetric tensor \\(\\Omega\\) . \\(\\Psi\\) is then advanced in time using central difference approximations for the velocity gradients, where degenerate eigenvalue cases are handled with simplified calculations. In the second part, the function converts the updated log-conformation tensor back to the conformation tensor A by exponentiating the eigenvalues and applies the relaxation factor derived from the relaxation time. Finally, it computes the polymeric stress tensor T from A.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Warnings are printed...",
    "content": "Warnings are printed if negative eigenvalues are detected, and a debug counter is incremented when debugging is enabled. event tracer_advection ( i ++) { Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term // start by declaring the scalar variables that will store the components of $\\Psi$ scalar Psi11 = A11 , Psi12 = A12 , Psi13 = A13 , Psi22 = A22 , Psi23 = A23 , Psi33 = A33 ; foreach () { pseudo_t3d A , R ; init_pseudo_t3d (& R , 0.0 ); pseudo_v3d Lambda ; init_pseudo_v3d (& Lambda , 0.0 ); A . x . x = A11 []; A . x . y = A12 []; A . x . z = A13 []; A . y . x = A12 []; A . y . y = A22 []; A . y . z = A23 []; A . z . x = A13 []; A . z . y = A23 []; A . z . z = A33 []; // Diagonalize the conformation tensor A to obtain the eigenvalues Lambda and eigenvectors R diagonalization_3D (& Lambda , & R , & A ); /* Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This prevents numerical...",
    "content": "This prevents numerical instabilities while maintaining physical meaning. */ if ( Lambda . x <= 0. || Lambda . y <= 0. || Lambda . z <= 0. ) { fprintf ( ferr , \"WARNING: Negative eigenvalue detected at ( %g , %g , %g ): [ %g , %g , %g ] \\n \" , x , y , z , Lambda . x , Lambda . y , Lambda . z ); #ifdef DEBUG_EIGENVALUES atomic_increment (& eigenvalue_corrections ); #endif Lambda . x = max ( Lambda . x , EIGENVALUE_MIN ); Lambda . y = max ( Lambda . y , EIGENVALUE_MIN ); Lambda . z = max ( Lambda . z , EIGENVALUE_MIN ); } // Compute Psi = log(A) = R * log(Lambda) * R^T Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ) + sq ( R . x . z )* log ( Lambda . z ); Psi22 [] = sq ( R . y . x )* log ( Lambda . x ) + sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . z )* log ( Lambda . z ); Psi33 [] = sq ( R . z . x )* log ( Lambda . x ) + sq ( R . z . y )* log ( Lambda . y ) + sq ( R . z . z )* log ( Lambda . z ); Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . x . y * R . y . y * log ( Lambda . y ) + R . x . z * R . y . z * log ( Lambda . z ); Psi13 [] = R . x . x * R . z . x * log ( Lambda . x ) + R . x . y * R . z . y * log ( Lambda . y ) + R . x . z * R . z . z * log ( Lambda . z ); Psi23 [] = R . y . x * R . z . x * log ( Lambda . x ) + R . y . y * R . z . y * log ( Lambda . y ) + R . y . z * R . z . z * log ( Lambda . z ); // Compute B and Omega tensors (3D version) pseudo_t3d B , M , Omega ; init_pseudo_t3d (& B , 0.0 ); init_pseudo_t3d (& M , 0.0 ); init_pseudo_t3d (& Omega , 0.0 ); // Check if any pair of eigenvalues are numerically equal (within a small tolerance) if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 || fabs ( Lambda . y - Lambda . z ) <= 1e-20 || fabs ( Lambda . z - Lambda . x ) <= 1e-20 ) { // In case of equal eigenvalues, the calculations for B and Omega simplify significantly // B is grad U and Omega is zero. // Compute off-diagonal elements of B using central differences // These represent the symmetric part of the velocity gradient tensor B . x . y = ( u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ] + u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ])/( 4. * Delta ); // (dv/dx + du/dy)/2 B . x . z = ( u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ] + u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ])/( 4. * Delta ); // (dw/dx + du/dz)/2 B . y . z = ( u . z [ 0 , 1 , 0 ] - u . z [ 0 ,- 1 , 0 ] + u . y [ 0 , 0 , 1 ] - u . y [ 0 , 0 ,- 1 ])/( 4. * Delta ); // (dw/dy + dv/dz)/2 // Compute diagonal elements of B // These represent the normal strain rates B . x . x = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ])/( 2. * Delta ); // du/dx B . y . y = ( u . y [ 0 , 1 , 0 ] - u . y [ 0 ,- 1 , 0 ])/( 2. * Delta ); // dv/dy B . z . z = ( u . z [ 0 , 0 , 1 ] - u . z [ 0 , 0 ,- 1 ])/( 2. * Delta ); // dw/dz // Set all components of Omega to zero // This is because Omega represents the antisymmetric part of the velocity gradient tensor, // which vanishes when eigenvalues are equal Omega . x . y = Omega . x . z = Omega . y . z = Omega . y . x = Omega . z . x = Omega . z . y = 0. ; } else { /* ### Compute the velocity gradient tensor components using central differences - These represent the spatial derivatives of each velocity component - These gradients form the velocity gradient tensor (nablaU): [ dudx dudy dudz ] [ dvdx dvdy dvdz ] [ dwdx dwdy dwdz ] */ // Derivatives of u (x-component of velocity) double dudx = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ])/( 2.0 * Delta ); // du/dx double dudy = ( u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // du/dy double dudz = ( u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // du/dz // Derivatives of v (y-component of velocity) double dvdx = ( u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ])/( 2.0 * Delta ); // dv/dx double dvdy = ( u . y [ 0 , 1 , 0 ] - u . y [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // dv/dy double dvdz = ( u . y [ 0 , 0 , 1 ] - u . y [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // dv/dz // Derivatives of w (z-component of velocity) double dwdx = ( u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ])/( 2.0 * Delta ); // dw/dx double dwdy = ( u . z [ 0 , 1 , 0 ] - u . z [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // dw/dy double dwdz = ( u . z [ 0 , 0 , 1 ] - u . z [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // dw/dz /* Calculate the M tensor through matrix multiplication: M = R * (nablaU)^T R^T.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This represents the...",
    "content": "This represents the velocity gradient tensor transformed to the eigenvector basis of the conformation tensor. * Steps: 1. Compute intermediate products (R * nablaU^T): - Store row-wise products in Rx_gradU_*, Ry_gradU_*, Rz_gradU_* - Each variable represents one row of the intermediate matrix 2.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Multiply by R^T...",
    "content": "Multiply by R^T to obtain the final M tensor: - M.i.j represents the (i,j) component of the transformed velocity gradient - This transformation expresses the velocity gradient in the eigenvector basis - The resulting M tensor is used to compute Omega (\u03a9) and B tensors, such that */ // First, compute intermediate products of R and (nablaU)^T double Rx_gradU_x = R . x . x * dudx + R . x . y * dvdx + R . x . z * dwdx ; double Rx_gradU_y = R . x . x * dudy + R . x . y * dvdy + R . x . z * dwdy ; double Rx_gradU_z = R . x . x * dudz + R . x . y * dvdz + R . x . z * dwdz ; double Ry_gradU_x = R . y . x * dudx + R . y . y * dvdx + R . y . z * dwdx ; double Ry_gradU_y = R . y . x * dudy + R . y . y * dvdy + R . y . z * dwdy ; double Ry_gradU_z = R . y . x * dudz + R . y . y * dvdz + R . y . z * dwdz ; double Rz_gradU_x = R . z . x * dudx + R . z . y * dvdx + R . z . z * dwdx ; double Rz_gradU_y = R . z . x * dudy + R . z . y * dvdy + R . z . z * dwdy ; double Rz_gradU_z = R . z . x * dudz + R . z . y * dvdz + R . z . z * dwdz ; // Now compute M components by multiplying the intermediate products with R^T M . x . x = R . x . x * Rx_gradU_x + R . x . y * Rx_gradU_y + R . x . z * Rx_gradU_z ; M . x . y = R . x . x * Ry_gradU_x + R . x . y * Ry_gradU_y + R . x . z * Ry_gradU_z ; M . x . z = R . x . x * Rz_gradU_x + R . x . y * Rz_gradU_y + R . x . z * Rz_gradU_z ; M . y . x = R . y . x * Rx_gradU_x + R . y . y * Rx_gradU_y + R . y . z * Rx_gradU_z ; M . y . y = R . y . x * Ry_gradU_x + R . y . y * Ry_gradU_y + R . y . z * Ry_gradU_z ; M . y . z = R . y . x * Rz_gradU_x + R . y . y * Rz_gradU_y + R . y . z * Rz_gradU_z ; M . z . x = R . z . x * Rx_gradU_x + R . z . y * Rx_gradU_y + R . z . z * Rx_gradU_z ; M . z . y = R . z . x * Ry_gradU_x + R . z . y * Ry_gradU_y + R . z . z * Ry_gradU_z ; M . z . z = R . z . x * Rz_gradU_x + R . z . y * Rz_gradU_y + R . z . z * Rz_gradU_z ; // Compute the off-diagonal elements of the Omega tensor in the eigenvector basis double omega_xy = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); double omega_xz = ( Lambda . z * M . x . z + Lambda . x * M . z . x )/( Lambda . z - Lambda . x ); double omega_yz = ( Lambda . z * M . y . z + Lambda . y * M . z . y )/( Lambda . z - Lambda . y ); // Calculate intermediate rotation combinations for each direction // x-direction rotation combinations double rot_x_xy_yz = ( R . x . x * omega_xy - R . x . z * omega_yz ); // xy rotation minus yz rotation, x components double rot_x_xy_xz = ( R . x . y * omega_xy + R . x . z * omega_xz ); // xy rotation plus xz rotation, x components double rot_x_xz_yz = ( R . x . x * omega_xz + R . x . y * omega_yz ); // xz rotation plus yz rotation, x components // y-direction rotation combinations double rot_y_xy_yz = ( R . y . x * omega_xy - R . y . z * omega_yz ); // xy rotation minus yz rotation, y components double rot_y_xy_xz = ( R . y . y * omega_xy + R . y . z * omega_xz ); // xy rotation plus xz rotation, y components double rot_y_xz_yz = ( R . y . x * omega_xz + R . y . y * omega_yz ); // xz rotation plus yz rotation, y components // z-direction rotation combinations double rot_z_xy_yz = ( R . z . x * omega_xy - R . z . z * omega_yz ); // xy rotation minus yz rotation, z components double rot_z_xy_xz = ( R . z . y * omega_xy + R . z . z * omega_xz ); // xy rotation plus xz rotation, z components double rot_z_xz_yz = ( R . z . x * omega_xz + R . z . y * omega_yz ); // xz rotation plus yz rotation, z components Calculate the components of the Omega tensor in the physical coordinate system The Omega tensor represents the rotational part of the velocity gradient tensor and is computed through the following steps: We already have: R: eigenvector matrix of the conformation tensor rot_*_*_*: pre-computed rotation combinations for each direction Mathematical background: Omega = R * Omega_eigen * R^T where Omega_eigen is the rotation tensor in eigenvector space The components are calculated using the rotation combinations: rot_i_jk_lm represents combined rotations in the i-direction Each component Omega_ij is a linear combination of these rotations // Compute x-row components of Omega Omega . x . x = R . x . y * rot_x_xy_yz // xy-yz rotation contribution - R . x . x * rot_x_xy_xz // xy-xz rotation contribution + R . x . z * rot_x_xz_yz ; // xz-yz rotation contribution Omega . x . y = R . y . y * rot_x_xy_yz // xy-yz rotation mapped to y-direction - R . y . x * rot_x_xy_xz // xy-xz rotation mapped to y-direction + R . y . z * rot_x_xz_yz ; // xz-yz rotation mapped to y-direction Omega . x . z = R . z . y * rot_x_xy_yz // xy-yz rotation mapped to z-direction - R . z . x * rot_x_xy_xz // xy-xz rotation mapped to z-direction + R . z . z * rot_x_xz_yz ; // xz-yz rotation mapped to z-direction // Compute y-row components using similar pattern Omega . y . x = R . x . y * rot_y_xy_yz - R . x . x * rot_y_xy_xz + R . x . z * rot_y_xz_yz ; Omega . y . y = R . y . y * rot_y_xy_yz - R . y . x * rot_y_xy_xz + R . y . z * rot_y_xz_yz ; Omega . y . z = R . z . y * rot_y_xy_yz - R . z . x * rot_y_xy_xz + R . z . z * rot_y_xz_yz ; // Compute z-row components using similar pattern Omega . z . x = R . x . y * rot_z_xy_yz - R . x . x * rot_z_xy_xz + R . x . z * rot_z_xz_yz ; Omega . z . y = R . y . y * rot_z_xy_yz - R . y . x * rot_z_xy_xz + R . y . z * rot_z_xz_yz ; Omega . z . z = R . z . y * rot_z_xy_yz - R . z . x * rot_z_xy_xz + R . z . z * rot_z_xz_yz ; Note: The resulting Omega tensor is skew-symmetric, meaning: - Omega_ij = -Omega_ji This property is automatically satisfied by the construction above and is essential for preserving the physical meaning of rotation // Extract diagonal components of M (velocity gradient tensor in eigenvector basis) double M_diag_x = M . x . x , M_diag_y = M . y . y , M_diag_z = M . z . z ; Compute B tensor: B = R * diag(M) * R^T - This transforms the diagonal velocity gradient tensor back to the original coordinate system - B is symmetric, so we only need to compute the upper triangle // Compute diagonal elements of B B . x . x = M_diag_x * sq ( R . x . x ) + M_diag_y * sq ( R . x . y ) + M_diag_z * sq ( R . x . z ); B . y . y = M_diag_x * sq ( R . y . x ) + M_diag_y * sq ( R . y . y ) + M_diag_z * sq ( R . y . z ); B . z . z = M_diag_x * sq ( R . z . x ) + M_diag_y * sq ( R . z . y ) + M_diag_z * sq ( R . z . z ); // Compute off-diagonal elements of B (upper triangle) B . x . y = M_diag_x * R . x . x * R . y . x + M_diag_y * R . x . y * R . y . y + M_diag_z * R . x . z * R . y . z ; B . x . z = M_diag_x * R . x . x * R . z . x + M_diag_y * R . x . y * R . z . y + M_diag_z * R . x . z * R . z . z ; B . y . z = M_diag_x * R . y . x * R . z . x + M_diag_y * R . y . y * R . z . y + M_diag_z * R . y . z * R . z . z ; // Fill in lower triangle using symmetry of B B . y . x = B . x . y ; B . z . x = B . x . z ; B . z . y = B . y . z ; } We now advance \\(\\Psi\\) in time, adding the upper convective contribution.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This step 1:...",
    "content": "This step 1: _t = 2 + (-) // save old values of Psi components double old_Psi11 = Psi11 []; double old_Psi22 = Psi22 []; double old_Psi33 = Psi33 []; double old_Psi12 = Psi12 []; double old_Psi13 = Psi13 []; double old_Psi23 = Psi23 []; // Psi11 Psi11 [] += dt * ( 2.0 * B . x . x + Omega . x . y * old_Psi12 - Omega . y . x * old_Psi12 + Omega . x . z * old_Psi13 - Omega . z . x * old_Psi13 ); // Psi22 Psi22 [] += dt * ( 2.0 * B . y . y - Omega . x . y * old_Psi12 + Omega . y . x * old_Psi12 + Omega . y . z * old_Psi23 - Omega . z . y * old_Psi23 ); // Psi33 Psi33 [] += dt * ( 2.0 * B . z . z - Omega . x . z * old_Psi13 + Omega . z . x * old_Psi13 - Omega . y . z * old_Psi23 + Omega . z . y * old_Psi23 ); // Psi12 Psi12 [] += dt * ( 2.0 * B . x . y + Omega . x . x * old_Psi12 - Omega . x . y * old_Psi11 + Omega . x . y * old_Psi22 - Omega . y . y * old_Psi12 + Omega . x . z * old_Psi23 - Omega . z . y * old_Psi13 ); // Psi13 Psi13 [] += dt * ( 2.0 * B . x . z + Omega . x . x * old_Psi13 - Omega . x . z * old_Psi11 + Omega . x . y * old_Psi23 - Omega . y . z * old_Psi12 + Omega . x . z * old_Psi33 - Omega . z . z * old_Psi13 ); // Psi23 Psi23 [] += dt * ( 2.0 * B . y . z + Omega . y . x * old_Psi13 - Omega . x . z * old_Psi12 + Omega . y . y * old_Psi23 - Omega . y . z * old_Psi22 + Omega . y . z * old_Psi33 - Omega . z . z * old_Psi23 ); } // Advection of Psi, which is the log-conformation tensor advection ({ Psi11 , Psi12 , Psi13 , Psi22 , Psi23 , Psi33 }, uf , dt ); Convert back to A and T We now convert the log-conformation tensor Psi back to the conformation tensor A and compute the stress tensor T.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This process involves...",
    "content": "This process involves diagonalization, exponentiation of eigenvalues, and application of the relaxation factor. foreach () { pseudo_t3d A , R ; init_pseudo_t3d (& R , 0.0 ); pseudo_v3d Lambda ; init_pseudo_v3d (& Lambda , 0.0 ); // Reconstruct the log-conformation tensor from its components A . x . x = Psi11 []; A . x . y = Psi12 []; A . x . z = Psi13 []; A . y . x = Psi12 []; A . y . y = Psi22 []; A . y . z = Psi23 []; A . z . x = Psi13 []; A . z . y = Psi23 []; A . z . z = Psi33 []; // Diagonalize A to obtain eigenvalues and eigenvectors diagonalization_3D (& Lambda , & R , & A ); // Exponentiate eigenvalues Lambda . x = exp ( Lambda . x ); Lambda . y = exp ( Lambda . y ); Lambda . z = exp ( Lambda . z ); // Reconstruct A using A = R * diag(Lambda) * R^T A . x . x = Lambda . x * sq ( R . x . x ) + Lambda . y * sq ( R . x . y ) + Lambda . z * sq ( R . x . z ); A . x . y = Lambda . x * R . x . x * R . y . x + Lambda . y * R . x . y * R . y . y + Lambda . z * R . x . z * R . y . z ; A . y . x = A . x . y ; A . x . z = Lambda . x * R . x . x * R . z . x + Lambda . y * R . x . y * R . z . y + Lambda . z * R . x . z * R . z . z ; A . z . x = A . x . z ; A . y . y = Lambda . x * sq ( R . y . x ) + Lambda . y * sq ( R . y . y ) + Lambda . z * sq ( R . y . z ); A . y . z = Lambda . x * R . y . x * R . z . x + Lambda . y * R . y . y * R . z . y + Lambda . z * R . y . z * R . z . z ; A . z . y = A . y . z ; A . z . z = Lambda . x * sq ( R . z . x ) + Lambda . y * sq ( R . z . y ) + Lambda . z * sq ( R . z . z ); // Apply relaxation using the relaxation time lambda double intFactor = lambda [] != 0. ? exp (- dt / lambda []) : 0. ; A . x . y *= intFactor ; A . y . x = A . x . y ; A . x . z *= intFactor ; A . z . x = A . x . z ; A . y . z *= intFactor ; A . z . y = A . y . z ; foreach_dimension () A . x . x = 1. + ( A . x . x - 1. )* intFactor ; Get Aij from A.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: These commands might...",
    "content": "These commands might look repetitive. But, I do this so that in the future, generalization to tensor only form is easier. // diagonal terms: A11 [] = A . x . x ; A22 [] = A . y . y ; A33 [] = A . z . z ; // off-diagonal terms: A12 [] = A . x . y ; A13 [] = A . x . z ; A23 [] = A . y . z ; // Compute the stress tensor T using the polymer modulus Gp T11 [] = Gp []*( A . x . x - 1. ); T22 [] = Gp []*( A . y . y - 1. ); T33 [] = Gp []*( A . z . z - 1. ); T12 [] = Gp []* A . x . y ; T13 [] = Gp []* A . x . z ; T23 [] = Gp []* A . y . z ; } } #endif Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{T}\\) is defined at cell centers, while the corresponding force (acceleration) is defined at cell faces. For each component of the momentum equation, we need to compute the divergence of the corresponding row of the stress tensor.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Examples",
    "content": "For example, for the x-component in 3D: \\[ (\\nabla \\cdot \\mathbf{T})_x = \\partial_x T_{xx} + \\partial_y T_{xy} + \\partial_z T_{xz} \\] The normal stress gradient (e.g. \\(\\partial_x T_{xx}\\) ) is computed directly from cell-centered values.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The shear stress...",
    "content": "The shear stress gradients (e.g. \\(\\partial_y T_{xy}\\) ) are computed using vertex-averaged values to avoid checkerboard instabilities. event acceleration ( i ++) { face vector av = a ; #if dimension == // 2D implementation foreach_face ( x ) { if ( fm . x [] > 1e-20 ) { // y-gradient of T12 (shear stress) double shearX = ( T12 [ 0 , 1 ]* cm [ 0 , 1 ] + T12 [- 1 , 1 ]* cm [- 1 , 1 ] - T12 [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; // x-gradient of T11 (normal stress) double gradX_T11 = cm []* T11 [] - cm [- 1 ]* T11 [- 1 ]; av . x [] += ( shearX + gradX_T11 )* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ) { if ( fm . y [] > 1e-20 ) { // x-gradient of T12 (shear stress) double shearY = ( T12 [ 1 , 0 ]* cm [ 1 , 0 ] + T12 [ 1 ,- 1 ]* cm [ 1 ,- 1 ] - T12 [- 1 , 0 ]* cm [- 1 , 0 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; // y-gradient of T22 (normal stress) double gradY_T22 = cm []* T22 [] - cm [ 0 ,- 1 ]* T22 [ 0 ,- 1 ]; av . y [] += ( shearY + gradY_T22 )* alpha . y []/( sq ( fm . y [])* Delta ); } } #elif dimension == // 3D implementation foreach_face ( x ) { if ( fm . x [] > 1e-20 ) { // y-gradient of T12 double shearY = ( T12 [ 0 , 1 , 0 ]* cm [ 0 , 1 , 0 ] + T12 [- 1 , 1 , 0 ]* cm [- 1 , 1 , 0 ] - T12 [ 0 ,- 1 , 0 ]* cm [ 0 ,- 1 , 0 ] - T12 [- 1 ,- 1 , 0 ]* cm [- 1 ,- 1 , 0 ])/ 4. ; // z-gradient of T13 double shearZ = ( T13 [ 0 , 0 , 1 ]* cm [ 0 , 0 , 1 ] + T13 [- 1 , 0 , 1 ]* cm [- 1 , 0 , 1 ] - T13 [ 0 , 0 ,- 1 ]* cm [ 0 , 0 ,- 1 ] - T13 [- 1 , 0 ,- 1 ]* cm [- 1 , 0 ,- 1 ])/ 4. ; // x-gradient of T11 double gradX_T11 = cm []* T11 [] - cm [- 1 , 0 , 0 ]* T11 [- 1 , 0 , 0 ]; av . x [] += ( shearY + shearZ + gradX_T11 )* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ) { if ( fm . y [] > 1e-20 ) { // x-gradient of T12 double shearX = ( T12 [ 1 , 0 , 0 ]* cm [ 1 , 0 , 0 ] + T12 [ 1 ,- 1 , 0 ]* cm [ 1 ,- 1 , 0 ] - T12 [- 1 , 0 , 0 ]* cm [- 1 , 0 , 0 ] - T12 [- 1 ,- 1 , 0 ]* cm [- 1 ,- 1 , 0 ])/ 4. ; // z-gradient of T23 double shearZ = ( T23 [ 0 , 0 , 1 ]* cm [ 0 , 0 , 1 ] + T23 [ 0 ,- 1 , 1 ]* cm [ 0 ,- 1 , 1 ] - T23 [ 0 , 0 ,- 1 ]* cm [ 0 , 0 ,- 1 ] - T23 [ 0 ,- 1 ,- 1 ]* cm [ 0 ,- 1 ,- 1 ])/ 4. ; // y-gradient of T22 double gradY_T22 = cm []* T22 [] - cm [ 0 ,- 1 , 0 ]* T22 [ 0 ,- 1 , 0 ]; av . y [] += ( shearX + shearZ + gradY_T22 )* alpha . y []/( sq ( fm . y [])* Delta ); } } foreach_face ( z ) { if ( fm . z [] > 1e-20 ) { // x-gradient of T13 double shearX = ( T13 [ 1 , 0 , 0 ]* cm [ 1 , 0 , 0 ] + T13 [ 1 , 0 ,- 1 ]* cm [ 1 , 0 ,- 1 ] - T13 [- 1 , 0 , 0 ]* cm [- 1 , 0 , 0 ] - T13 [- 1 , 0 ,- 1 ]* cm [- 1 , 0 ,- 1 ])/ 4. ; // y-gradient of T23 double shearY = ( T23 [ 0 , 1 , 0 ]* cm [ 0 , 1 , 0 ] + T23 [ 0 , 1 ,- 1 ]* cm [ 0 , 1 ,- 1 ] - T23 [ 0 ,- 1 , 0 ]* cm [ 0 ,- 1 , 0 ] - T23 [ 0 ,- 1 ,- 1 ]* cm [ 0 ,- 1 ,- 1 ])/ 4. ; // z-gradient of T33 double gradZ_T33 = cm []* T33 [] - cm [ 0 , 0 ,- 1 ]* T33 [ 0 , 0 ,- 1 ]; av . z [] += ( shearX + shearY + gradZ_T33 )* alpha . z []/( sq ( fm . z [])* Delta ); } } #endif }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if AXI#error \"axi compatibility is not there. To keep the code easy to read, we will not implement axi compatibility just yet.\"#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: /*TODO:- Perhaps, instead...",
    "content": "/*TODO:- Perhaps, instead of the Bell--Collela--Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to [http://basilisk.fr/src/navier-stokes/conserving.h](http://basilisk.fr/src/navier-stokes/conserving.h)*/#define EIGENVALUE_MIN1e-8220#ifdef DEBUG_EIGENVALUESstaticinteigenvalue_corrections=0;#endif#include\"bcg.h\"(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation time/*conformation tensor */// diagonal elementsscalar A11[],A22[],A33[];// off-diagonal elementsscalar A12[],A13[],A23[];/*stress tensor */// diagonal elementsscalar T11[],T22[],T33[];// off-diagonal elementsscalar T12[],T13[],T23[];event defaults(i=0){if(is_constant(a.x))a=new face vector;/*initialize A and T*/for(scalar s in{A11,A22,A33}){foreach(){s[]=1.;}}for(scalar s in{T11,T12,T13,T22,T23,T33,A12,A13,A23}){foreach(){s[]=0.;}}for(scalar s in{A11,A22,A33,T11,T22,T33,A12,A13,A23,T12,T13,T23}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}if(s.boundary[top]!=periodic_bc){s[top]=neumann(0);s[bottom]=neumann(0);}#if dimension ==if(s.boundary[front]!=periodic_bc){s[front]=neumann(0);s[back]=neumann(0);}#endif}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if dimension ==typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}#endif/*Now this is the 3D implementation.*/#if dimension ==#include\"eigen_decomposition.h\"typedefstruct{doublex,y,z;}pseudo_v3d;typedefstruct{pseudo_v3d x,y,z;}pseudo_t3d;// Function to initialize pseudo_v3dstaticinlinevoidinit_pseudo_v3d(pseudo_v3d*v,doublevalue){v->x=value;v->y=value;v->z=value;}// Function to initialize pseudo_t3dstaticinlinevoidinit_pseudo_t3d(pseudo_t3d*t,doublevalue){init_pseudo_v3d(&t->x,value);init_pseudo_v3d(&t->y,value);init_pseudo_v3d(&t->z,value);}staticvoiddiagonalization_3D(pseudo_v3d*Lambda,pseudo_t3d*R,pseudo_t3d*A){// Check if the matrix is already diagonalif(sq(A->x.y)+sq(A->x.z)+sq(A->y.z)<1e-15){R->x.x=R->y.y=R->z.z=1.;R->y.x=R->x.y=R->z.x=R->x.z=R->z.y=R->y.z=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;Lambda->z=A->z.z;return;}// Compute eigenvalues using the eigen_decomposition functiondoublematrix[3][3]={{A->x.x,A->x.y,A->x.z},{A->y.x,A->y.y,A->y.z},{A->z.x,A->z.y,A->z.z}};doubleeigenvectors[3][3];doubleeigenvalues[3];compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);// Store eigenvalues and eigenvectorsLambda->x=eigenvalues[0];Lambda->y=eigenvalues[1];Lambda->z=eigenvalues[2];R->x.x=eigenvectors[0][0];R->x.y=eigenvectors[0][1];R->x.z=eigenvectors[0][2];R->y.x=eigenvectors[1][0];R->y.y=eigenvectors[1][1];R->y.z=eigenvectors[1][2];R->z.x=eigenvectors[2][0];R->z.y=eigenvectors[2][1];R->z.z=eigenvectors[2][2];}#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event tracer_advection(i++){scalar Psi11=A11;scalar Psi12=A12;scalar Psi22=A22;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);pseudo_t R;init_pseudo_t(&R,0.0);diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.This prevents numerical instabilities while maintaining physical meaning.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"WARNING: Negative eigenvalue detected at (%g,%g): [%g,%g]\\n\",x,y,Lambda.x,Lambda.y);#ifdef DEBUG_EIGENVALUESatomic_increment(&eigenvalue_corrections);#endifLambda.x=max(Lambda.x,EIGENVALUE_MIN);Lambda.y=max(Lambda.y,EIGENVALUE_MIN);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);Psi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);Psi22[]=sq(R.y.y)*log(Lambda.y)+sq(R.y.x)*log(Lambda.x);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "pseudo_t B;init_pseudo_t(&B,0.0);doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;init_pseudo_t(&M,0.0);foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubles=-Psi12[];Psi12[]+=dt*(2.*B.x.y+OM*(Psi22[]-Psi11[]));s*=-1;Psi11[]+=dt*2.*(B.x.x+s*OM);s*=-1;Psi22[]+=dt*2.*(B.y.y+s*OM);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A={{Psi11[],Psi12[]},{Psi12[],Psi22[]}},R;init_pseudo_t(&R,0.0);pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);A.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "A12[]=A.x.y;T12[]=Gp[]*A.x.y;A11[]=A.x.x;T11[]=Gp[]*(A.x.x-1.);A22[]=A.y.y;T22[]=Gp[]*(A.y.y-1.);}}#elif dimension ==",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: // start by...",
    "content": "// start by declaring the scalar variables that will store the components of $\\Psi$scalar Psi11=A11,Psi12=A12,Psi13=A13,Psi22=A22,Psi23=A23,Psi33=A33;foreach(){pseudo_t3d A,R;init_pseudo_t3d(&R,0.0);pseudo_v3d Lambda;init_pseudo_v3d(&Lambda,0.0);A.x.x=A11[];A.x.y=A12[];A.x.z=A13[];A.y.x=A12[];A.y.y=A22[];A.y.z=A23[];A.z.x=A13[];A.z.y=A23[];A.z.z=A33[];// Diagonalize the conformation tensor A to obtain the eigenvalues Lambda and eigenvectors Rdiagonalization_3D(&Lambda,&R,&A);/*Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.This prevents numerical instabilities while maintaining physical meaning.*/if(Lambda.x<=0.||Lambda.y<=0.||Lambda.z<=0.){fprintf(ferr,\"WARNING: Negative eigenvalue detected at (%g,%g,%g): [%g,%g,%g]\\n\",x,y,z,Lambda.x,Lambda.y,Lambda.z);#ifdef DEBUG_EIGENVALUESatomic_increment(&eigenvalue_corrections);#endifLambda.x=max(Lambda.x,EIGENVALUE_MIN);Lambda.y=max(Lambda.y,EIGENVALUE_MIN);Lambda.z=max(Lambda.z,EIGENVALUE_MIN);}// Compute Psi = log(A) = R * log(Lambda) * R^TPsi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y)+sq(R.x.z)*log(Lambda.z);Psi22[]=sq(R.y.x)*log(Lambda.x)+sq(R.y.y)*log(Lambda.y)+sq(R.y.z)*log(Lambda.z);Psi33[]=sq(R.z.x)*log(Lambda.x)+sq(R.z.y)*log(Lambda.y)+sq(R.z.z)*log(Lambda.z);Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.x.y*R.y.y*log(Lambda.y)+R.x.z*R.y.z*log(Lambda.z);Psi13[]=R.x.x*R.z.x*log(Lambda.x)+R.x.y*R.z.y*log(Lambda.y)+R.x.z*R.z.z*log(Lambda.z);Psi23[]=R.y.x*R.z.x*log(Lambda.x)+R.y.y*R.z.y*log(Lambda.y)+R.y.z*R.z.z*log(Lambda.z);// Compute B and Omega tensors (3D version)pseudo_t3d B,M,Omega;init_pseudo_t3d(&B,0.0);init_pseudo_t3d(&M,0.0);init_pseudo_t3d(&Omega,0.0);// Check if any pair of eigenvalues are numerically equal (within a small tolerance)if(fabs(Lambda.x-Lambda.y)<=1e-20||fabs(Lambda.y-Lambda.z)<=1e-20||fabs(Lambda.z-Lambda.x)<=1e-20){// In case of equal eigenvalues, the calculations for B and Omega simplify significantly// B is grad U and Omega is zero.// Compute off-diagonal elements of B using central differences// These represent the symmetric part of the velocity gradient tensorB.x.y=(u.y[1,0,0]-u.y[-1,0,0]+u.x[0,1,0]-u.x[0,-1,0])/(4.*Delta);// (dv/dx + du/dy)/2B.x.z=(u.z[1,0,0]-u.z[-1,0,0]+u.x[0,0,1]-u.x[0,0,-1])/(4.*Delta);// (dw/dx + du/dz)/2B.y.z=(u.z[0,1,0]-u.z[0,-1,0]+u.y[0,0,1]-u.y[0,0,-1])/(4.*Delta);// (dw/dy + dv/dz)/2// Compute diagonal elements of B// These represent the normal strain ratesB.x.x=(u.x[1,0,0]-u.x[-1,0,0])/(2.*Delta);// du/dxB.y.y=(u.y[0,1,0]-u.y[0,-1,0])/(2.*Delta);// dv/dyB.z.z=(u.z[0,0,1]-u.z[0,0,-1])/(2.*Delta);// dw/dz// Set all components of Omega to zero// This is because Omega represents the antisymmetric part of the velocity gradient tensor,// which vanishes when eigenvalues are equalOmega.x.y=Omega.x.z=Omega.y.z=Omega.y.x=Omega.z.x=Omega.z.y=0.;}else{/*###Compute the velocity gradient tensor components using central differences- These represent the spatial derivatives of each velocity component- These gradients form the velocity gradient tensor (nablaU):[ dudx  dudy  dudz ][ dvdx  dvdy  dvdz ][ dwdx  dwdy  dwdz ]*/// Derivatives of u (x-component of velocity)doubledudx=(u.x[1,0,0]-u.x[-1,0,0])/(2.0*Delta);// du/dxdoubledudy=(u.x[0,1,0]-u.x[0,-1,0])/(2.0*Delta);// du/dydoubledudz=(u.x[0,0,1]-u.x[0,0,-1])/(2.0*Delta);// du/dz// Derivatives of v (y-component of velocity)doubledvdx=(u.y[1,0,0]-u.y[-1,0,0])/(2.0*Delta);// dv/dxdoubledvdy=(u.y[0,1,0]-u.y[0,-1,0])/(2.0*Delta);// dv/dydoubledvdz=(u.y[0,0,1]-u.y[0,0,-1])/(2.0*Delta);// dv/dz// Derivatives of w (z-component of velocity)doubledwdx=(u.z[1,0,0]-u.z[-1,0,0])/(2.0*Delta);// dw/dxdoubledwdy=(u.z[0,1,0]-u.z[0,-1,0])/(2.0*Delta);// dw/dydoubledwdz=(u.z[0,0,1]-u.z[0,0,-1])/(2.0*Delta);// dw/dz/*Calculate the M tensor through matrix multiplication: M = R * (nablaU)^T R^T.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: This represents the...",
    "content": "This represents the velocity gradient tensor transformed to the eigenvector basis of the conformation tensor.* Steps:1. Compute intermediate products (R * nablaU^T):- Store row-wise products in Rx_gradU_*, Ry_gradU_*, Rz_gradU_*- Each variable represents one row of the intermediate matrix2.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Multiply by R^T...",
    "content": "Multiply by R^T to obtain the final M tensor:- M.i.j represents the (i,j) component of the transformed velocity gradient- This transformation expresses the velocity gradient in the eigenvector basis- The resulting M tensor is used to compute Omega (\u03a9) and B tensors, such that*/// First, compute intermediate products of R and (nablaU)^TdoubleRx_gradU_x=R.x.x*dudx+R.x.y*dvdx+R.x.z*dwdx;doubleRx_gradU_y=R.x.x*dudy+R.x.y*dvdy+R.x.z*dwdy;doubleRx_gradU_z=R.x.x*dudz+R.x.y*dvdz+R.x.z*dwdz;doubleRy_gradU_x=R.y.x*dudx+R.y.y*dvdx+R.y.z*dwdx;doubleRy_gradU_y=R.y.x*dudy+R.y.y*dvdy+R.y.z*dwdy;doubleRy_gradU_z=R.y.x*dudz+R.y.y*dvdz+R.y.z*dwdz;doubleRz_gradU_x=R.z.x*dudx+R.z.y*dvdx+R.z.z*dwdx;doubleRz_gradU_y=R.z.x*dudy+R.z.y*dvdy+R.z.z*dwdy;doubleRz_gradU_z=R.z.x*dudz+R.z.y*dvdz+R.z.z*dwdz;// Now compute M components by multiplying the intermediate products with R^TM.x.x=R.x.x*Rx_gradU_x+R.x.y*Rx_gradU_y+R.x.z*Rx_gradU_z;M.x.y=R.x.x*Ry_gradU_x+R.x.y*Ry_gradU_y+R.x.z*Ry_gradU_z;M.x.z=R.x.x*Rz_gradU_x+R.x.y*Rz_gradU_y+R.x.z*Rz_gradU_z;M.y.x=R.y.x*Rx_gradU_x+R.y.y*Rx_gradU_y+R.y.z*Rx_gradU_z;M.y.y=R.y.x*Ry_gradU_x+R.y.y*Ry_gradU_y+R.y.z*Ry_gradU_z;M.y.z=R.y.x*Rz_gradU_x+R.y.y*Rz_gradU_y+R.y.z*Rz_gradU_z;M.z.x=R.z.x*Rx_gradU_x+R.z.y*Rx_gradU_y+R.z.z*Rx_gradU_z;M.z.y=R.z.x*Ry_gradU_x+R.z.y*Ry_gradU_y+R.z.z*Ry_gradU_z;M.z.z=R.z.x*Rz_gradU_x+R.z.y*Rz_gradU_y+R.z.z*Rz_gradU_z;// Compute the off-diagonal elements of the Omega tensor in the eigenvector basisdoubleomega_xy=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);doubleomega_xz=(Lambda.z*M.x.z+Lambda.x*M.z.x)/(Lambda.z-Lambda.x);doubleomega_yz=(Lambda.z*M.y.z+Lambda.y*M.z.y)/(Lambda.z-Lambda.y);// Calculate intermediate rotation combinations for each direction// x-direction rotation combinationsdoublerot_x_xy_yz=(R.x.x*omega_xy-R.x.z*omega_yz);// xy rotation minus yz rotation, x componentsdoublerot_x_xy_xz=(R.x.y*omega_xy+R.x.z*omega_xz);// xy rotation plus xz rotation, x componentsdoublerot_x_xz_yz=(R.x.x*omega_xz+R.x.y*omega_yz);// xz rotation plus yz rotation, x components// y-direction rotation combinationsdoublerot_y_xy_yz=(R.y.x*omega_xy-R.y.z*omega_yz);// xy rotation minus yz rotation, y componentsdoublerot_y_xy_xz=(R.y.y*omega_xy+R.y.z*omega_xz);// xy rotation plus xz rotation, y componentsdoublerot_y_xz_yz=(R.y.x*omega_xz+R.y.y*omega_yz);// xz rotation plus yz rotation, y components// z-direction rotation combinationsdoublerot_z_xy_yz=(R.z.x*omega_xy-R.z.z*omega_yz);// xy rotation minus yz rotation, z componentsdoublerot_z_xy_xz=(R.z.y*omega_xy+R.z.z*omega_xz);// xy rotation plus xz rotation, z componentsdoublerot_z_xz_yz=(R.z.x*omega_xz+R.z.y*omega_yz);// xz rotation plus yz rotation, z components",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: // Compute x-row...",
    "content": "// Compute x-row components of OmegaOmega.x.x=R.x.y*rot_x_xy_yz// xy-yz rotation contribution-R.x.x*rot_x_xy_xz// xy-xz rotation contribution+R.x.z*rot_x_xz_yz;// xz-yz rotation contributionOmega.x.y=R.y.y*rot_x_xy_yz// xy-yz rotation mapped to y-direction-R.y.x*rot_x_xy_xz// xy-xz rotation mapped to y-direction+R.y.z*rot_x_xz_yz;// xz-yz rotation mapped to y-directionOmega.x.z=R.z.y*rot_x_xy_yz// xy-yz rotation mapped to z-direction-R.z.x*rot_x_xy_xz// xy-xz rotation mapped to z-direction+R.z.z*rot_x_xz_yz;// xz-yz rotation mapped to z-direction// Compute y-row components using similar patternOmega.y.x=R.x.y*rot_y_xy_yz-R.x.x*rot_y_xy_xz+R.x.z*rot_y_xz_yz;Omega.y.y=R.y.y*rot_y_xy_yz-R.y.x*rot_y_xy_xz+R.y.z*rot_y_xz_yz;Omega.y.z=R.z.y*rot_y_xy_yz-R.z.x*rot_y_xy_xz+R.z.z*rot_y_xz_yz;// Compute z-row components using similar patternOmega.z.x=R.x.y*rot_z_xy_yz-R.x.x*rot_z_xy_xz+R.x.z*rot_z_xz_yz;Omega.z.y=R.y.y*rot_z_xy_yz-R.y.x*rot_z_xy_xz+R.y.z*rot_z_xz_yz;Omega.z.z=R.z.y*rot_z_xy_yz-R.z.x*rot_z_xy_xz+R.z.z*rot_z_xz_yz;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "// Extract diagonal components of M (velocity gradient tensor in eigenvector basis)doubleM_diag_x=M.x.x,M_diag_y=M.y.y,M_diag_z=M.z.z;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: // Compute diagonal...",
    "content": "// Compute diagonal elements of BB.x.x=M_diag_x*sq(R.x.x)+M_diag_y*sq(R.x.y)+M_diag_z*sq(R.x.z);B.y.y=M_diag_x*sq(R.y.x)+M_diag_y*sq(R.y.y)+M_diag_z*sq(R.y.z);B.z.z=M_diag_x*sq(R.z.x)+M_diag_y*sq(R.z.y)+M_diag_z*sq(R.z.z);// Compute off-diagonal elements of B (upper triangle)B.x.y=M_diag_x*R.x.x*R.y.x+M_diag_y*R.x.y*R.y.y+M_diag_z*R.x.z*R.y.z;B.x.z=M_diag_x*R.x.x*R.z.x+M_diag_y*R.x.y*R.z.y+M_diag_z*R.x.z*R.z.z;B.y.z=M_diag_x*R.y.x*R.z.x+M_diag_y*R.y.y*R.z.y+M_diag_z*R.y.z*R.z.z;// Fill in lower triangle using symmetry of BB.y.x=B.x.y;B.z.x=B.x.z;B.z.y=B.y.z;}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: // save old...",
    "content": "// save old values of Psi componentsdoubleold_Psi11=Psi11[];doubleold_Psi22=Psi22[];doubleold_Psi33=Psi33[];doubleold_Psi12=Psi12[];doubleold_Psi13=Psi13[];doubleold_Psi23=Psi23[];// Psi11Psi11[]+=dt*(2.0*B.x.x+Omega.x.y*old_Psi12-Omega.y.x*old_Psi12+Omega.x.z*old_Psi13-Omega.z.x*old_Psi13);// Psi22Psi22[]+=dt*(2.0*B.y.y-Omega.x.y*old_Psi12+Omega.y.x*old_Psi12+Omega.y.z*old_Psi23-Omega.z.y*old_Psi23);// Psi33Psi33[]+=dt*(2.0*B.z.z-Omega.x.z*old_Psi13+Omega.z.x*old_Psi13-Omega.y.z*old_Psi23+Omega.z.y*old_Psi23);// Psi12Psi12[]+=dt*(2.0*B.x.y+Omega.x.x*old_Psi12-Omega.x.y*old_Psi11+Omega.x.y*old_Psi22-Omega.y.y*old_Psi12+Omega.x.z*old_Psi23-Omega.z.y*old_Psi13);// Psi13Psi13[]+=dt*(2.0*B.x.z+Omega.x.x*old_Psi13-Omega.x.z*old_Psi11+Omega.x.y*old_Psi23-Omega.y.z*old_Psi12+Omega.x.z*old_Psi33-Omega.z.z*old_Psi13);// Psi23Psi23[]+=dt*(2.0*B.y.z+Omega.y.x*old_Psi13-Omega.x.z*old_Psi12+Omega.y.y*old_Psi23-Omega.y.z*old_Psi22+Omega.y.z*old_Psi33-Omega.z.z*old_Psi23);}// Advection of Psi, which is the log-conformation tensoradvection({Psi11,Psi12,Psi13,Psi22,Psi23,Psi33},uf,dt);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "foreach(){pseudo_t3d A,R;init_pseudo_t3d(&R,0.0);pseudo_v3d Lambda;init_pseudo_v3d(&Lambda,0.0);// Reconstruct the log-conformation tensor from its componentsA.x.x=Psi11[];A.x.y=Psi12[];A.x.z=Psi13[];A.y.x=Psi12[];A.y.y=Psi22[];A.y.z=Psi23[];A.z.x=Psi13[];A.z.y=Psi23[];A.z.z=Psi33[];// Diagonalize A to obtain eigenvalues and eigenvectorsdiagonalization_3D(&Lambda,&R,&A);// Exponentiate eigenvaluesLambda.x=exp(Lambda.x);Lambda.y=exp(Lambda.y);Lambda.z=exp(Lambda.z);// Reconstruct A using A = R * diag(Lambda) * R^TA.x.x=Lambda.x*sq(R.x.x)+Lambda.y*sq(R.x.y)+Lambda.z*sq(R.x.z);A.x.y=Lambda.x*R.x.x*R.y.x+Lambda.y*R.x.y*R.y.y+Lambda.z*R.x.z*R.y.z;A.y.x=A.x.y;A.x.z=Lambda.x*R.x.x*R.z.x+Lambda.y*R.x.y*R.z.y+Lambda.z*R.x.z*R.z.z;A.z.x=A.x.z;A.y.y=Lambda.x*sq(R.y.x)+Lambda.y*sq(R.y.y)+Lambda.z*sq(R.y.z);A.y.z=Lambda.x*R.y.x*R.z.x+Lambda.y*R.y.y*R.z.y+Lambda.z*R.y.z*R.z.z;A.z.y=A.y.z;A.z.z=Lambda.x*sq(R.z.x)+Lambda.y*sq(R.z.y)+Lambda.z*sq(R.z.z);// Apply relaxation using the relaxation time lambdadoubleintFactor=lambda[]!=0.?exp(-dt/lambda[]):0.;A.x.y*=intFactor;A.y.x=A.x.y;A.x.z*=intFactor;A.z.x=A.x.z;A.y.z*=intFactor;A.z.y=A.y.z;foreach_dimension()A.x.x=1.+(A.x.x-1.)*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "// diagonal terms:A11[]=A.x.x;A22[]=A.y.y;A33[]=A.z.z;// off-diagonal terms:A12[]=A.x.y;A13[]=A.x.z;A23[]=A.y.z;// Compute the stress tensor T using the polymer modulus GpT11[]=Gp[]*(A.x.x-1.);T22[]=Gp[]*(A.y.y-1.);T33[]=Gp[]*(A.z.z-1.);T12[]=Gp[]*A.x.y;T13[]=Gp[]*A.x.z;T23[]=Gp[]*A.y.z;}}#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event acceleration(i++){face vector...",
    "content": "event acceleration(i++){face vector av=a;#if dimension ==// 2D implementationforeach_face(x){if(fm.x[]>1e-20){// y-gradient of T12 (shear stress)doubleshearX=(T12[0,1]*cm[0,1]+T12[-1,1]*cm[-1,1]-T12[0,-1]*cm[0,-1]-T12[-1,-1]*cm[-1,-1])/4.;// x-gradient of T11 (normal stress)doublegradX_T11=cm[]*T11[]-cm[-1]*T11[-1];av.x[]+=(shearX+gradX_T11)*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){// x-gradient of T12 (shear stress)doubleshearY=(T12[1,0]*cm[1,0]+T12[1,-1]*cm[1,-1]-T12[-1,0]*cm[-1,0]-T12[-1,-1]*cm[-1,-1])/4.;// y-gradient of T22 (normal stress)doublegradY_T22=cm[]*T22[]-cm[0,-1]*T22[0,-1];av.y[]+=(shearY+gradY_T22)*alpha.y[]/(sq(fm.y[])*Delta);}}#elif dimension ==// 3D implementationforeach_face(x){if(fm.x[]>1e-20){// y-gradient of T12doubleshearY=(T12[0,1,0]*cm[0,1,0]+T12[-1,1,0]*cm[-1,1,0]-T12[0,-1,0]*cm[0,-1,0]-T12[-1,-1,0]*cm[-1,-1,0])/4.;// z-gradient of T13doubleshearZ=(T13[0,0,1]*cm[0,0,1]+T13[-1,0,1]*cm[-1,0,1]-T13[0,0,-1]*cm[0,0,-1]-T13[-1,0,-1]*cm[-1,0,-1])/4.;// x-gradient of T11doublegradX_T11=cm[]*T11[]-cm[-1,0,0]*T11[-1,0,0];av.x[]+=(shearY+shearZ+gradX_T11)*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){// x-gradient of T12doubleshearX=(T12[1,0,0]*cm[1,0,0]+T12[1,-1,0]*cm[1,-1,0]-T12[-1,0,0]*cm[-1,0,0]-T12[-1,-1,0]*cm[-1,-1,0])/4.;// z-gradient of T23doubleshearZ=(T23[0,0,1]*cm[0,0,1]+T23[0,-1,1]*cm[0,-1,1]-T23[0,0,-1]*cm[0,0,-1]-T23[0,-1,-1]*cm[0,-1,-1])/4.;// y-gradient of T22doublegradY_T22=cm[]*T22[]-cm[0,-1,0]*T22[0,-1,0];av.y[]+=(shearX+shearZ+gradY_T22)*alpha.y[]/(sq(fm.y[])*Delta);}}foreach_face(z){if(fm.z[]>1e-20){// x-gradient of T13doubleshearX=(T13[1,0,0]*cm[1,0,0]+T13[1,0,-1]*cm[1,0,-1]-T13[-1,0,0]*cm[-1,0,0]-T13[-1,0,-1]*cm[-1,0,-1])/4.;// y-gradient of T23doubleshearY=(T23[0,1,0]*cm[0,1,0]+T23[0,1,-1]*cm[0,1,-1]-T23[0,-1,0]*cm[0,-1,0]-T23[0,-1,-1]*cm[0,-1,-1])/4.;// z-gradient of T33doublegradZ_T33=cm[]*T33[]-cm[0,0,-1]*T33[0,0,-1];av.z[]+=(shearX+shearY+gradZ_T33)*alpha.z[]/(sq(fm.z[])*Delta);}}#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "src-local/eigen_decomposition.h See raw file Matrix Eigenvalue Solver This module provides algorithms for computing eigenvalues and eigenvectors of 3x3 symmetric matrices, which are commonly encountered in computational fluid dynamics, solid mechanics, and other physics-based simulations. Mathematical Background The implementation uses the Householder transformation to reduce a symmetric matrix to tridiagonal form, followed by the QL algorithm with implicit shifts to compute the eigenvalues and eigenvectors. For a 3x3 symmetric matrix, these methods are particularly efficient and numerically stable, providing accurate results even for matrices with closely spaced eigenvalues. Tridiagonalize a 3x3 Symmetric Matrix Reduces a 3x3 symmetric matrix to tridiagonal form using the Householder method, which applies a series of orthogonal transformations to eliminate elements below the subdiagonal.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Results",
    "content": "Parameters: matrix[in]: Input 3x3 symmetric matrix to be tridiagonalized eigenvectors[out]: Orthogonal matrix of Householder vectors diagonal[out]: Diagonal elements of the resulting tridiagonal matrix subdiagonal[out]: Subdiagonal elements of the tridiagonal matrix Implementation Notes: The original matrix is preserved The eigenvectors matrix is initialized to identity and then transformed The algorithm exploits the symmetry of the input matrix #define SQUARE ( x ) (( x )*( x )) 36 static void tridiagonalize_symmetric_3x3 ( double matrix [ 3 ][ 3 ], double eigenvectors [ 3 ][ 3 ], double diagonal [ 3 ], double subdiagonal [ 2 ]) { const int size = 3 ; double householder_vector [ size ], temp_vector [ size ]; double omega , scale , sigma , tau ; // Initialize eigenvectors to the identity matrix for ( int i = 0 ; i < size ; i ++) { eigenvectors [ i ][ i ] = 1.0 ; for ( int j = 0 ; j < i ; j ++) eigenvectors [ i ][ j ] = eigenvectors [ j ][ i ] = 0.0 ; } // Compute the first Householder reflection scale = SQUARE ( matrix [ 0 ][ 1 ]) + SQUARE ( matrix [ 0 ][ 2 ]); sigma = ( matrix [ 0 ][ 1 ] > 0 ) ? - sqrt ( scale ) : sqrt ( scale ); subdiagonal [ 0 ] = sigma ; tau = sigma * matrix [ 0 ][ 1 ]; householder_vector [ 1 ] = matrix [ 0 ][ 1 ] - sigma ; householder_vector [ 2 ] = matrix [ 0 ][ 2 ]; omega = scale - tau ; if ( omega > 0.0 ) { omega = 1.0 / omega ; sigma = 0.0 ; for ( int i = 1 ; i < size ; i ++) { tau = matrix [ 1 ][ i ] * householder_vector [ 1 ] + matrix [ i ][ 2 ] * householder_vector [ 2 ]; temp_vector [ i ] = omega * tau ; sigma += householder_vector [ i ] * tau ; } sigma *= 0.5 * SQUARE ( omega ); for ( int i = 1 ; i < size ; i ++) temp_vector [ i ] -= sigma * householder_vector [ i ]; diagonal [ 0 ] = matrix [ 0 ][ 0 ]; diagonal [ 1 ] = matrix [ 1 ][ 1 ] - 2.0 * temp_vector [ 1 ] * householder_vector [ 1 ]; diagonal [ 2 ] = matrix [ 2 ][ 2 ] - 2.0 * temp_vector [ 2 ] * householder_vector [ 2 ]; for ( int j = 1 ; j < size ; j ++) { tau = omega * householder_vector [ j ]; for ( int i = 1 ; i < size ; i ++) eigenvectors [ i ][ j ] -= tau * householder_vector [ i ]; } subdiagonal [ 1 ] = matrix [ 1 ][ 2 ] - temp_vector [ 1 ] * householder_vector [ 2 ] - householder_vector [ 1 ] * temp_vector [ 2 ]; } else { for ( int i = 0 ; i < size ; i ++) diagonal [ i ] = matrix [ i ][ i ]; subdiagonal [ 1 ] = matrix [ 1 ][ 2 ]; } } ### Compute Eigenvalues and Eigenvectors of a 3x3 Symmetric Matrix Calculates the complete eigensystem (eigenvalues and eigenvectors) of a 3x3 symmetric matrix using the QL algorithm with implicit shifts, after first reducing the matrix to tridiagonal form.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Parameters: matrix[in]: Input...",
    "content": "Parameters: matrix[in]: Input 3x3 symmetric matrix whose eigensystem will be computed eigenvectors[out]: Matrix whose columns are the eigenvectors eigenvalues[out]: Array containing the eigenvalues Return Value: 0: Computation successful -1: Algorithm failed to converge within the maximum number of iterations Algorithm Details: First checks if the matrix is already diagonal If not, tridiagonalizes the matrix using Householder transformations Applies the QL algorithm with implicit shifts to compute eigenvalues Maximum of 30 iterations are allowed for convergence Numerical tolerance of 1e-15 is used for detecting diagonal matrices Usage Example: double matrix [ 3 ][ 3 ] = {{ 1.0 , 0.5 , 0.3 }, { 0.5 , 2.0 , 0.1 }, { 0.3 , 0.1 , 3.0 }}; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; int result = compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); if ( result == 0 ) { // Computation successful } static int compute_eigensystem_symmetric_3x3 ( double matrix [ 3 ][ 3 ], double eigenvectors [ 3 ][ 3 ], double eigenvalues [ 3 ]) { const int size = 3 ; const int max_iterations = 30 ; double subdiagonal [ 3 ]; double g , r , p , f , b , s , c , t ; int iteration_count ; int m ; // Check for diagonal matrix with unit entries if ( SQUARE ( matrix [ 0 ][ 1 ]) < 1e-15 && SQUARE ( matrix [ 0 ][ 2 ]) < 1e-15 && SQUARE ( matrix [ 1 ][ 2 ]) < 1e-15 ) { for ( int i = 0 ; i < size ; i ++) { for ( int j = 0 ; j < size ; j ++) { eigenvectors [ i ][ j ] = ( i == j ) ? 1.0 : 0.0 ; } eigenvalues [ i ] = matrix [ i ][ i ]; } return 0 ; } tridiagonalize_symmetric_3x3 ( matrix , eigenvectors , eigenvalues , subdiagonal ); for ( int l = 0 ; l < size - 1 ; l ++) { iteration_count = 0 ; while ( 1 ) { for ( m = l ; m <= size - 2 ; m ++) { g = fabs ( eigenvalues [ m ]) + fabs ( eigenvalues [ m + 1 ]); if ( fabs ( subdiagonal [ m ]) + g == g ) break ; } if ( m == l ) break ; if ( iteration_count ++ >= max_iterations ) return - 1 ; g = ( eigenvalues [ l + 1 ] - eigenvalues [ l ]) / ( 2.0 * subdiagonal [ l ]); r = sqrt ( SQUARE ( g ) + 1.0 ); g = eigenvalues [ m ] - eigenvalues [ l ] + subdiagonal [ l ] / ( g + ( g > 0 ? fabs ( r ) : - fabs ( r ))); s = c = 1.0 ; p = 0.0 ; for ( int i = m - 1 ; i >= l ; i --) { f = s * subdiagonal [ i ]; b = c * subdiagonal [ i ]; if ( fabs ( f ) > fabs ( g )) { c = g / f ; r = sqrt ( SQUARE ( c ) + 1.0 ); subdiagonal [ i + 1 ] = f * r ; c *= ( s = 1.0 / r ); } else { s = f / g ; r = sqrt ( SQUARE ( s ) + 1.0 ); subdiagonal [ i + 1 ] = g * r ; s *= ( c = 1.0 / r ); } g = eigenvalues [ i + 1 ] - p ; r = ( eigenvalues [ i ] - g ) * s + 2.0 * c * b ; p = s * r ; eigenvalues [ i + 1 ] = g + p ; g = c * r - b ; for ( int k = 0 ; k < size ; k ++) { t = eigenvectors [ k ][ i + 1 ]; eigenvectors [ k ][ i + 1 ] = s * eigenvectors [ k ][ i ] + c * t ; eigenvectors [ k ][ i ] = c * eigenvectors [ k ][ i ] - s * t ; } } eigenvalues [ l ] -= p ; subdiagonal [ l ] = g ; subdiagonal [ m ] = 0.0 ; } } return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "#define SQUARE(x)((x)*(x))36staticvoidtridiagonalize_symmetric_3x3(doublematrix[3][3],doubleeigenvectors[3][3],doublediagonal[3],doublesubdiagonal[2]){constintsize=3;doublehouseholder_vector[size],temp_vector[size];doubleomega,scale,sigma,tau;// Initialize eigenvectors to the identity matrixfor(inti=0;i<size;i++){eigenvectors[i][i]=1.0;for(intj=0;j<i;j++)eigenvectors[i][j]=eigenvectors[j][i]=0.0;}// Compute the first Householder reflectionscale=SQUARE(matrix[0][1])+SQUARE(matrix[0][2]);sigma=(matrix[0][1]>0)?-sqrt(scale):sqrt(scale);subdiagonal[0]=sigma;tau=sigma*matrix[0][1];householder_vector[1]=matrix[0][1]-sigma;householder_vector[2]=matrix[0][2];omega=scale-tau;if(omega>0.0){omega=1.0/omega;sigma=0.0;for(inti=1;i<size;i++){tau=matrix[1][i]*householder_vector[1]+matrix[i][2]*householder_vector[2];temp_vector[i]=omega*tau;sigma+=householder_vector[i]*tau;}sigma*=0.5*SQUARE(omega);for(inti=1;i<size;i++)temp_vector[i]-=sigma*householder_vector[i];diagonal[0]=matrix[0][0];diagonal[1]=matrix[1][1]-2.0*temp_vector[1]*householder_vector[1];diagonal[2]=matrix[2][2]-2.0*temp_vector[2]*householder_vector[2];for(intj=1;j<size;j++){tau=omega*householder_vector[j];for(inti=1;i<size;i++)eigenvectors[i][j]-=tau*householder_vector[i];}subdiagonal[1]=matrix[1][2]-temp_vector[1]*householder_vector[2]-householder_vector[1]*temp_vector[2];}else{for(inti=0;i<size;i++)diagonal[i]=matrix[i][i];subdiagonal[1]=matrix[1][2];}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doublematrix[3][3]={{1.0,0.5,0.3},{0.5,2.0,0.1},{0.3,0.1,3.0}};doubleeigenvectors[3][3];doubleeigenvalues[3];intresult=compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);if(result==0){// Computation successful}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "staticintcompute_eigensystem_symmetric_3x3(doublematrix[3][3],doubleeigenvectors[3][3],doubleeigenvalues[3]){constintsize=3;constintmax_iterations=30;doublesubdiagonal[3];doubleg,r,p,f,b,s,c,t;intiteration_count;intm;// Check for diagonal matrix with unit entriesif(SQUARE(matrix[0][1])<1e-15&&SQUARE(matrix[0][2])<1e-15&&SQUARE(matrix[1][2])<1e-15){for(inti=0;i<size;i++){for(intj=0;j<size;j++){eigenvectors[i][j]=(i==j)?1.0:0.0;}eigenvalues[i]=matrix[i][i];}return0;}tridiagonalize_symmetric_3x3(matrix,eigenvectors,eigenvalues,subdiagonal);for(intl=0;l<size-1;l++){iteration_count=0;while(1){for(m=l;m<=size-2;m++){g=fabs(eigenvalues[m])+fabs(eigenvalues[m+1]);if(fabs(subdiagonal[m])+g==g)break;}if(m==l)break;if(iteration_count++>=max_iterations)return-1;g=(eigenvalues[l+1]-eigenvalues[l])/(2.0*subdiagonal[l]);r=sqrt(SQUARE(g)+1.0);g=eigenvalues[m]-eigenvalues[l]+subdiagonal[l]/(g+(g>0?fabs(r):-fabs(r)));s=c=1.0;p=0.0;for(inti=m-1;i>=l;i--){f=s*subdiagonal[i];b=c*subdiagonal[i];if(fabs(f)>fabs(g)){c=g/f;r=sqrt(SQUARE(c)+1.0);subdiagonal[i+1]=f*r;c*=(s=1.0/r);}else{s=f/g;r=sqrt(SQUARE(s)+1.0);subdiagonal[i+1]=g*r;s*=(c=1.0/r);}g=eigenvalues[i+1]-p;r=(eigenvalues[i]-g)*s+2.0*c*b;p=s*r;eigenvalues[i+1]=g+p;g=c*r-b;for(intk=0;k<size;k++){t=eigenvectors[k][i+1];eigenvectors[k][i+1]=s*eigenvectors[k][i]+c*t;eigenvectors[k][i]=c*eigenvectors[k][i]-s*t;}}eigenvalues[l]-=p;subdiagonal[l]=g;subdiagonal[m]=0.0;}}return0;}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "src-local/log-conform-viscoelastic.h See raw file Log-Conformation Method with Tensor Implementation Overview Title : log-conform-viscoelastic.h Version : 10.5 Description : Tensor-based implementation of the log-conformation method for viscoelastic fluids Key Features Conformation tensor A exists across domain and relaxes according to \u03bb Stress acts according to elastic modulus G Uses native tensor data structures for better code organization Supports both 2D and axisymmetric configurations Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Nov 23, 2024 Implementation Notes Based on http://basilisk.fr/src/log-conform.h with key improvements: Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling bug where [\u03c3_p] = 0 & [\u03c3_s] = \u03b3\u03ba Ensures [\u03c3_s+\u03c3_p] = \u03b3\u03ba for correct interface behavior Important Limitations 3D Compatibility Currently limited to 2D and axisymmetric cases only 3D support is blocked by Basilisk core limitations: Boundary conditions for symmetric tensors are not implemented in Basilisk core See basilisk/src/grid/cartesian-common.h lines 230-251 Comment in source: \u201cfixme: boundary conditions don\u2019t work!\u201d Alternative for 3D For 3D simulations, use log-conform-viscoelastic-scalar-3D.h Scalar version uses individual components instead of tensors Provides full 3D functionality without boundary condition limitations Technical Notes Variable Naming conform_p , conform_qq : Represent the Conformation tensor Tensor implementation provides more natural mathematical representation Axisymmetric components handled separately when needed Mathematical Framework The implementation follows the standard log-conformation approach: 1.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Uses tensor mathematics...",
    "content": "Uses tensor mathematics for clean formulation 2. Handles both planar and axisymmetric geometries 3. Provides natural extension to various constitutive models Note: In this code, conform_p, conform_qq are in fact the Conformation tensor. The log-conformation method for viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Function Definition",
    "content": "Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function. The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In the case...",
    "content": "In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models. Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This instability poses...",
    "content": "This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) . TODO: - Perhaps, instead of the Bell\u2013Collela\u2013Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to http://basilisk.fr/src/navier-stokes/conserving.h #include \"bcg.h\" #if dimension == #error \"This implementation does not support 3D due to missing tensor boundary conditions in Basilisk (see cartesian-common.h line ~246).",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: JavaScript",
    "content": "Use log-conform-viscoelastic-scalar-3D.h for 3D simulations.\" #endif ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time symmetric tensor conform_p [], tau_p []; #if AXI scalar conform_qq [], tau_qq []; #endif event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; foreach () { foreach_dimension (){ tau_p . x . x [] = 0. ; conform_p . x . x [] = 1. ; } tau_p . x . y [] = 0. ; conform_p . x . y [] = 0. ; #if AXI tau_qq [] = 0 ; conform_qq [] = 1. ; #endif } for ( scalar s in { tau_p }) { s . v . x . i = - 1 ; // just a scalar, not the component of a vector foreach_dimension (){ if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } } for ( scalar s in { conform_p }) { s . v . x . i = - 1 ; // just a scalar, not the component of a vector foreach_dimension (){ if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } } #if AXI scalar s1 = tau_p . x . y ; s1 [ bottom ] = dirichlet ( 0. ); #endif #if AXI scalar s2 = conform_p . x . y ; s2 [ bottom ] = dirichlet ( 0. ); #endif } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } The stress tensor depends on previous instants and has to be integrated in time. In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We use a...",
    "content": "We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ). In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] event tracer_advection ( i ++) { tensor Psi = conform_p ; #if AXI scalar Psiqq = conform_qq ; #endif Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A ; A . x . y = conform_p . x . y []; foreach_dimension () A . x . x = conform_p . x . x []; In the axisymmetric case, \\(\\Psi_{\\theta \\theta} = \\log A_{\\theta \\theta}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Therefore \\(\\Psi_{\\theta \\theta}...",
    "content": "Therefore \\(\\Psi_{\\theta \\theta} = \\log [ ( 1 + \\text{fa} \\tau_{p_{\\theta \\theta}})]\\) . #if AXI double Aqq = conform_qq []; Psiqq [] = log ( Aqq ); #endif The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; pseudo_t R ; diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue. Please report this bug by opening an issue on the GitHub repository. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"Negative eigenvalue detected: Lambda.x = %g , Lambda.y = %g\\n \" , Lambda . x , Lambda . y ); fprintf ( ferr , \"x = %g , y = %g\\n \" , x , y ); exit ( 1 ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "Psi . x . y [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); foreach_dimension () Psi . x . x [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) . The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Transform omega back...",
    "content": "Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: - R is the eigenvector matrix of the conformation tensor - M is the velocity gradient tensor in the eigenvector basis - The construction ensures B is symmetric and traceless pseudo_t B ; double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi . x . y []; Psi . x . y [] += dt *( 2. * B . x . y + OM *( Psi . y . y [] - Psi . x . x [])); foreach_dimension () { s *= - 1 ; Psi . x . x [] += dt * 2. *( B . x . x + s * OM ); } In the axisymmetric case, the governing equation for \\(\\Psi_{\\theta \\theta}\\) only involves that component, \\[ \\Psi_{\\theta \\theta}|_t - 2 L_{\\theta \\theta} = \\frac{\\mathbf{f}_r(e^{-\\Psi_{\\theta \\theta}})}{\\lambda} \\] with \\(L_{\\theta \\theta} = u_y/y\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Therefore step (a)...",
    "content": "Therefore step (a) for \\(\\Psi_{\\theta \\theta}\\) is #if AXI Psiqq [] += dt * 2. * u . y []/ max ( y , 1e-20 ); #endif } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . #if AXI advection ({ Psi . x . x , Psi . x . y , Psi . y . y , Psiqq }, uf , dt ); #else advection ({ Psi . x . x , Psi . x . y , Psi . y . y }, uf , dt ); #endif Convert back to _p foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi . x . x [], Psi . x . y []}, { Psi . y . x [], Psi . y . y []}}, R ; pseudo_v Lambda ; diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; #if AXI double Aqq = exp ( Psiqq []); #endif We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); #if AXI Aqq = ( 1. - intFactor ) + intFactor * exp ( Psiqq []); #endif A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . conform_p . x . y [] = A . x . y ; tau_p . x . y [] = Gp []* A . x . y ; #if AXI conform_qq [] = Aqq ; tau_qq [] = Gp []*( Aqq - 1. ); #endif foreach_dimension (){ conform_p . x . x [] = A . x . x ; tau_p . x . x [] = Gp []*( A . x . x - 1. ); } } } Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{\\tau}_p\\) is defined at cell centers while the corresponding force (acceleration) will be defined at cell faces. Two terms contribute to each component of the momentum equation.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Examples",
    "content": "For example the \\(x\\) -component in Cartesian coordinates has the following terms: \\(\\partial_x \\mathbf{\\tau}_{p_{xx}} + \\partial_y \\mathbf{\\tau}_{p_{xy}}\\) . The first term is easy to compute since it can be calculated directly from center values of cells sharing the face. The other one is harder. It will be computed from vertex values. The vertex values are obtained by averaging centered values.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Results",
    "content": "Note that as a result of the vertex averaging cells [] and [-1,0] are not involved in the computation of shear. event acceleration ( i ++) { face vector av = a ; foreach_face () if ( fm . x [] > 1e-20 ) { double shear = ( tau_p . x . y [ 0 , 1 ]* cm [ 0 , 1 ] + tau_p . x . y [- 1 , 1 ]* cm [- 1 , 1 ] - tau_p . x . y [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - tau_p . x . y [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . x [] += ( shear + cm []* tau_p . x . x [] - cm [- 1 ]* tau_p . x . x [- 1 ])* alpha . x []/( sq ( fm . x [])* Delta ); } #if AXI foreach_face ( y ) if ( y > 0. ) av . y [] -= ( tau_qq [] + tau_qq [ 0 ,- 1 ])* alpha . y []/ sq ( y )/ 2. ; #endif }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: C/C++ Code",
    "content": "#include\"bcg.h\"#if dimension ==#error \"This implementation does not support 3D due to missing tensor boundary conditions in Basilisk (see cartesian-common.h line ~246).",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: Context",
    "content": "Use log-conform-viscoelastic-scalar-3D.h for 3D simulations.\"#endif(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation timesymmetric tensor conform_p[],tau_p[];#if AXIscalar conform_qq[],tau_qq[];#endifevent defaults(i=0){if(is_constant(a.x))a=new face vector;foreach(){foreach_dimension(){tau_p.x.x[]=0.;conform_p.x.x[]=1.;}tau_p.x.y[]=0.;conform_p.x.y[]=0.;#if AXItau_qq[]=0;conform_qq[]=1.;#endif}for(scalar s in{tau_p}){s.v.x.i=-1;// just a scalar, not the component of a vectorforeach_dimension(){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}}for(scalar s in{conform_p}){s.v.x.i=-1;// just a scalar, not the component of a vectorforeach_dimension(){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}}#if AXIscalar s1=tau_p.x.y;s1[bottom]=dirichlet(0.);#endif#if AXIscalar s2=conform_p.x.y;s2[bottom]=dirichlet(0.);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event tracer_advection(i++){tensor Psi=conform_p;#if AXIscalar Psiqq=conform_qq;#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A;A.x.y=conform_p.x.y[];foreach_dimension()A.x.x=conform_p.x.x[];",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if AXIdoubleAqq=conform_qq[];Psiqq[]=log(Aqq);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_v Lambda;pseudo_t R;diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue.Please report this bug by opening an issue on the GitHub repository.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"Negative eigenvalue detected: Lambda.x =%g, Lambda.y =%g\\n\",Lambda.x,Lambda.y);fprintf(ferr,\"x =%g, y =%g\\n\",x,y);exit(1);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "Psi.x.y[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);foreach_dimension()Psi.x.x[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "pseudo_t B;doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubles=-Psi.x.y[];Psi.x.y[]+=dt*(2.*B.x.y+OM*(Psi.y.y[]-Psi.x.x[]));foreach_dimension(){s*=-1;Psi.x.x[]+=dt*2.*(B.x.x+s*OM);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if AXIadvection({Psi.x.x,Psi.x.y,Psi.y.y,Psiqq},uf,dt);#elseadvection({Psi.x.x,Psi.x.y,Psi.y.y},uf,dt);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A={{Psi.x.x[],Psi.x.y[]},{Psi.y.x[],Psi.y.y[]}},R;pseudo_v Lambda;diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;#if AXIdoubleAqq=exp(Psiqq[]);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);#if AXIAqq=(1.-intFactor)+intFactor*exp(Psiqq[]);#endifA.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "conform_p.x.y[]=A.x.y;tau_p.x.y[]=Gp[]*A.x.y;#if AXIconform_qq[]=Aqq;tau_qq[]=Gp[]*(Aqq-1.);#endifforeach_dimension(){conform_p.x.x[]=A.x.x;tau_p.x.x[]=Gp[]*(A.x.x-1.);}}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event acceleration(i++){face vector av=a;foreach_face()if(fm.x[]>1e-20){doubleshear=(tau_p.x.y[0,1]*cm[0,1]+tau_p.x.y[-1,1]*cm[-1,1]-tau_p.x.y[0,-1]*cm[0,-1]-tau_p.x.y[-1,-1]*cm[-1,-1])/4.;av.x[]+=(shear+cm[]*tau_p.x.x[]-cm[-1]*tau_p.x.x[-1])*alpha.x[]/(sq(fm.x[])*Delta);}#if AXIforeach_face(y)if(y>0.)av.y[]-=(tau_qq[]+tau_qq[0,-1])*alpha.y[]/sq(y)/2.;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "src-local/log-conform-viscoelastic-scalar-2D.h See raw file Log-Conformation Method for 2D Viscoelastic Fluids Overview Title : log-conform-viscoelastic-scalar-2D.h Version : 2.5 Description : 2D and axisymmetric scalar implementation of viscoelastic fluid dynamics using the log-conformation method Key Features Conformation tensor A exists across domain and relaxes according to \u03bb Stress acts according to elastic modulus G Supports both 2D and axisymmetric configurations Scalar implementation approach for better performance Compatible with log-conform-viscoelastic.h Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Nov 23, 2024 Implementation Notes Based on http://basilisk.fr/src/log-conform.h with key improvements: Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling bug where [\u03c3_p] = 0 & [\u03c3_s] = \u03b3\u03ba Ensures [\u03c3_s+\u03c3_p] = \u03b3\u03ba for correct interface behavior Version History v1.0 (Oct 18, 2024) Initial implementation with 2D+axi support Scalar-based implementation for efficiency v2.0 (Nov 3, 2024) Major documentation improvements Made code an axisymmetric mirror of log-conform-viscoelastic-scalar-3D.h Added negative eigenvalue detection with location reporting Added initialization functions for pseudo_v and pseudo_t v2.1 (Nov 14, 2024) Added support for infinite Deborah number cases v2.5 (Nov 23, 2024) Enhanced documentation clarity and completeness Future Work Tensor Formulation Convert to consistent tensor formulation for: Improved readability and maintainability Better computational efficiency Reduced potential for bugs Prerequisites for axi compatibility in 3D version Related issues: https://github.com/comphy-lab/Viscoelastic3D/issues/11 https://github.com/comphy-lab/Viscoelastic3D/issues/5 Code Improvements Enforce tensor usage throughout codebase Implement foreach_dimension compatibility The log-conformation method for viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Therefore these materials...",
    "content": "Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers. Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The conformation tensor...",
    "content": "The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time. In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Parameters The primary...",
    "content": "Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features. This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: TODO: - Perhaps,...",
    "content": "TODO: - Perhaps, instead of the Bell\u2013Collela\u2013Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to http://basilisk.fr/src/navier-stokes/conserving.h #include \"bcg.h\" ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time scalar A11 [], A12 [], A22 []; // conformation tensor scalar T11 [], T12 [], T22 []; // stress tensor #if AXI scalar AThTh [], T_ThTh []; #endif event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; /* initialize A and T */ for ( scalar s in { A11 , A22 }) { foreach () { s [] = 1. ; } } for ( scalar s in { T11 , T12 , T22 , A12 }) { foreach (){ s [] = 0. ; } } #if AXI foreach (){ T_ThTh [] = 0 ; AThTh [] = 1. ; } #endif for ( scalar s in { T11 , T12 , T22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } for ( scalar s in { A11 , A12 , A22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } #if AXI T12 [ bottom ] = dirichlet ( 0. ); A12 [ bottom ] = dirichlet ( 0. ); #endif } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } The stress tensor depends on previous instants and has to be integrated in time. In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We use a...",
    "content": "We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ).",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In an Oldroyd-B...",
    "content": "In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] event tracer_advection ( i ++) { scalar Psi11 = A11 ; scalar Psi12 = A12 ; scalar Psi22 = A22 ; #if AXI scalar Psiqq = AThTh ; #endif Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A ; A . x . x = A11 []; A . y . y = A22 []; A . x . y = A12 []; #if AXI double Aqq = AThTh []; Psiqq [] = log ( Aqq ); #endif The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); pseudo_t R ; init_pseudo_t (& R , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues -- this should never happen.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: If it does,...",
    "content": "If it does, print the location and value of the offending eigenvalue. Please report this bug by opening an issue on the GitHub repository. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"Negative eigenvalue detected: Lambda.x = %g , Lambda.y = %g\\n \" , Lambda . x , Lambda . y ); fprintf ( ferr , \"x = %g , y = %g\\n \" , x , y ); exit ( 1 ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) . Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); Psi22 [] = sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . x )* log ( Lambda . x ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The diagonalization will...",
    "content": "The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis. Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: R is the eigenvector matrix of the conformation tensor M is the velocity gradient tensor in the eigenvector basis The construction ensures B is symmetric and traceless pseudo_t B ; init_pseudo_t (& B , 0.0 ); double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; init_pseudo_t (& M , 0.0 ); foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi12 []; Psi12 [] += dt * ( 2. * B . x . y + OM * ( Psi22 [] - Psi11 [])); s *= - 1 ; Psi11 [] += dt * 2. * ( B . x . x + s * OM ); s *= - 1 ; Psi22 [] += dt * 2. * ( B . y . y + s * OM ); In the axisymmetric case, the governing equation for \\(\\Psi_{\\theta \\theta}\\) only involves that component, \\[ \\Psi_{\\theta \\theta}|_t - 2 L_{\\theta \\theta} = \\frac{\\mathbf{f}_r(e^{-\\Psi_{\\theta \\theta}})}{\\lambda} \\] with \\(L_{\\theta \\theta} = u_y/y\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Therefore step (a)...",
    "content": "Therefore step (a) for \\(\\Psi_{\\theta \\theta}\\) is #if AXI Psiqq [] += dt * 2. * u . y []/ max ( y , 1e-20 ); #endif } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . #if AXI advection ({ Psi11 , Psi12 , Psi22 , Psiqq }, uf , dt ); #else advection ({ Psi11 , Psi12 , Psi22 }, uf , dt ); #endif Convert back to Aij foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi11 [], Psi12 []}, { Psi12 [], Psi22 []}}, R ; init_pseudo_t (& R , 0.0 ); pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; #if AXI double Aqq = exp ( Psiqq []); #endif We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); #if AXI Aqq = ( 1. - intFactor ) + intFactor * exp ( Psiqq []); #endif A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . A12 [] = A . x . y ; T12 [] = Gp []* A . x . y ; #if AXI AThTh [] = Aqq ; T_ThTh [] = Gp []*( Aqq - 1. ); #endif A11 [] = A . x . x ; T11 [] = Gp []*( A . x . x - 1. ); A22 [] = A . y . y ; T22 [] = Gp []*( A . y . y - 1. ); } } Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{\\tau}_p\\) is defined at cell centers while the corresponding force (acceleration) will be defined at cell faces. Two terms contribute to each component of the momentum equation.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Examples",
    "content": "For example the \\(x\\) -component in Cartesian coordinates has the following terms: \\(\\partial_x \\mathbf{\\tau}_{p_{xx}} + \\partial_y \\mathbf{\\tau}_{p_{xy}}\\) . The first term is easy to compute since it can be calculated directly from center values of cells sharing the face. The other one is harder. It will be computed from vertex values. The vertex values are obtained by averaging centered values.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Results",
    "content": "Note that as a result of the vertex averaging cells [] and [-1,0] are not involved in the computation of shear. event acceleration ( i ++) { face vector av = a ; foreach_face ( x ){ if ( fm . x [] > 1e-20 ) { double shearX = ( T12 [ 0 , 1 ]* cm [ 0 , 1 ] + T12 [- 1 , 1 ]* cm [- 1 , 1 ] - T12 [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . x [] += ( shearX + cm []* T11 [] - cm [- 1 ]* T11 [- 1 ])* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ){ if ( fm . y [] > 1e-20 ) { double shearY = ( T12 [ 1 , 0 ]* cm [ 1 , 0 ] + T12 [ 1 ,- 1 ]* cm [ 1 ,- 1 ] - T12 [- 1 , 0 ]* cm [- 1 , 0 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . y [] += ( shearY + cm []* T22 [] - cm [ 0 ,- 1 ]* T22 [ 0 ,- 1 ])* alpha . y []/( sq ( fm . y [])* Delta ); } } #if AXI foreach_face ( y ) if ( y > 1e-20 ) av . y [] -= ( T_ThTh [] + T_ThTh [ 0 ,- 1 ])* alpha . y []/ sq ( y )/ 2. ; #endif }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: C/C++ Code",
    "content": "#include\"bcg.h\"(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation timescalar A11[],A12[],A22[];// conformation tensorscalar T11[],T12[],T22[];// stress tensor#if AXIscalar AThTh[],T_ThTh[];#endifevent defaults(i=0){if(is_constant(a.x))a=new face vector;/*initialize A and T*/for(scalar s in{A11,A22}){foreach(){s[]=1.;}}for(scalar s in{T11,T12,T22,A12}){foreach(){s[]=0.;}}#if AXIforeach(){T_ThTh[]=0;AThTh[]=1.;}#endiffor(scalar s in{T11,T12,T22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}for(scalar s in{A11,A12,A22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}#if AXIT12[bottom]=dirichlet(0.);A12[bottom]=dirichlet(0.);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event tracer_advection(i++){scalar Psi11=A11;scalar Psi12=A12;scalar Psi22=A22;#if AXIscalar Psiqq=AThTh;#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A;A.x.x=A11[];A.y.y=A22[];A.x.y=A12[];#if AXIdoubleAqq=AThTh[];Psiqq[]=log(Aqq);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);pseudo_t R;init_pseudo_t(&R,0.0);diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue.Please report this bug by opening an issue on the GitHub repository.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"Negative eigenvalue detected: Lambda.x =%g, Lambda.y =%g\\n\",Lambda.x,Lambda.y);fprintf(ferr,\"x =%g, y =%g\\n\",x,y);exit(1);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);Psi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);Psi22[]=sq(R.y.y)*log(Lambda.y)+sq(R.y.x)*log(Lambda.x);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "pseudo_t B;init_pseudo_t(&B,0.0);doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;init_pseudo_t(&M,0.0);foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubles=-Psi12[];Psi12[]+=dt*(2.*B.x.y+OM*(Psi22[]-Psi11[]));s*=-1;Psi11[]+=dt*2.*(B.x.x+s*OM);s*=-1;Psi22[]+=dt*2.*(B.y.y+s*OM);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if AXIadvection({Psi11,Psi12,Psi22,Psiqq},uf,dt);#elseadvection({Psi11,Psi12,Psi22},uf,dt);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A={{Psi11[],Psi12[]},{Psi12[],Psi22[]}},R;init_pseudo_t(&R,0.0);pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;#if AXIdoubleAqq=exp(Psiqq[]);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);#if AXIAqq=(1.-intFactor)+intFactor*exp(Psiqq[]);#endifA.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "A12[]=A.x.y;T12[]=Gp[]*A.x.y;#if AXIAThTh[]=Aqq;T_ThTh[]=Gp[]*(Aqq-1.);#endifA11[]=A.x.x;T11[]=Gp[]*(A.x.x-1.);A22[]=A.y.y;T22[]=Gp[]*(A.y.y-1.);}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event acceleration(i++){face vector...",
    "content": "event acceleration(i++){face vector av=a;foreach_face(x){if(fm.x[]>1e-20){doubleshearX=(T12[0,1]*cm[0,1]+T12[-1,1]*cm[-1,1]-T12[0,-1]*cm[0,-1]-T12[-1,-1]*cm[-1,-1])/4.;av.x[]+=(shearX+cm[]*T11[]-cm[-1]*T11[-1])*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){doubleshearY=(T12[1,0]*cm[1,0]+T12[1,-1]*cm[1,-1]-T12[-1,0]*cm[-1,0]-T12[-1,-1]*cm[-1,-1])/4.;av.y[]+=(shearY+cm[]*T22[]-cm[0,-1]*T22[0,-1])*alpha.y[]/(sq(fm.y[])*Delta);}}#if AXIforeach_face(y)if(y>1e-20)av.y[]-=(T_ThTh[]+T_ThTh[0,-1])*alpha.y[]/sq(y)/2.;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "src-local/two-phaseVE.h See raw file Modification by Vatsal Sanjay Version 2.0, Oct 17, 2024 Changelog Oct 17, 2024: added support for VE simulations. Brief history v1.0 is the vanilla Basilisk code for two-phase flows: http://basilisk.fr/src/two-phase.h + http://basilisk.fr/src/two-phase-generic.h v2.0 is the modification for viscoelastic fluids using the log-conformation method. Two-phase interfacial flows This is a modified version of two-phase.h . It contains the implementation of Viscoplastic Fluid (Bingham Fluid). This file helps setup simulations for flows of two fluids separated by an interface (i.e. immiscible fluids). It is typically used in combination with a Navier\u2013Stokes solver . The interface between the fluids is tracked with a Volume-Of-Fluid method. The volume fraction in fluid 1 is \\(f=1\\) and \\(f=0\\) in fluid 2.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "The densities and dynamic viscosities for fluid 1 and 2 are rho1 , mu1 , rho2 , mu2 , respectively. #include \"vof.h\" scalar f [], * interfaces = { f }; double rho1 = 1. , mu1 = 0. , rho2 = 1. , mu2 = 0. ; double G1 = 0. , G2 = 0. ; // elastic moduli double lambda1 = 0. , lambda2 = 0. ; // relaxation times double TOLelastic = 1e-2 ; // tolerance for elastic modulus #TOFIX: this must always be a very small number. Auxilliary fields are necessary to define the (variable) specific volume \\(\\alpha=1/\\rho\\) as well as the cell-centered density. face vector alphav []; scalar rhov []; scalar Gpd []; scalar lambdapd []; event defaults ( i = 0 ) { alpha = alphav ; rho = rhov ; Gp = Gpd ; lambda = lambdapd ; If the viscosity is non-zero, we need to allocate the face-centered viscosity field. mu = new face vector ; } The density and viscosity are defined using arithmetic averages by default.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Definitions - Python Function",
    "content": "The user can overload these definitions to use other types of averages (i.e. harmonic). #ifndef rho # define rho ( f ) ( clamp ( f , 0. , 1. )*( rho1 - rho2 ) + rho2 ) 62 #endif #ifndef mu // for Arithmetic mean, use this # define mu ( f ) ( clamp ( f , 0. , 1. )*( mu1 - mu2 ) + mu2 ) 66 #endif We have the option of using some \u201csmearing\u201d of the density/viscosity jump. #ifdef FILTERED scalar sf []; #else # define sf f 76 #endif event tracer_advection ( i ++) { When using smearing of the density jump, we initialise sf with the vertex-average of f . #ifndef sf #if dimension <= foreach () sf [] = ( 4. * f [] + 2. *( f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 1 , 0 ] + f [- 1 , 0 ]) + f [- 1 ,- 1 ] + f [ 1 ,- 1 ] + f [ 1 , 1 ] + f [- 1 , 1 ])/ 16. ; #else // dimension == foreach () sf [] = ( 8. * f [] + 4. *( f [- 1 ] + f [ 1 ] + f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 0 , 0 , 1 ] + f [ 0 , 0 ,- 1 ]) + 2. *( f [- 1 , 1 ] + f [- 1 , 0 , 1 ] + f [- 1 , 0 ,- 1 ] + f [- 1 ,- 1 ] + f [ 0 , 1 , 1 ] + f [ 0 , 1 ,- 1 ] + f [ 0 ,- 1 , 1 ] + f [ 0 ,- 1 ,- 1 ] + f [ 1 , 1 ] + f [ 1 , 0 , 1 ] + f [ 1 ,- 1 ] + f [ 1 , 0 ,- 1 ]) + f [ 1 ,- 1 , 1 ] + f [- 1 , 1 , 1 ] + f [- 1 , 1 ,- 1 ] + f [ 1 , 1 , 1 ] + f [ 1 , 1 ,- 1 ] + f [- 1 ,- 1 ,- 1 ] + f [ 1 ,- 1 ,- 1 ] + f [- 1 ,- 1 , 1 ])/ 64. ; #endif #endif #if TREE sf . prolongation = refine_bilinear ; sf . dirty = true ; // boundary conditions need to be updated #endif } event properties ( i ++) { foreach_face () { double ff = ( sf [] + sf [- 1 ])/ 2. ; alphav . x [] = fm . x []/ rho ( ff ); face vector muv = mu ; muv . x [] = fm . x []* mu ( ff ); } foreach (){ rhov [] = cm []* rho ( sf []); Gpd [] = 0. ; lambdapd [] = 0. ; if ( clamp ( sf [], 0. , 1. ) > TOLelastic ){ Gpd [] += G1 * clamp ( sf [], 0. , 1. ); lambdapd [] += lambda1 * clamp ( sf [], 0. , 1. ); } if ( clamp (( 1 - sf []), 0. , 1. ) > TOLelastic ){ Gpd [] += G2 * clamp (( 1 - sf []), 0. , 1. ); lambdapd [] += lambda2 * clamp (( 1 - sf []), 0. , 1. ); } } #if TREE sf . prolongation = fraction_refine ; sf . dirty = true ; // boundary conditions need to be updated #endif }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"vof.h\"scalar f[],*interfaces={f};doublerho1=1.,mu1=0.,rho2=1.,mu2=0.;doubleG1=0.,G2=0.;// elastic modulidoublelambda1=0.,lambda2=0.;// relaxation timesdoubleTOLelastic=1e-2;// tolerance for elastic modulus #TOFIX: this must always be a very small number.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "face vector alphav[];scalar rhov[];scalar Gpd[];scalar lambdapd[];event defaults(i=0){alpha=alphav;rho=rhov;Gp=Gpd;lambda=lambdapd;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Function: rho",
    "content": "#ifndef rho# define rho(f)(clamp(f,0.,1.)*(rho1-rho2)+rho2)62#endif#ifndef mu// for Arithmetic mean, use this# define mu(f)(clamp(f,0.,1.)*(mu1-mu2)+mu2)66#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Function: FILTEREDscalar",
    "content": "#ifdef FILTEREDscalar sf[];#else# define sf f76#endifevent tracer_advection(i++){",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Function: sf",
    "content": "#ifndef sf#if dimension <=foreach()sf[]=(4.*f[]+2.*(f[0,1]+f[0,-1]+f[1,0]+f[-1,0])+f[-1,-1]+f[1,-1]+f[1,1]+f[-1,1])/16.;#else// dimension ==foreach()sf[]=(8.*f[]+4.*(f[-1]+f[1]+f[0,1]+f[0,-1]+f[0,0,1]+f[0,0,-1])+2.*(f[-1,1]+f[-1,0,1]+f[-1,0,-1]+f[-1,-1]+f[0,1,1]+f[0,1,-1]+f[0,-1,1]+f[0,-1,-1]+f[1,1]+f[1,0,1]+f[1,-1]+f[1,0,-1])+f[1,-1,1]+f[-1,1,1]+f[-1,1,-1]+f[1,1,1]+f[1,1,-1]+f[-1,-1,-1]+f[1,-1,-1]+f[-1,-1,1])/64.;#endif#endif#if TREEsf.prolongation=refine_bilinear;sf.dirty=true;// boundary conditions need to be updated#endif}event properties(i++){foreach_face(){doubleff=(sf[]+sf[-1])/2.;alphav.x[]=fm.x[]/rho(ff);face vector muv=mu;muv.x[]=fm.x[]*mu(ff);}foreach(){rhov[]=cm[]*rho(sf[]);Gpd[]=0.;lambdapd[]=0.;if(clamp(sf[],0.,1.)>TOLelastic){Gpd[]+=G1*clamp(sf[],0.,1.);lambdapd[]+=lambda1*clamp(sf[],0.,1.);}if(clamp((1-sf[]),0.,1.)>TOLelastic){Gpd[]+=G2*clamp((1-sf[]),0.,1.);lambdapd[]+=lambda2*clamp((1-sf[]),0.,1.);}}#if TREEsf.prolongation=fraction_refine;sf.dirty=true;// boundary conditions need to be updated#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # tested on MacOS only.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue. # modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk # Check if --hard flag is passed HARD_RESET = \\f alse if [[ \" \\$ 1\" == \"--hard\" ]]; then HARD_RESET = \\t rue fi # Function to install basilisk install_basilisk() { darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make -k make } # Remove project config always rm -rf .project_config # Check if basilisk needs to be installed if [[ \" \\$ HARD_RESET\" == true ]] || [[ ! -d \"basilisk\" ]]; then echo \"Installing basilisk...\" rm -rf basilisk install_basilisk else echo \"Using existing basilisk installation...\" cd basilisk/src fi # Setup environment variables echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config # Check if qcc is working properly echo \"\\nChecking qcc installation...\" if ! qcc --version > /dev/null 2 >& 1 ; then echo \"\\033[0;31mError: qcc is not working properly.\\033[0m\" echo \"Please ensure you have Xcode Command Line Tools installed.\" echo \"You can install them by running: xcode-select --install\" echo \"For more details, visit: http://basilisk.fr/src/INSTALL\" exit 1 else echo \"\\033[0;32mqcc is properly installed.\\033[0m\" qcc --version fi",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: #!/bin/zsh# tested on...",
    "content": "#!/bin/zsh# tested on MacOS only.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue.# modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basilisk# Check if --hard flag is passedHARD_RESET=\\falseif[[\"\\$1\"==\"--hard\"]];thenHARD_RESET=\\truefi# Function to install basiliskinstall_basilisk(){darcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake-kmake}# Remove project config alwaysrm-rf.project_config# Check if basilisk needs to be installedif[[\"\\$HARD_RESET\"==true]]||[[!-d\"basilisk\"]];thenecho\"Installing basilisk...\"rm-rfbasiliskinstall_basiliskelseecho\"Using existing basilisk installation...\"cdbasilisk/srcfi# Setup environment variablesecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config# Check if qcc is working properlyecho\"\\nChecking qcc installation...\"if!qcc--version>/dev/null2>&1;thenecho\"\\033[0;31mError: qcc is not working properly.\\033[0m\"echo\"Please ensure you have Xcode Command Line Tools installed.\"echo\"You can install them by running: xcode-select --install\"echo\"For more details, visit: http://basilisk.fr/src/INSTALL\"exit1elseecho\"\\033[0;32mqcc is properly installed.\\033[0m\"qcc--versionfi",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Herschel-Bulkley Worthington Jets...",
    "content": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles This repository contains the simulation code and analysis for studying the dynamics of Herschel-Bulkley Worthington jets and droplets produced by bursting bubbles.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: JavaScript",
    "content": "The code uses the Basilisk framework to simulate bubble cavity collapse in non-Newtonian media, examining how power-law index, yield stress, and viscosity affect jet and droplet formation. basilisk/src/ - Core Basilisk CFD library (reference only, do not modify) simulationCases/ - Simulation cases and input/output data burstingBubbleHB.c - Main Herschel-Bulkley bursting bubble simulation initial-condition-test.ipynb - Jupyter notebook for initial condition tests Makefile - Makefile for compiling/running cases runMake.sh - Helper script for running make src-local/ - Custom header files extending Basilisk functionality two-phaseVP-HB.h - Herschel-Bulkley two-phase flow model postProcess/ - Project-specific post-processing tools getData.c - Data extraction utility getFacets.c - Facet extraction utility video.py - Python script for video/visualization reset_install_requirements.sh - Script to set up Basilisk and dependencies Overview The project investigates how non-Newtonian behavior influences bubble bursting dynamics by exploring the phase space of effective Ohnesorge number, power-law index, and plasto-capillary number using volume of fluid-based finite volume simulations.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Results",
    "content": "The results demonstrate how shear-thinning/thickening behavior and yield stress significantly influence the overall dynamics through the interplay of viscous and plastic effects. Installation and Setup To ensure you have the necessary tools and a fresh Basilisk installation, use the provided script: ./reset_install_requirements.sh Function This script checks for Basilisk installation and compiles it if not present. OS Compatibility Designed for macOS. If you encounter issues on Linux, please open a GitHub issue. Dependencies Basilisk C is fetched and built automatically. Xcode Command Line Tools (macOS) or equivalent compiler toolchain (Linux) are required. Environment Setup After running the script, a .project_config file is created, setting BASILISK and PATH automatically.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "If you have previously installed Basilisk or changed dependencies, re-run the script with --hard : ./reset_install_requirements.sh --hard Running the Code Recommended Method: Using Makefile The easiest way to compile and run the code is using the Makefile approach: Navigate to the testCases directory: cd testCases Compile and run using make (this runs the code interactively using the browser): CFLAGS = -DDISPLAY=-1 make burstingBubbleVE.tst To run the code non-interactively, use the following command: make burstingBubbleVE.tst Alternative Method: Direct Compilation You can compile the code directly using qcc in two ways: Using include paths (recommended): qcc -O2 -Wall -disable-dimensions -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm Without include paths: qcc -O2 -Wall -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm Note : If using method 2, you must first manually copy the src-local folder to your running directory.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Local Execution MacOS:...",
    "content": "Local Execution MacOS: # First source the configuration source .project_config # Compile using include paths (recommended) qcc -O2 -Wall -disable-dimensions -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm # Or compile without include paths (requires manually copying src-local folder) qcc -O2 -Wall -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm # Run the executable, only supports serial execution ./burstingBubbleVE Linux: # First source the configuration source .project_config # Compile using include paths (recommended) qcc -O2 -Wall -disable-dimensions -fopenmp -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm # Or compile without include paths (requires manually copying src-local folder) qcc -O2 -Wall -disable-dimensions -fopenmp burstingBubbleVE.c -o burstingBubbleVE -lm # Set the number of OpenMP threads export OMP_NUM_THREADS = 4 # Run the executable ./burstingBubbleVE HPC Cluster Execution (e.g., Snellius) For cluster environments, it is strongly recommended to manually copy the src-local folder to your working directory to ensure reliable compilation across different cluster configurations: First, copy the required files: cp -r /path/to/original/src-local .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Compile the code...",
    "content": "Compile the code for MPI: CC99 = 'mpicc -std=c99' qcc -Wall -O2 -D_MPI = 1 -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm Create a SLURM job script (e.g., run_simulation.sh ): #!/bin/bash #SBATCH --nodes=1 #SBATCH --ntasks=32 #SBATCH --time=1:00:00 #SBATCH --partition=genoa #SBATCH --mail-type=ALL #SBATCH --mail-user=v.sanjay@utwente.nl srun --mpi = pmi2 -n 32 --gres = cpu:32 --mem-per-cpu = 1750mb burstingBubbleVE Submit the job: sbatch run_simulation.sh Additional Running Scripts The z_extras/running directory contains supplementary materials and post-processing tools used in the analysis. This includes C-based data extraction utilities, Python visualization scripts, and analysis notebooks. These tools were used to process simulation outputs and generate figures for the study. For detailed documentation of these tools, see the README in the z_extras directory. Contributing Issues & Contributions : Please file bug reports, feature requests, or pull requests on GitHub .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: When creating an...",
    "content": "When creating an issue, please: For bug reports: Include the error message, OS version, and steps to reproduce the issue For feature requests: Clearly describe the proposed feature and its use case For questions: Check existing issues and documentation first We welcome contributions! Please feel free to submit a Pull Request. Reset Install Requirements Script The reset_install_requirements.sh script is designed to reset the installation requirements for the project. This can be useful when you want to ensure that all dependencies are fresh and up-to-date. Purpose The script re-installs all required packages as specified in the requirements file, ensuring that the project\u2019s dependencies are up-to-date and consistent. Usage To run the script, use the following command in your terminal: bash reset_install_requirements.sh Make sure to have the necessary permissions to execute the script.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Citation If you...",
    "content": "Citation If you use this code in your research, please cite: Software Authors Vatsal Sanjay (University of Twente), vatsalsanjay@gmail.com License This project is licensed under standard academic terms. Please cite the paper and software if you use this code in your research. Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/getData.c postProcess/getFacets.c postProcess/video.py simulationCases simulationCases/Makefile simulationCases/burstingBubbleHB.c simulationCases/initial-condition-test.ipynb simulationCases/runMake.sh src-local src-local/two-phaseVP-HB.h",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "qcc-O2-Wall-disable-dimensions-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "qcc-O2-Wall-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# First source the configurationsource.project_config# Compile using include paths (recommended)qcc-O2-Wall-disable-dimensions-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm# Or compile without include paths (requires manually copying src-local folder)qcc-O2-Wall-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm# Run the executable, only supports serial execution./burstingBubbleVE",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# First source the configurationsource.project_config# Compile using include paths (recommended)qcc-O2-Wall-disable-dimensions-fopenmp-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm# Or compile without include paths (requires manually copying src-local folder)qcc-O2-Wall-disable-dimensions-fopenmpburstingBubbleVE.c-oburstingBubbleVE-lm# Set the number of OpenMP threadsexportOMP_NUM_THREADS=4# Run the executable./burstingBubbleVE",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "CC99='mpicc -std=c99'qcc-Wall-O2-D_MPI=1-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#!/bin/bash#SBATCH --nodes=1#SBATCH --ntasks=32#SBATCH --time=1:00:00#SBATCH --partition=genoa#SBATCH --mail-type=ALL#SBATCH --mail-user=v.sanjay@utwente.nlsrun--mpi=pmi2-n32--gres=cpu:32--mem-per-cpu=1750mb burstingBubbleVE",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases burstingBubbleHB.c This simulation models the dynamics of bursting bubbles in Herschel-Bulkley media, with particular focus on Worthingt... initial-condition-test.ipynb The basilisk script needs the points to be sorted such that the first point is the south pole of the bubble cavity th... Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje... runMake.sh source ../.projectconfig echo \\$BASILISK mkdir -p \\$1 qcc -O2 -Wall -disable-dimensions -I\\$(PWD)/src-local -I\\$(PWD)...",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local # Fix permissions for runtest script fix-permissions: @chmod +x \\$ ( BASILISK ) /src/runtest # Make all test targets depend on fix-permissions %.tst: fix-permissions include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)CFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-local# Fix permissions for runtest scriptfix-permissions:@chmod+x\\$(BASILISK)/src/runtest# Make all test targets depend on fix-permissions%.tst:fix-permissionsinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/initial-condition-test.ipynb | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "simulationCases/initial-condition-test.ipynb See raw file Reverse engineer to fix bug Jupyter Notebook: Reverse engineer to fix bug Download Notebook View in nbviewer Open in Colab About this notebook The basilisk script needs the points to be sorted such that the first point is the south pole of the bubble cavity then you walk along the liquid-gas interface towards the bubble cap and then join to the far field liquid-gas interface (which is a straight line). Key Features: Visualization of data and results Analysis of simulation outputs Interactive exploration of parameters Tip: For the best interactive experience, download the notebook or open it in Google Colab. Notebook Preview Notebook Preview Unavailable The notebook preview could not be loaded.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/initial-condition-test.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/initial-condition-test.ipynb | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: This may be...",
    "content": "This may be because: The notebook file is not yet available in the repository The nbviewer service is temporarily unavailable The repository is private or has access restrictions You can still download the notebook using the button above or view it directly through one of the external services.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/initial-condition-test.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runMake.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles",
    "content": "simulationCases/runMake.sh See raw file runMake.sh #!/bin/bash source ../.project_config echo \\$ BASILISK mkdir -p \\$ 1 qcc -O2 -Wall -disable-dimensions -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local \\$ 1.c -o \\$ 1/\\$1 -lm cd \\$ 1 ./\\$1",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/runMake.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runMake.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#!/bin/bashsource../.project_configecho\\$BASILISKmkdir-p\\$1qcc-O2-Wall-disable-dimensions-I\\$(PWD)/src-local-I\\$(PWD)/../src-local\\$1.c-o\\$1/\\$1-lmcd\\$1./\\$1",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/runMake.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "simulationCases/burstingBubbleHB.c See raw file Bursting Bubbles in Herschel-Bulkley Media Simulation This simulation models the dynamics of bursting bubbles in Herschel-Bulkley media, with particular focus on Worthington jet formation and droplet ejection. The code implements a two-phase flow model with non-Newtonian rheology using an epsilon-regularisation approach.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: File Information File:...",
    "content": "File Information File: burstingBubbleHB.c Author: Vatsal Sanjay Version: 1.0 Date: Dec 31, 2024 Usage ./program maxLevel n OhK J Bond tmax Parameters maxLevel : Maximum refinement level for adaptive mesh n : Power-law index OhK : k-effective Ohnesorge number for the liquid phase: \\(Oh_k = \\frac{k}{\\sqrt{\\rho^nR_0^{3n-1}\\gamma^{2-n}}}\\) J : Plasto-capillary number: \\(\\mathcal{J} = \\frac{\\tau_yR_0}{\\gamma}\\) Bond : Bond number (ratio of gravitational to surface tension forces): \\(Bo = \\frac{\\rho g R_0^2}{\\gamma}\\) tmax : Maximum simulation time #include \"axi.h\" #include \"navier-stokes/centered.h\" Simulation Configuration Global Parameters FILTERED : Enable density and viscosity jump smoothing tsnap : Time interval between snapshots (default: 1e-2) fErr : Error tolerance for volume fraction (1e-3) KErr : Error tolerance for curvature calculation (1e-6) VelErr : Error tolerance for velocity field (1e-3) D2Err : Error tolerance for conformation inside the liquid (1e-2) Ldomain : Domain size in characteristic lengths (8) #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVP-HB.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #if !_MPI #include \"distance.h\" #endif #define tsnap ( 1e-2 ) // 0.001 only for some cases. // Error tolerances #define fErr ( 1e-3 ) // Error tolerance in f1 VOF #define KErr ( 1e-6 ) // Error tolerance in VoF curvature calculated using // height function method (see adapt event) #define VelErr ( 1e-3 ) // Error tolerances in velocity -- Use 1e-2 for low Oh // and 1e-3 to 5e-3 for high Oh/moderate to high J #define D2Err ( 1e-2 ) // Error tolerances in conformation inside the liquid // Domain size #define Ldomain 8 65 // Boundary conditions - outflow on the right boundary u . n [ right ] = neumann ( 0. ); p [ right ] = dirichlet ( 0. ); int MAXlevel ; double OhK , Oha , J , Bond , tmax ; char nameOut [ 80 ], dumpFile [ 80 ], logFile [ 80 ]; Main Function The entry point of the simulation that initializes parameters and starts the simulation run.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Main",
    "content": "Parameters argc : Number of command line arguments argv : Array of command line argument strings Returns Integer status code (0 on successful completion) int main ( int argc , char const * argv []) { L0 = Ldomain ; origin (- L0 / 2. , 0. ); Parameter Initialization Setting default values for simulation parameters. In production runs, these values can be passed from the command line. MAXlevel = 10 ; n = 0.4 ; OhK = 0.001 ; J = 2e-1 ; Bond = 1e0 ; tmax = 2.5e0 ; epsilon = 1e-2 ; Command Line Argument Parsing To get parameters from the terminal, uncomment the following block. // First ensure that all the variables were transferred properly from the // terminal or job script. if ( argc < 7 ) { fprintf ( ferr , \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Need %d more...",
    "content": "Need %d more \" \"arguments \\n \" , 7 - argc ); return 1 ; } MAXlevel = atoi ( argv [ 1 ]); n = atof ( argv [ 2 ]); OhK = atof ( argv [ 3 ]); J = atof ( argv [ 4 ]); Bond = atof ( argv [ 5 ]); tmax = atof ( argv [ 6 ]); epsilon = 1e-2 ; init_grid ( 1 << 5 ); // Create a folder named intermediate where all the simulation snapshots are stored char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file. See writingFiles event sprintf ( dumpFile , \"restart\" ); // Name of the log file.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: See logWriting event...",
    "content": "See logWriting event sprintf ( logFile , \"logData.dat\" ); Physical Properties Configuration Phase Properties rho1 , rho2 : Density of liquid and gas phases mu1 , mu2 : Dynamic viscosity of liquid and gas phases Dimensionless Numbers Oh : Ohnesorge number for liquid phase Oha : Ohnesorge number for gas phase (= 2e-2 * Oh) J : Plasto-capillary number Bond : Bond number rho1 = 1. , rho2 = 1e-3 ; Oha = 2e-2 * OhK ; mu1 = OhK , mu2 = Oha ; tauy = J ; f . sigma = 1.0 ; TOLERANCE = 1e-4 ; CFL = 1e-1 ; run (); } Initialization Event Sets up the initial conditions for the simulation at t=0.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Function Definition",
    "content": "Process Attempts to restore from a dump file If not available, loads initial shape from data file Sets up distance function and volume fraction event init ( t = 0 ) { #if _MPI // This is for supercomputers without OpenMP support if (! restore ( file = dumpFile )) { fprintf ( ferr , \"Cannot restored from a dump file! \\n \" ); } #else if (! restore ( file = dumpFile )) { char filename [ 60 ]; // sprintf(filename,\"Bo%5.4f-buggy.dat\",Bond); // sprintf(filename,\"Bo%5.4f.dat\",Bond); sprintf ( filename , \"Bo %5.4f -buggy_fixed.dat\" , Bond ); FILE * fp = fopen ( filename , \"rb\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); // Try in folder one level up // sprintf(filename,\"../Bo%5.4f-buggy.dat\",Bond); // sprintf(filename,\"../Bo%5.4f.dat\",Bond); sprintf ( filename , \"../Bo %5.4f -buggy_fixed.dat\" , Bond ); fp = fopen ( filename , \"rb\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); return 1 ; } } coord * InitialShape ; InitialShape = input_xy ( fp ); fclose ( fp ); scalar d []; distance ( d , InitialShape ); while ( adapt_wavelet (( scalar *){ f , d }, ( double []){ 1e-8 , 1e-8 }, MAXlevel ). nf ); // The distance function is defined at the center of each cell, we have // to calculate the value of this function at each vertex. vertex scalar phi []; foreach_vertex () { phi [] = -( d [] + d [- 1 ] + d [ 0 ,- 1 ] + d [- 1 ,- 1 ])/ 4. ; } // We can now initialize the volume fraction of the domain. fractions ( phi , f ); } // return 1; #endif } Adaptive Mesh Refinement Implements wavelet-based adaptive mesh refinement to focus computational resources on areas of interest.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: JavaScript",
    "content": "Refinement Criteria Volume fraction gradient Velocity field changes Conformation tensor variations Curvature details event adapt ( i ++) { scalar KAPPA []; curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , u . x , u . y , D2 , KAPPA }, ( double []){ fErr , VelErr , VelErr , D2Err , KErr }, MAXlevel , MAXlevel - 6 ); } Output Generation Periodically saves simulation state for post-processing and creates snapshots at regular intervals.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Output Files Restart...",
    "content": "Output Files Restart file for continuing simulations Snapshot files for visualization and analysis event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Simulation Termination Executes when the simulation reaches its end time, displaying a summary of key simulation parameters. event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , n %2.1e , OhK %2.1e , Oha %2.1e , J %4.3f , \" \"Bo %4.3f\\n \" , MAXlevel , n , OhK , Oha , J , Bond ); } Simulation Monitoring Tracks key metrics like kinetic energy during simulation and logs to file.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Features Calculates total...",
    "content": "Features Calculates total kinetic energy Logs simulation progress Implements safety checks to stop simulation if instabilities occur event logWriting ( i ++) { // if (i > 5){ // FILE * ftest = fopen(\"test.txt\", \"w\"); // output_facets(f, ftest); // return 1;} double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 2 * pi * y )*( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y [])))* sq ( Delta ); } if ( pid () == 0 ) { static FILE * fp ; if ( i == 0 ) { fprintf ( ferr , \"Level %d , n %2.1e , OhK %2.1e , Oha %2.1e , J %4.3f , \" \"Bo %4.3f\\n \" , MAXlevel , n , OhK , Oha , J , Bond ); fprintf ( ferr , \"i dt t ke \\n \" ); fp = fopen ( logFile , \"w\" ); fprintf ( fp , \"Level %d , n %2.1e , OhK %2.1e , Oha %2.1e , J %4.3f , \" \"Bo %4.3f\\n \" , MAXlevel , n , OhK , Oha , J , Bond ); fprintf ( fp , \"i dt t ke \\n \" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } else { fp = fopen ( logFile , \"a\" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); assert ( ke > - 1e-10 ); if ( ke > 1e2 && i > 1e1 ) { if ( pid () == 0 ) { fprintf ( ferr , \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" ); fp = fopen ( logFile , \"a\" ); fprintf ( fp , \"The kinetic energy blew up. Stopping simulation \\n \" ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } assert ( ke < 1e2 ); if ( ke < 1e-6 && i > 1e1 ) { if ( pid () == 0 ) { fprintf ( ferr , \"Kinetic energy too small now! Stopping! \\n \" ); dump ( file = dumpFile ); fp = fopen ( logFile , \"a\" ); fprintf ( fp , \"Kinetic energy too small now! Stopping! \\n \" ); fclose ( fp ); return 1 ; } } } }",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: C/C++ Code",
    "content": "#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVP-HB.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#if !_MPI#include\"distance.h\"#endif#define tsnap(1e-2)// 0.001 only for some cases.// Error tolerances#define fErr(1e-3)// Error tolerance in f1 VOF#define KErr(1e-6)// Error tolerance in VoF curvature calculated using// height function method (see adapt event)#define VelErr(1e-3)// Error tolerances in velocity -- Use 1e-2 for low Oh// and 1e-3 to 5e-3 for high Oh/moderate to high J#define D2Err(1e-2)// Error tolerances in conformation inside the liquid// Domain size#define Ldomain865// Boundary conditions - outflow on the right boundaryu.n[right]=neumann(0.);p[right]=dirichlet(0.);intMAXlevel;doubleOhK,Oha,J,Bond,tmax;charnameOut[80],dumpFile[80],logFile[80];",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(intargc,charconst*argv[]){L0=Ldomain;origin(-L0/2.,0.);",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "MAXlevel=10;n=0.4;OhK=0.001;J=2e-1;Bond=1e0;tmax=2.5e0;epsilon=1e-2;",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "// First ensure that all the variables were transferred properly from the// terminal or job script.if(argc<7){fprintf(ferr,\"Lack of command line arguments. Check! Need%dmore \"\"arguments\\n\",7-argc);return1;}MAXlevel=atoi(argv[1]);n=atof(argv[2]);OhK=atof(argv[3]);J=atof(argv[4]);Bond=atof(argv[5]);tmax=atof(argv[6]);epsilon=1e-2;",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "init_grid(1<<5);// Create a folder named intermediate where all the simulation snapshots are storedcharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file. See writingFiles eventsprintf(dumpFile,\"restart\");// Name of the log file. See logWriting eventsprintf(logFile,\"logData.dat\");",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "rho1=1.,rho2=1e-3;Oha=2e-2*OhK;mu1=OhK,mu2=Oha;tauy=J;f.sigma=1.0;TOLERANCE=1e-4;CFL=1e-1;run();}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event init(t=0){#if _MPI//...",
    "content": "event init(t=0){#if _MPI// This is for supercomputers without OpenMP supportif(!restore(file=dumpFile)){fprintf(ferr,\"Cannot restored from a dump file!\\n\");}#elseif(!restore(file=dumpFile)){charfilename[60];// sprintf(filename,\"Bo%5.4f-buggy.dat\",Bond);// sprintf(filename,\"Bo%5.4f.dat\",Bond);sprintf(filename,\"Bo%5.4f-buggy_fixed.dat\",Bond);FILE*fp=fopen(filename,\"rb\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);// Try in folder one level up// sprintf(filename,\"../Bo%5.4f-buggy.dat\",Bond);// sprintf(filename,\"../Bo%5.4f.dat\",Bond);sprintf(filename,\"../Bo%5.4f-buggy_fixed.dat\",Bond);fp=fopen(filename,\"rb\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);return1;}}coord*InitialShape;InitialShape=input_xy(fp);fclose(fp);scalar d[];distance(d,InitialShape);while(adapt_wavelet((scalar*){f,d},(double[]){1e-8,1e-8},MAXlevel).nf);// The distance function is defined at the center of each cell, we have// to calculate the value of this function at each vertex.vertex scalar phi[];foreach_vertex(){phi[]=-(d[]+d[-1]+d[0,-1]+d[-1,-1])/4.;}// We can now initialize the volume fraction of the domain.fractions(phi,f);}// return 1;#endif}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);adapt_wavelet((scalar*){f,u.x,u.y,D2,KAPPA},(double[]){fErr,VelErr,VelErr,D2Err,KErr},MAXlevel,MAXlevel-6);}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, n%2.1e, OhK%2.1e, Oha%2.1e, J%4.3f, \"\"Bo%4.3f\\n\",MAXlevel,n,OhK,Oha,J,Bond);}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event logWriting(i++){// if...",
    "content": "event logWriting(i++){// if (i > 5){// FILE * ftest = fopen(\"test.txt\", \"w\");// output_facets(f, ftest);// return 1;}doubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])))*sq(Delta);}if(pid()==0){staticFILE*fp;if(i==0){fprintf(ferr,\"Level%d, n%2.1e, OhK%2.1e, Oha%2.1e, J%4.3f, \"\"Bo%4.3f\\n\",MAXlevel,n,OhK,Oha,J,Bond);fprintf(ferr,\"i dt t ke\\n\");fp=fopen(logFile,\"w\");fprintf(fp,\"Level%d, n%2.1e, OhK%2.1e, Oha%2.1e, J%4.3f, \"\"Bo%4.3f\\n\",MAXlevel,n,OhK,Oha,J,Bond);fprintf(fp,\"i dt t ke\\n\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}else{fp=fopen(logFile,\"a\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);assert(ke>-1e-10);if(ke>1e2&&i>1e1){if(pid()==0){fprintf(ferr,\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Stopping simulation\\n\");fp=fopen(logFile,\"a\");fprintf(fp,\"The kinetic...",
    "content": "Stopping simulation\\n\");fp=fopen(logFile,\"a\");fprintf(fp,\"The kinetic energy blew up. Stopping simulation\\n\");fclose(fp);dump(file=dumpFile);return1;}}assert(ke<1e2);if(ke<1e-6&&i>1e1){if(pid()==0){fprintf(ferr,\"Kinetic energy too small now! Stopping!\\n\");dump(file=dumpFile);fp=fopen(logFile,\"a\");fprintf(fp,\"Kinetic energy too small now! Stopping!\\n\");fclose(fp);return1;}}}}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/getData.c See raw file Fluid Simulation Data Extraction This program extracts and processes data from fluid dynamics simulation snapshots. It calculates key fluid mechanics quantities like strain rate tensor invariants and velocity magnitudes from simulation output files. Physical Background The code analyzes the spatial derivatives of velocity fields to compute the second invariant of the strain rate tensor, which is an important quantity for identifying vortical structures in fluid flows. Additionally, it calculates velocity magnitudes throughout the flow field. The strain rate tensor is a fundamental quantity in fluid mechanics that describes the rate of deformation of fluid elements. Its second invariant is particularly useful for identifying regions of strong vorticity and shear, making it valuable for visualizing coherent structures in turbulent flows.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "Usage ./program filename xmin ymin xmax ymax ny filename: Path to simulation snapshot file xmin, ymin: Minimum coordinates of the region of interest xmax, ymax: Maximum coordinates of the region of interest ny: Number of grid points in y-direction (resolution) @author Vatsal Sanjay @affiliation Physics of Fluids Group, University of Twente @email vatsalsanjay@gmail.com #include \"utils.h\" #include \"output.h\" scalar f []; // Volume fraction field vector u []; // Velocity field char filename [ 80 ]; int nx , ny , len ; double xmin , ymin , xmax , ymax , Deltax , Deltay ; scalar D2c [], vel []; // Derived fields scalar * list = NULL ; // List of fields to output Main Function Processes command line arguments, restores simulation data, computes derived quantities, and outputs results to a formatted file. a: Number of command line arguments arguments: Array of command line argument strings Returns exit status code int main ( int a , char const * arguments []) { // Parse command line arguments sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); // Initialize list of fields to output list = list_add ( list , D2c ); list = list_add ( list , vel ); Data Processing Restores simulation data and calculates derived quantities at each point: D2c: Log10 of the second invariant of the strain rate tensor vel: Velocity magnitude field The strain rate tensor components are computed using finite difference approximations of the velocity gradients. restore ( file = filename ); foreach () { // Calculate components of the strain rate tensor double D11 = ( u . y [ 0 , 1 ] - u . y [ 0 , - 1 ])/( 2 * Delta ); double D22 = ( u . y []/ y ); double D33 = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2 * Delta ); double D13 = 0.5 * (( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 , - 1 ])/( 2 * Delta )); // Calculate the second invariant double D2 = ( sq ( D11 ) + sq ( D22 ) + sq ( D33 ) + 2.0 * sq ( D13 )); D2c [] = f [] * sqrt ( D2 / 2.0 ); // Convert to log scale for better visualization if ( D2c [] > 0. ) { D2c [] = log ( D2c [])/ log ( 10 ); } else { D2c [] = - 10 ; // Floor value for zero or negative values } // Calculate velocity magnitude vel [] = f [] * sqrt ( sq ( u . x []) + sq ( u . y [])); } Data Output This section handles the output of processed data: Calculates the mesh dimensions based on user-specified bounds Interpolates field values onto a regular grid Writes output data to a formatted text file The output format is a space-separated values file with columns: x-coordinate, y-coordinate, followed by values of each field in \u2018list\u2019.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: FILE * fp...",
    "content": "FILE * fp = ferr ; // Calculate grid spacing and dimensions Deltay = ( double )(( ymax - ymin )/( ny )); nx = ( int )(( xmax - xmin )/ Deltay ); Deltax = ( double )(( xmax - xmin )/( nx )); len = list_len ( list ); // Allocate memory for interpolated field values double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); // Interpolate field values onto regular grid for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ) { field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } // Write interpolated data to output file for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ) { fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } // Clean up resources fflush ( fp ); fclose ( fp ); matrix_free ( field ); }",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"scalar f[];// Volume fraction fieldvector u[];// Velocity fieldcharfilename[80];intnx,ny,len;doublexmin,ymin,xmax,ymax,Deltax,Deltay;scalar D2c[],vel[];// Derived fieldsscalar*list=NULL;// List of fields to output",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(inta,charconst*arguments[]){// Parse command line argumentssprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);// Initialize list of fields to outputlist=list_add(list,D2c);list=list_add(list,vel);",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: restore(file=filename);foreach(){// Calculate components...",
    "content": "restore(file=filename);foreach(){// Calculate components of the strain rate tensordoubleD11=(u.y[0,1]-u.y[0,-1])/(2*Delta);doubleD22=(u.y[]/y);doubleD33=(u.x[1,0]-u.x[-1,0])/(2*Delta);doubleD13=0.5*((u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(2*Delta));// Calculate the second invariantdoubleD2=(sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13));D2c[]=f[]*sqrt(D2/2.0);// Convert to log scale for better visualizationif(D2c[]>0.){D2c[]=log(D2c[])/log(10);}else{D2c[]=-10;// Floor value for zero or negative values}// Calculate velocity magnitudevel[]=f[]*sqrt(sq(u.x[])+sq(u.y[]));}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: FILE*fp=ferr;// Calculate grid...",
    "content": "FILE*fp=ferr;// Calculate grid spacing and dimensionsDeltay=(double)((ymax-ymin)/(ny));nx=(int)((xmax-xmin)/Deltay);Deltax=(double)((xmax-xmin)/(nx));len=list_len(list);// Allocate memory for interpolated field valuesdouble**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));// Interpolate field values onto regular gridfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}// Write interpolated data to output filefor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}// Clean up resourcesfflush(fp);fclose(fp);matrix_free(field);}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData.c This program extracts and processes data from fluid dynamics simulation snapshots. It calculates key fluid mechanics ... getFacets.c A utility for extracting interface facets from fluid simulation data. video.py import numpy as np import os import subprocess as sp import matplotlib matplotlib.use('Agg') Use non-interactive back...",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/video.py | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Import Statements",
    "content": "postProcess/video.py See raw file # Author: Vatsal Sanjay # vatsalsanjay@gmail.com # Physics of Fluids # Last updated: Dec 24, 2024 import numpy as np import os import subprocess as sp import matplotlib matplotlib.use( 'Agg' ) # Use non-interactive backend import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import multiprocessing as mp from functools import partial import argparse import matplotlib.colors as mcolors custom_colors = [ \"white\" , \"#DA8A67\" , \"#A0522D\" , \"#400000\" ] custom_cmap = mcolors.LinearSegmentedColormap.from_list( \"custom_hot\" , custom_colors) # Set up matplotlib configuration plt.rcParams[ 'text.usetex' ] = True plt.rcParams[ 'font.family' ] = 'serif' plt.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath} \\ usepackage{amssymb}' plt.rcParams[ 'mathtext.fontset' ] = 'cm' plt.rcParams[ 'font.serif' ] = [ 'Computer Modern Roman' ] + plt.rcParams[ 'font.serif' ] def gettingFacets(filename): exe = [ \"./getFacets\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) skip = True return segs def gettingfield(filename, zmin, rmin, zmax, rmax, nr): exe = [ \"./getData\" , filename, str (zmin), str (rmin), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, D2temp, veltemp = [],[],[],[] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) return R, Z, D2, vel, nz # ---------------------------------------------------------------------------------------------------------------------- def process_timestep(ti, caseToProcess, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw): t = 0.01 * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" if not os.path.exists(place): print ( f\" { place } File not found!\" ) return if os.path.exists(name): print ( f\" { name } Image present!\" ) return # --- Gather interface segments and field data as before --- segs = gettingFacets(place) nr = int (GridsPerR * rmax) R, Z, D2, vel, nz = gettingfield(place, zmin, rmin, zmax, rmax, nr) [xminp, xmaxp, yminp, ymaxp] = R. min (), R. max (), Z. min (), Z. max () extent_vel = [ - xminp, - xmaxp, yminp, ymaxp] extent_D2 = [xminp, xmaxp, yminp, ymaxp] AxesLabel, TickLabel = 30 , 20 fig, ax = plt.subplots( 1 , 1 , figsize = ( 19.20 , 10.80 )) ax.plot([ - rmax, rmax], [ 0 , 0 ], '--' , color = 'grey' , linewidth = lw) # \"horizontal\" axis is z ax.plot([ 0 , 0 ], [zmin, zmax], '-.' , color = 'grey' , linewidth = lw) # \"vertical\" axis is r # Domain box: ax.plot([ - rmax, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax.plot([ - rmax, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([ - rmax, - rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) line_segments = LineCollection(segs, linewidths = 4 , colors = 'green' ) ax.add_collection(line_segments) # ---------------------------------------------------------- # Now show imshow with the rotated arrays and extents: # ---------------------------------------------------------- cntrl1 = ax.imshow( vel, cmap = \"Blues\" , interpolation = 'bilinear' , origin = 'lower' , extent = extent_vel, vmin = 0.0 , vmax = 4e0 ) cntrl2 = ax.imshow( D2, cmap = \"hot_r\" , interpolation = 'bilinear' , origin = 'lower' , extent = extent_D2, vmin =- 3e0 , vmax = 2e0 ) # Equal aspect ensures squares in the new orientation ax.set_aspect( 'equal' ) ax.set_xlim( - rmax, rmax) # x range ax.set_ylim(zmin, zmax) # y range # Titles and labels that match the new orientation ax.set_title( fr' $ t/ \\t au_ {{ \\ gamma }} = { t :.4f} $ ' , fontsize = TickLabel) # Colorbars: place them closer to the plot edges fig.subplots_adjust(left = 0.1 , right = 0.9 ) # adjust spacing for vertical colorbars # Left colorbar cbar_ax1 = fig.add_axes([ 0.07 , 0.15 , 0.02 , 0.7 ]) # x,y,width,height in figure coords c1 = plt.colorbar(cntrl1, cax = cbar_ax1, orientation = 'vertical' ) c1.ax.tick_params(labelsize = TickLabel) c1.set_label( r' $ \\| u_i \\| /V_{ \\ gamma} $ ' , fontsize = AxesLabel, labelpad = 10 , rotation = 90 , position = ( 0 , 0.5 )) c1.ax.yaxis.set_label_position( 'left' ) c1.ax.yaxis.set_ticks_position( 'left' ) # Move ticks to left side c1.ax.tick_params(axis = 'y' , labelright = False , labelleft = True ) # Move tick labels to left side # Right colorbar cbar_ax2 = fig.add_axes([ 0.92 , 0.15 , 0.02 , 0.7 ]) c2 = plt.colorbar(cntrl2, cax = cbar_ax2, orientation = 'vertical' ) c2.ax.tick_params(labelsize = TickLabel) c2.set_label( r' $ \\| \\m athcal{D}_{ij} \\|\\t au_{ \\ gamma} $ ' , fontsize = AxesLabel, labelpad = 10 ) ax.axis( 'off' ) # Save with higher DPI and specific backend plt.savefig(name, bbox_inches = \"tight\" , dpi = 150 , backend = 'agg' ) plt.close() def main(): # Get number of CPUs from command line argument, or use all available import argparse parser = argparse.ArgumentParser() parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use' ) parser.add_argument( '--nGFS' , type = int , default = 256 , help = 'Number of restart files to process' ) parser.add_argument( '--ZMAX' , type = float , default = 1.0 , help = 'Maximum Z value' ) parser.add_argument( '--RMAX' , type = float , default = 4.0 , help = 'Maximum R value' ) parser.add_argument( '--ZMIN' , type = float , default =- 3.0 , help = 'Minimum Z value' ) parser.add_argument( '--RMIN' , type = float , default = 0.0 , help = 'Minimum R value' ) parser.add_argument( '--caseToProcess' , type = str , default = '../testCases/burstingBubbleHB' , help = 'Case to process' ) args = parser.parse_args() CPUStoUse = args.CPUs nGFS = args.nGFS ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN RMIN = args.RMIN caseToProcess = args.caseToProcess num_processes = CPUStoUse rmin, rmax, zmin, zmax = [RMIN, RMAX, ZMIN, ZMAX] GridsPerR = 128 lw = 2 folder = 'Video' if not os.path.isdir(folder): os.makedirs(folder) # Create a pool of worker processes with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, caseToProcess = caseToProcess, folder = folder, nGFS = nGFS, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw) # Map the process_func to all timesteps pool. map (process_func, range (nGFS)) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/video.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/video.py | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: # Author: Vatsal...",
    "content": "# Author: Vatsal Sanjay# vatsalsanjay@gmail.com# Physics of Fluids# Last updated: Dec 24, 2024importnumpyasnpimportosimportsubprocessasspimportmatplotlibmatplotlib.use('Agg')# Use non-interactive backendimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportmultiprocessingasmpfromfunctoolsimportpartialimportargparseimportmatplotlib.colorsasmcolorscustom_colors=[\"white\",\"#DA8A67\",\"#A0522D\",\"#400000\"]custom_cmap=mcolors.LinearSegmentedColormap.from_list(\"custom_hot\", custom_colors)# Set up matplotlib configurationplt.rcParams['text.usetex']=Trueplt.rcParams['font.family']='serif'plt.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}\\usepackage{amssymb}'plt.rcParams['mathtext.fontset']='cm'plt.rcParams['font.serif']=['Computer Modern Roman']+plt.rcParams['font.serif']defgettingFacets(filename):exe=[\"./getFacets\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, rmin, zmax, rmax, nr):exe=[\"./getData\", filename,str(zmin),str(rmin),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, D2temp, veltemp=[],[],[],[]forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))returnR, Z, D2, vel, nz# ----------------------------------------------------------------------------------------------------------------------defprocess_timestep(ti, caseToProcess, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw):t=0.01*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"ifnotos.path.exists(place):print(f\"{place}File not found!\")returnifos.path.exists(name):print(f\"{name}Image present!\")return# --- Gather interface segments and field data as before ---segs=gettingFacets(place)nr=int(GridsPerR*rmax)R, Z, D2, vel, nz=gettingfield(place, zmin, rmin, zmax, rmax, nr)[xminp, xmaxp, yminp, ymaxp]=R.min(), R.max(), Z.min(), Z.max()extent_vel=[-xminp,-xmaxp, yminp, ymaxp]extent_D2=[xminp, xmaxp, yminp, ymaxp]AxesLabel, TickLabel=30,20fig, ax=plt.subplots(1,1, figsize=(19.20,10.80))ax.plot([-rmax, rmax], [0,0],'--', color='grey', linewidth=lw)# \"horizontal\" axis is zax.plot([0,0], [zmin, zmax],'-.', color='grey', linewidth=lw)# \"vertical\" axis is r# Domain box:ax.plot([-rmax, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax.plot([-rmax, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax.plot([-rmax,-rmax], [zmin, zmax],'-', color='black', linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)line_segments=LineCollection(segs, linewidths=4, colors='green')ax.add_collection(line_segments)# ----------------------------------------------------------# Now show imshow with the rotated arrays and extents:# ----------------------------------------------------------cntrl1=ax.imshow(vel,cmap=\"Blues\",interpolation='bilinear',origin='lower',extent=extent_vel,vmin=0.0,vmax=4e0)cntrl2=ax.imshow(D2,cmap=\"hot_r\",interpolation='bilinear',origin='lower',extent=extent_D2,vmin=-3e0,vmax=2e0)# Equal aspect ensures squares in the new orientationax.set_aspect('equal')ax.set_xlim(-rmax, rmax)# x rangeax.set_ylim(zmin, zmax)# y range# Titles and labels that match the new orientationax.set_title(fr'$t/\\tau_{{\\gamma}}={t:.4f}$', fontsize=TickLabel)# Colorbars: place them closer to the plot edgesfig.subplots_adjust(left=0.1, right=0.9)# adjust spacing for vertical colorbars# Left colorbarcbar_ax1=fig.add_axes([0.07,0.15,0.02,0.7])# x,y,width,height in figure coordsc1=plt.colorbar(cntrl1, cax=cbar_ax1, orientation='vertical')c1.ax.tick_params(labelsize=TickLabel)c1.set_label(r'$\\|u_i\\|/V_{\\gamma}$', fontsize=AxesLabel, labelpad=10, rotation=90, position=(0,0.5))c1.ax.yaxis.set_label_position('left')c1.ax.yaxis.set_ticks_position('left')# Move ticks to left sidec1.ax.tick_params(axis='y', labelright=False, labelleft=True)# Move tick labels to left side# Right colorbarcbar_ax2=fig.add_axes([0.92,0.15,0.02,0.7])c2=plt.colorbar(cntrl2, cax=cbar_ax2, orientation='vertical')c2.ax.tick_params(labelsize=TickLabel)c2.set_label(r'$\\|\\mathcal{D}_{ij}\\|\\tau_{\\gamma}$', fontsize=AxesLabel, labelpad=10)ax.axis('off')# Save with higher DPI and specific backendplt.savefig(name, bbox_inches=\"tight\", dpi=150, backend='agg')plt.close()defmain():# Get number of CPUs from command line argument, or use all availableimportargparseparser=argparse.ArgumentParser()parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use')parser.add_argument('--nGFS',type=int, default=256,help='Number of restart files to process')parser.add_argument('--ZMAX',type=float, default=1.0,help='Maximum Z value')parser.add_argument('--RMAX',type=float, default=4.0,help='Maximum R value')parser.add_argument('--ZMIN',type=float, default=-3.0,help='Minimum Z value')parser.add_argument('--RMIN',type=float, default=0.0,help='Minimum R value')parser.add_argument('--caseToProcess',type=str, default='../testCases/burstingBubbleHB',help='Case to process')args=parser.parse_args()CPUStoUse=args.CPUsnGFS=args.nGFSZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMINRMIN=args.RMINcaseToProcess=args.caseToProcessnum_processes=CPUStoUsermin, rmax, zmin, zmax=[RMIN, RMAX, ZMIN, ZMAX]GridsPerR=128lw=2folder='Video'ifnotos.path.isdir(folder):os.makedirs(folder)# Create a pool of worker processeswithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep, caseToProcess=caseToProcess,folder=folder, nGFS=nGFS,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw)# Map the process_func to all timestepspool.map(process_func,range(nGFS))if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/video.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/getFacets.c See raw file Getting Facets A utility for extracting interface facets from fluid simulation data. Description This program extracts and outputs the facets representing the interface between different phases in a multiphase flow simulation. The facets define the boundary between fluid phases, useful for geometric analysis and visualization of the interface morphology. Physics Background In multiphase fluid simulations, interfaces between different fluids are critical features that determine many physical phenomena like surface tension effects, droplet formation, and coalescence events. This utility identifies these interfaces by extracting facets from volume fraction data, allowing for quantitative analysis of interfacial dynamics.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getFacets.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "Usage ./getFacets input_file Author: Vatsal Sanjay vatsalsanjay@gmail.com Physics of Fluids Department University of Twente #include \"utils.h\" #include \"output.h\" #include \"fractions.h\" scalar f []; // Volume fraction field char filename [ 80 ]; Main Function Loads a simulation snapshot and extracts the interface facets. Input parameters: arguments[1] : Filename of the simulation snapshot to process Process: Restores the simulation state from the specified file Extracts interface facets from the volume fraction field Outputs facet data to standard error Return value: Returns 0 on successful completion Note: The facet extraction algorithm identifies where the volume fraction field crosses a threshold value (typically 0.5) between adjacent cells. int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); FILE * fp = ferr ; output_facets ( f , fp ); fflush ( fp ); fclose ( fp ); return 0 ; }",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getFacets.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"fractions.h\"scalar f[];// Volume fraction fieldcharfilename[80];",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getFacets.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);restore(file=filename);FILE*fp=ferr;output_facets(f,fp);fflush(fp);fclose(fp);return0;}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getFacets.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files two-phaseVP-HB.h This is a modified version of [two-phase.h](http://basilisk.fr/src/two-phase.h). It contains the implementation of Vi...",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "src-local/two-phaseVP-HB.h See raw file Modification by Vatsal Sanjay Version 4.0, Jan 1, 2025 Changelog Jan 1, 2025 (v4.0) There was a bug in calculation of D2 which would trigger while using parallel computing only. This has been fixed. Dec 31, 2024 (v3.5) Added the Herschel-Bulkley formulation. n = 1 recovers the Bingham formulation. n = 1, tau_y = 0 recovers the Newtonian formulation. Oct 11, 2024 (v2.0) Using the epsilon formulation for the viscoplastic fluid. Unified the code to handle both planar and axi-symmetric cases seamlessly. This eliminates the need for a separate codebase when switching to axi-symmetric formulations. Only fluid 1 can be viscoplastic, fluid 2 is always Newtonian.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "Brief history: v0.0 is of course the original code on http://basilisk.fr/src/two-phase.h valid for Newtonian fluids. v1.0 is the modification for viscoplastic fluids using the min(temp, mumax) formulation where one needed to use a separate codebase for axi-symmetric cases (see: git@github.com:VatsalSy/Bursting-Bubble-In-a-Viscoplastic-Medium.git). v2.0 is the modification for viscoplastic fluids using the epsilon formulation (this code) where I also unified the code to handle both planar and axi-symmetric cases seamlessly. Two-phase interfacial flows This is a modified version of two-phase.h . It contains the implementation of Viscoplastic Fluid (Bingham Fluid). This file helps setup simulations for flows of two fluids separated by an interface (i.e. immiscible fluids). It is typically used in combination with a Navier\u2013Stokes solver . The interface between the fluids is tracked with a Volume-Of-Fluid method. The volume fraction in fluid 1 is \\(f=1\\) and \\(f=0\\) in fluid 2.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "The densities and dynamic viscosities for fluid 1 and 2 are rho1 , mu1 , rho2 , mu2 , respectively. #include \"vof.h\" scalar f [], * interfaces = { f }; scalar D2 []; face vector D2f []; double rho1 = 1. , mu1 = 0. , rho2 = 1. , mu2 = 0. ; double epsilon = 1e-6 , tauy = 0. , n = 1. ; Auxilliary fields are necessary to define the (variable) specific volume \\(\\alpha=1/\\rho\\) as well as the cell-centered density. face vector alphav []; scalar rhov []; event defaults ( i = 0 ) { alpha = alphav ; rho = rhov ; If the viscosity is non-zero, we need to allocate the face-centered viscosity field. mu = new face vector ; } The density and viscosity are defined using arithmetic averages by default.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Definitions - Python Function",
    "content": "The user can overload these definitions to use other types of averages (i.e. harmonic). #ifndef rho # define rho ( f ) ( clamp ( f , 0. , 1. )*( rho1 - rho2 ) + rho2 ) 66 #endif #ifndef mu // for Arithmetic mean, use this // # define mu(muTemp, mu2, f) (clamp(f,0.,1.)*(muTemp - mu2) + mu2) // for Harmonic mean, use this # define mu ( muTemp , mu2 , f ) ( 1.0 / (( clamp ( f , 0. , 1. ) / muTemp ) + (( 1.0 - clamp ( f , 0. , 1. )) / mu2 ))) 72 #endif We have the option of using some \u201csmearing\u201d of the density/viscosity jump. #ifdef FILTERED scalar sf []; #else # define sf f 82 #endif event tracer_advection ( i ++) { When using smearing of the density jump, we initialise sf with the vertex-average of f . #ifndef sf #if dimension <= foreach () sf [] = ( 4. * f [] + 2. *( f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 1 , 0 ] + f [- 1 , 0 ]) + f [- 1 ,- 1 ] + f [ 1 ,- 1 ] + f [ 1 , 1 ] + f [- 1 , 1 ])/ 16. ; #else // dimension == foreach () sf [] = ( 8. * f [] + 4. *( f [- 1 ] + f [ 1 ] + f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 0 , 0 , 1 ] + f [ 0 , 0 ,- 1 ]) + 2. *( f [- 1 , 1 ] + f [- 1 , 0 , 1 ] + f [- 1 , 0 ,- 1 ] + f [- 1 ,- 1 ] + f [ 0 , 1 , 1 ] + f [ 0 , 1 ,- 1 ] + f [ 0 ,- 1 , 1 ] + f [ 0 ,- 1 ,- 1 ] + f [ 1 , 1 ] + f [ 1 , 0 , 1 ] + f [ 1 ,- 1 ] + f [ 1 , 0 ,- 1 ]) + f [ 1 ,- 1 , 1 ] + f [- 1 , 1 , 1 ] + f [- 1 , 1 ,- 1 ] + f [ 1 , 1 , 1 ] + f [ 1 , 1 ,- 1 ] + f [- 1 ,- 1 ,- 1 ] + f [ 1 ,- 1 ,- 1 ] + f [- 1 ,- 1 , 1 ])/ 64. ; #endif #endif #if TREE sf . prolongation = refine_bilinear ; sf . dirty = true ; // boundary conditions need to be updated #endif } event properties ( i ++) { This is the part where we have made changes. # Herschel\u2013Bulkley formulation for non-Newtonian flows ## Features: * Yield stress \\(\\tau_y\\) * Power law dependance on the strain rate * Shear thinning for \\(n < 1\\) . * Shear thickening for \\(n > 1\\) . * Bingham model for \\(n = 1\\) . * Newtonian fluid for \\(n = 1\\) and \\(\\tau_y = 0\\) . \\(\\varepsilon\\) -formulation \\[ \\boldsymbol{\\tau} = \\tau_{y}\\,\\boldsymbol{\\mathcal{I}} \\;+\\; K\\left(2\\boldsymbol{\\mathcal{D}}\\right)^{n} = 2\\biggl[\\frac{\\tau_{y}}{2\\|\\boldsymbol{\\mathcal{D}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + K\\,\\bigl(2\\|\\boldsymbol{\\mathcal{D}}\\|+\\epsilon\\bigr)^{n-1} \\biggr]\\boldsymbol{\\mathcal{D}}. \\] Normalizing stresses with \\(\\gamma/R_0\\) , length with \\(R_0\\) , and velocity with \\(\\sqrt{\\gamma/\\rho_lR_0}\\) \u2026 \\[ \\boldsymbol{\\tilde{\\tau}} = 2\\biggl[\\frac{\\mathcal{J}}{2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + Oh_K\\,\\bigl(2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\epsilon\\bigr)^{n-1} \\biggr]\\boldsymbol{\\tilde{\\mathcal{D}}}. \\] Here, the effective Ohnesorge is \\[ Oh_K = \\frac{K}{\\sqrt{\\rho_l^n\\gamma^{2-n}R_0^{3n-2}}} \\] One can easily see that putting \\(n = 1\\) recovers the Bingham model with \\(Oh = \\eta_l/\\sqrt{\\rho_l\\gamma R_0}\\) .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Additionally, with \\(n...",
    "content": "Additionally, with \\(n = 1\\) & \\(\\mathcal{J}\\) = 0, the model will give a Newtonian response.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: More details on...",
    "content": "More details on the implementation Calculate the norm of the deformation tensor \\(\\boldsymbol{\\mathcal{D}}\\) : \\[\\mathcal{D}_{11} = \\frac{\\partial u_r}{\\partial r}\\] \\[\\mathcal{D}_{22} = \\frac{u_r}{r}\\] \\[\\mathcal{D}_{13} = \\frac{1}{2}\\left( \\frac{\\partial u_r}{\\partial z}+ \\frac{\\partial u_z}{\\partial r}\\right)\\] \\[\\mathcal{D}_{31} = \\frac{1}{2}\\left( \\frac{\\partial u_z}{\\partial r}+ \\frac{\\partial u_r}{\\partial z}\\right)\\] \\[\\mathcal{D}_{33} = \\frac{\\partial u_z}{\\partial z}\\] \\[\\mathcal{D}_{12} = \\mathcal{D}_{23} = 0.\\] The second invariant is \\(\\mathcal{D}_2=\\sqrt{\\mathcal{D}_{ij}\\mathcal{D}_{ij}}\\) (this is the Frobenius norm) \\[\\mathcal{D}_2^2= \\mathcal{D}_{ij}\\mathcal{D}_{ij}= \\mathcal{D}_{11}\\mathcal{D}_{11} + \\mathcal{D}_{22}\\mathcal{D}_{22} + \\mathcal{D}_{13}\\mathcal{D}_{31} + \\mathcal{D}_{31}\\mathcal{D}_{13} + \\mathcal{D}_{33}\\mathcal{D}_{33}\\] Note: \\(\\|\\mathcal{D}\\| = D_2/\\sqrt{2}\\) .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: We use the...",
    "content": "We use the formulation as given in Balmforth et al. (2013) [@balmforthYieldingStressRecent2014] , who use the strain rate tensor \\(\\boldsymbol{\\dot{\\mathcal{S}}}\\) which and its norm \\(\\sqrt{\\frac{1}{2}\\dot{\\mathcal{S}_{ij}}\\dot{\\mathcal{S}_{ij}}}\\) . Of course, given \\(\\dot{\\mathcal{S}}_{ij}=2 D_{ij}\\) . Calculate the equivalent viscosity Factorizing with \\(2 \\mathcal{D}_{ij}\\) to obtain an equivalent viscosity \\[\\eta_{\\text{eff}} = \\frac{\\mathcal{J}}{2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + Oh_K\\,\\bigl(2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\epsilon\\bigr)^{n-1} \\] In this formulation, \\(\\varepsilon\\) is a small number to ensure numerical stability. The term \\[\\frac{\\tau_y}{\\varepsilon} + ...\\] is equivalent to the \\(\\mu_{max}\\) of the previous (v1.0, see: GitHub ) formulation [@sanjayBurstingBubbleViscoplastic2021] . Note: The fluid flows always, it is not a solid, but a very viscous fluid. Reproduced from: P.-Y. Lagr\u00e9e\u2019s Sandbox .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "Here, we use a face implementation of the regularisation method, described here . foreach_face ( x ) { double ff = ( sf [] + sf [- 1 ])/ 2. ; alphav . x [] = fm . x []/ rho ( ff ); double muTemp = mu1 ; face vector muv = mu ; double D2temp = 0. ; D2temp += sq ( 0.5 *( ( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ] + u . y [- 1 , 1 ] - u . y [- 1 ,- 1 ])/( 2. * Delta ) )); // D11 #if AXI D2temp += sq (( u . y [ 0 , 0 ] + u . y [- 1 , 0 ])/( 2 * max ( y , 1e-20 ))); // D22 #endif D2temp += sq (( u . x [] - u . x [- 1 , 0 ])/ Delta ); // D33 D2temp += 2.0 * sq ( 0.5 *( ( u . y [] - u . y [- 1 , 0 ])/ Delta + 0.5 *( ( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . x [- 1 , 1 ] - u . x [- 1 ,- 1 ])/( 2. * Delta ) ) )); // D13 D2temp = sqrt ( D2temp / 2.0 ); if ( tauy > 0. ){ muTemp = tauy /( 2.0 * D2temp + epsilon ) + mu1 * pow (( 2.0 * D2temp + epsilon ), n - 1 ); } muv . x [] = fm . x []* mu ( muTemp , mu2 , ff ); D2f . x [] = D2temp ; } foreach_face ( y ) { double ff = ( sf [ 0 , 0 ] + sf [ 0 ,- 1 ])/ 2. ; alphav . y [] = fm . y []/ rho ( ff ); double muTemp = mu1 ; face vector muv = mu ; double D2temp = 0. ; D2temp += sq (( u . y [ 0 , 0 ] - u . y [ 0 ,- 1 ])/ Delta ); // D11 #if AXI D2temp += sq (( u . y [ 0 , 0 ] + u . y [ 0 ,- 1 ])/( 2 * max ( y , 1e-20 ))); // D22 #endif D2temp += sq ( 0.5 *( ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ] + u . x [ 1 ,- 1 ] - u . x [- 1 ,- 1 ])/( 2. * Delta ) )); // D33 D2temp += 2.0 * sq ( 0.5 *( ( u . x [ 0 , 0 ] - u . x [ 0 ,- 1 ])/ Delta + 0.5 *( ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . y [ 1 ,- 1 ] - u . y [- 1 ,- 1 ])/( 2. * Delta ) ) )); // D13 D2temp = sqrt ( D2temp / 2.0 ); if ( tauy > 0. ){ muTemp = tauy /( 2.0 * D2temp + epsilon ) + mu1 * pow (( 2.0 * D2temp + epsilon ), n - 1 ); } muv . y [] = fm . y []* mu ( muTemp , mu2 , ff ); D2f . y [] = D2temp ; } #if dimension == error ( \"3D not implemented yet\" ); #endif I also calculate a cell-centered scalar D2, where I store \\(\\|\\mathbf{\\mathcal{D}}\\|\\) .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: This can also...",
    "content": "This can also be used for refimnement to accurately refine the fake-yield surfaces. foreach (){ rhov [] = cm []* rho ( sf []); D2 [] = f []*( D2f . x []+ D2f . y []+ D2f . x [ 1 , 0 ]+ D2f . y [ 0 , 1 ])/ 4. ; } #if TREE sf . prolongation = fraction_refine ; sf . dirty = true ; // boundary conditions need to be updated #endif }",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"vof.h\"scalar f[],*interfaces={f};scalar D2[];face vector D2f[];doublerho1=1.,mu1=0.,rho2=1.,mu2=0.;doubleepsilon=1e-6,tauy=0.,n=1.;",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "face vector alphav[];scalar rhov[];event defaults(i=0){alpha=alphav;rho=rhov;",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Function: rho",
    "content": "#ifndef rho# define rho(f)(clamp(f,0.,1.)*(rho1-rho2)+rho2)66#endif#ifndef mu// for Arithmetic mean, use this// # define mu(muTemp, mu2, f)  (clamp(f,0.,1.)*(muTemp - mu2) + mu2)// for Harmonic mean, use this# define mu(muTemp,mu2,f)(1.0/((clamp(f,0.,1.)/muTemp)+((1.0-clamp(f,0.,1.))/mu2)))72#endif",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Function: FILTEREDscalar",
    "content": "#ifdef FILTEREDscalar sf[];#else# define sf f82#endifevent tracer_advection(i++){",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Function: sf",
    "content": "#ifndef sf#if dimension <=foreach()sf[]=(4.*f[]+2.*(f[0,1]+f[0,-1]+f[1,0]+f[-1,0])+f[-1,-1]+f[1,-1]+f[1,1]+f[-1,1])/16.;#else// dimension ==foreach()sf[]=(8.*f[]+4.*(f[-1]+f[1]+f[0,1]+f[0,-1]+f[0,0,1]+f[0,0,-1])+2.*(f[-1,1]+f[-1,0,1]+f[-1,0,-1]+f[-1,-1]+f[0,1,1]+f[0,1,-1]+f[0,-1,1]+f[0,-1,-1]+f[1,1]+f[1,0,1]+f[1,-1]+f[1,0,-1])+f[1,-1,1]+f[-1,1,1]+f[-1,1,-1]+f[1,1,1]+f[1,1,-1]+f[-1,-1,-1]+f[1,-1,-1]+f[-1,-1,1])/64.;#endif#endif#if TREEsf.prolongation=refine_bilinear;sf.dirty=true;// boundary conditions need to be updated#endif}event properties(i++){",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "foreach_face(x){doubleff=(sf[]+sf[-1])/2.;alphav.x[]=fm.x[]/rho(ff);doublemuTemp=mu1;face vector muv=mu;doubleD2temp=0.;D2temp+=sq(0.5*((u.y[0,1]-u.y[0,-1]+u.y[-1,1]-u.y[-1,-1])/(2.*Delta)));// D11#if AXID2temp+=sq((u.y[0,0]+u.y[-1,0])/(2*max(y,1e-20)));// D22#endifD2temp+=sq((u.x[]-u.x[-1,0])/Delta);// D33D2temp+=2.0*sq(0.5*((u.y[]-u.y[-1,0])/Delta+0.5*((u.x[0,1]-u.x[0,-1]+u.x[-1,1]-u.x[-1,-1])/(2.*Delta))));// D13D2temp=sqrt(D2temp/2.0);if(tauy>0.){muTemp=tauy/(2.0*D2temp+epsilon)+mu1*pow((2.0*D2temp+epsilon),n-1);}muv.x[]=fm.x[]*mu(muTemp,mu2,ff);D2f.x[]=D2temp;}foreach_face(y){doubleff=(sf[0,0]+sf[0,-1])/2.;alphav.y[]=fm.y[]/rho(ff);doublemuTemp=mu1;face vector muv=mu;doubleD2temp=0.;D2temp+=sq((u.y[0,0]-u.y[0,-1])/Delta);// D11#if AXID2temp+=sq((u.y[0,0]+u.y[0,-1])/(2*max(y,1e-20)));// D22#endifD2temp+=sq(0.5*((u.x[1,0]-u.x[-1,0]+u.x[1,-1]-u.x[-1,-1])/(2.*Delta)));// D33D2temp+=2.0*sq(0.5*((u.x[0,0]-u.x[0,-1])/Delta+0.5*((u.y[1,0]-u.y[-1,0]+u.y[1,-1]-u.y[-1,-1])/(2.*Delta))));// D13D2temp=sqrt(D2temp/2.0);if(tauy>0.){muTemp=tauy/(2.0*D2temp+epsilon)+mu1*pow((2.0*D2temp+epsilon),n-1);}muv.y[]=fm.y[]*mu(muTemp,mu2,ff);D2f.y[]=D2temp;}#if dimension ==error(\"3D not implemented yet\");#endif",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "foreach(){rhov[]=cm[]*rho(sf[]);D2[]=f[]*(D2f.x[]+D2f.y[]+D2f.x[1,0]+D2f.y[0,1])/4.;}#if TREEsf.prolongation=fraction_refine;sf.dirty=true;// boundary conditions need to be updated#endif}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "News - April",
    "content": "- Vatsal Sanjay awarded the Ammodo Science Fellowship . His research will focus on understanding fluid dynamics in fungal networks\u2014investigating how these vast underground systems transport water, nutrients, and genetic information across ecosystems. Read More Image credit: J. Heitman, B. J. Howlett, P. W. Crous, E. H. Stukenbrock, T. Y. James & N. A. R. Gow, The fungal kingdom, John Wiley & Sons (2020)",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "News - March",
    "content": "- Prof. Detlef Lohse shares his scientific journey in The Living Histories Series . His inspiring discussion on curiosity, mentorship, and the \"puzzle solving\" joy of science offers valuable insights for researchers at all career stages. Watch on YouTube Sanjay, V. , & Lohse, D. Unifying theory of scaling in drop impact: Forces & maximum spreading diameter. Published in Physical Review Letters.](/research#15) View Paper --> - Join us for a hybrid online+offline course: [High-Fidelity Simulations Using Basilisk C](/teaching/2025-Basilisk101-Madrid) in Madrid, Spain (March 10-13). Learn some computational (colorful) fluid dynamics with hands-on coding sessions.",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "News - February",
    "content": "- [ Sanjay, V. , Zhang, B., Lv, C., & Lohse, D. J. Fluid Mech., 1004, A6 (2025) selected as the cover article.](/research#14) Download Cover View Paper - Milan Sent graduated with a bachelor's degree from University of Twente. Thesis: Spinning Pizza",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "News - December",
    "content": "[Balasubramanian, A. G., Sanjay, V. , Jalaal, M., Vinuesa, R., & Tammisola, O. J. Fluid Mech., 1001, A9 (2024). selected as the cover article.](/research#12) Download Cover View Paper",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "News - November",
    "content": "Vatsal Sanjay recognized as an Outstanding Reviewer 2023 by the Journal of Fluid Mechanics for his contributions to the peer review process.",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "News - May",
    "content": "Vatsal Sanjay awarded the KIVI Hoogendoorn Fluid Mechanics Award 2023 for his PhD thesis \"Viscous Free-Surface Flows\". The award ceremony took place at the Burgers Symposium on 29\u201330 May 2024 in Lunteren.",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - About Us",
    "content": "We are based at the Physics of Fluids Department at the University of Twente, where we investigate [**non-Newtonian free-surface flows**](/research/?tag=Non-Newtonian) and [**soft matter singularities**](/research/?tag=Soft-matter-singularities). Our group employs a synergy of continuum simulations, experiments (through collaborations), and theoretical analysis to understand phenomena ranging involving drops, bubbles, jets, sheets, and more. We strive to connect fundamental findings with real-world applications, from industrial processes to everyday fluid dynamics.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Soft Matter Singularities",
    "content": "We examine topological transitions in fluid systems\u2014such as [**droplet impact**](/research/?tag=Drops), [**bubble bursting**](/research/?tag=Bubbles), and [**sheet fragmentation**](/research/?tag=Sheets) \u2014 where local instabilities drive fast, often dramatic flow dynamics. Our goal is to expose the universal mechanisms governing these [**singular**](/research/?tag=Soft-matter-singularities) events in soft matter.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Non-Newtonian Flows as the `Drosophila' of Continuum Mechanics",
    "content": "From [**elastoviscoplastic**](/research/?tag=Non-Newtonian) bubble bursting and elastic sheet break-up to champagne [**bubble**](/research/?tag=Bubbles) bursting and classical Taylor\u2013Culick retractions, non-Newtonian fluids serve as model systems to explore the fundamentals of continuum mechanics. By integrating high-fidelity simulations, analytical frameworks, and collaborative experiments, we reveal how microstructural stresses affect fluid and solid dynamics. This research provides key insights for industrial and environmental applications.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Viscous Free-Surface Flows",
    "content": "We investigate various viscous free-surface flows including inertial contact lines, [**bubble**](/research/?tag=Bubbles) removal, and focusing of [**waves**](/research/?tag=Waves). These phenomena are critical to energy transitions and manufacturing. For instance, a key challenge is optimizing bubble detachment in electrolysis to boost efficiency. This research involves advanced numerical methods and industry partnerships, with the broader aim of advancing technologies from chemical reactors to printing processes.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Commitment to Open Science",
    "content": "Open exchange of ideas drives our progress. We share our codes from the earliest stages of development, embracing transparent research practices to foster collaboration and reproducibility. We welcome inquiries and partnerships from the broader scientific community. Watchout for [![GitHub](https://img.shields.io/badge/GitHub-100000?style=flat-square&logo=github&logoColor=white)](https://github.com/comphy-lab) and [ ](https://github.com/comphy-lab \"Visit our GitHub organization\") on this website to interact with our codes. Feel free to contact us for discussions about our work or anything else related to fluid physics. Nothing is more exhilarating than a healthy scientific discussion.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Location & Website",
    "content": "[![Location](https://img.shields.io/badge/-Physics%20of%20Fluids-4285F4?style=flat&logo=googlemaps&logoColor=white)](https://maps.app.goo.gl/jSTCYnfcndF1uZPV8) [![Website](https://img.shields.io/badge/-comphy--lab.org-4285F4?style=flat&logo=googlechrome&logoColor=white)](http://www.comphy-lab.org) [![Email](https://img.shields.io/badge/-mailto:vatsalsy@comphy--lab.org-EA4335?style=flat&logo=gmail&logoColor=white)](mailto:vatsalsy@comphy-lab.org) vatsalsy@comphy-lab.org",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Academic Profiles",
    "content": "[![Google Scholar](https://img.shields.io/badge/-Google%20Scholar-4285F4?style=flat&logo=googlescholar&logoColor=white)](https://scholar.google.com/citations?user=tHb_qZoAAAAJ&hl=en) [![ORCID](https://img.shields.io/badge/-ORCID-A6CE39?style=flat&logo=orcid&logoColor=white)](https://orcid.org/0000-0002-4293-6099) [![arXiv](https://img.shields.io/badge/-arXiv-B31B1B?style=flat&logo=arxiv&logoColor=white)](https://arxiv.org/search/?query=vatsal+sanjay&searchtype=all&source=header) [![ResearchGate](https://img.shields.io/badge/-ResearchGate-00CCBB?style=flat&logo=researchgate&logoColor=white)](https://www.researchgate.net/profile/Vatsal-Sanjay-2)",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Social Media",
    "content": "[![X](https://img.shields.io/badge/-@CoMPhyLab-000000?style=flat&logo=x&logoColor=white)](https://twitter.com/VatsalSanjay) [![Bluesky](https://img.shields.io/badge/-@comphy--lab.org-0285FF?style=flat&logo=bluesky&logoColor=white)](https://bsky.app/profile/comphy-lab.org) For supplementary videos and teaser of our upcoming work:",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Index - Computational MultiphasePhysics (CoMPhy) Lab",
    "content": "Computational Multiphase Physics (CoMPhy) Lab Picture: Worthington jet formed due to bursting bubble. Featured Research",
    "url": "https://comphy-lab.org#intro",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "404 - 404! But, there are no dragons either.",
    "content": "404! But, there are no dragons either. Seems like you didn't find what you wanted. But don't worry - we've got plenty of exciting projects waiting for you to explore! Check Out: Take Me Home",
    "url": "https://comphy-lab.org#intro",
    "type": "website_section",
    "priority": 8
  }
]